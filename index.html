<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mission Control - MoltBot</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Login Required Screen (shown when not authenticated) -->
    <div id="login-screen" class="login-screen">
        <div class="login-container">
            <div class="login-logo">ğŸ¯</div>
            <h1 class="login-title">Mission Control</h1>
            <p class="login-subtitle">Task & Project Management Dashboard</p>

            <div class="login-card">
                <h2>ğŸ” Login Required</h2>
                <p>Connect your GitHub account to access the dashboard.</p>

                <div class="login-steps">
                    <div class="login-step">
                        <span class="login-step-num">1</span>
                        <div>
                            <strong>Create a Personal Access Token</strong>
                            <a href="https://github.com/settings/tokens/new?scopes=repo&description=Mission%20Control%20Dashboard" target="_blank" class="login-link">
                                Create token on GitHub â†’
                            </a>
                        </div>
                    </div>
                    <div class="login-step">
                        <span class="login-step-num">2</span>
                        <div>
                            <strong>Select "repo" scope</strong>
                            <span class="login-hint">Allows read/write access to repositories</span>
                        </div>
                    </div>
                    <div class="login-step">
                        <span class="login-step-num">3</span>
                        <div>
                            <strong>Paste your token below</strong>
                            <span class="login-hint">Starts with "ghp_"</span>
                        </div>
                    </div>
                </div>

                <div class="login-form">
                    <input type="password" id="login-token-input" class="login-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <button id="login-btn" class="login-btn" onclick="handleLogin()">
                        <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                        </svg>
                        Connect with GitHub
                    </button>
                    <div id="login-error" class="login-error"></div>
                    <div id="login-loading" class="login-loading">
                        <div class="spinner"></div>
                        <span>Validating...</span>
                    </div>
                </div>

                <p class="login-security">ğŸ”’ Your token is stored locally and never sent anywhere except GitHub.</p>
            </div>
        </div>
    </div>

    <!-- Main Dashboard (hidden until authenticated) -->
    <div id="dashboard" class="dashboard" style="display: none;">

    <header class="header">
        <div class="header-left">
            <div class="logo">
                <span>ğŸ¯</span>
                <span>Mission Control</span>
            </div>
            <nav class="nav-tabs">
                <div class="nav-tab active" data-view="tasks" onclick="switchView('tasks')">Tasks</div>
                <div class="nav-tab" data-view="skills" onclick="switchView('skills')">Skills</div>
                <div class="nav-tab" data-view="brain" onclick="switchView('brain')">Brain</div>
                <div class="nav-tab" data-view="docs" onclick="switchView('docs')">Docs</div>
                <div class="nav-tab" data-view="people" onclick="switchView('people')">Team</div>
            </nav>
            
            <!-- Search -->
            <div class="search-container">
                <div class="search-input-wrapper">
                    <input type="text" 
                           id="search-input" 
                           class="search-input" 
                           placeholder="Search tasks..." 
                           oninput="handleSearch(this.value)"
                           onkeydown="if(event.key==='Escape'){clearSearch()}">
                    <svg class="search-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="M21 21l-4.35-4.35"></path>
                    </svg>
                    <button class="search-clear" onmousedown="event.preventDefault()" onclick="clearSearch()" title="Clear search">Ã—</button>
                </div>
                <span class="search-info" id="search-info"></span>
                <label class="archive-search-toggle" title="Include archived tasks in search">
                    <input type="checkbox" id="search-include-archived" onchange="toggleArchiveSearch(this.checked)">
                    <span>ğŸ“¦ Archive</span>
                </label>
            </div>
        </div>
        <div class="header-right">
            <span class="live-indicator live" id="live-indicator">Live</span>
            <button class="btn btn-secondary" onclick="pollForUpdates(); window.location.reload()">â†» Refresh</button>

            <!-- Not Logged In -->
            <button class="btn btn-github" id="btn-connect" onclick="showAuthModal()">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                Connect GitHub
            </button>

            <!-- Logged In (hidden by default) -->
            <div class="user-profile" id="user-profile" style="display: none;">
                <img class="user-avatar" id="user-avatar" src="" alt="Avatar">
                <span class="user-name" id="user-name"></span>
                <button class="btn-icon" onclick="showSettingsModal()" title="Settings">âš™ï¸</button>
                <span class="user-logout" onclick="logout()">Logout</span>
            </div>
        </div>
    </header>

    <!-- Unsaved Changes Banner -->
    <div class="unsaved-banner" id="unsaved-banner">
        <span class="unsaved-text">âš ï¸ You have unsaved changes</span>
        <div>
            <button class="btn btn-secondary btn-small" onclick="discardChanges()">Discard</button>
            <button class="btn btn-primary btn-small" onclick="showCommitModal()">Save & Commit</button>
        </div>
    </div>

    <!-- TASKS VIEW -->
    <div id="view-tasks" class="view active">

    <div class="stats-bar">
        <div class="stat">
            <span class="stat-value" id="stat-week">0</span>
            <span class="stat-label">This week</span>
        </div>
        <div class="stat">
            <span class="stat-value" id="stat-progress">0</span>
            <span class="stat-label">In progress</span>
        </div>
        <div class="stat">
            <span class="stat-value" id="stat-total">0</span>
            <span class="stat-label">Total</span>
        </div>
        <div class="stat">
            <span class="stat-value stat-highlight" id="stat-completion">0%</span>
            <span class="stat-label">Completion</span>
        </div>
    </div>

    <div class="filters" id="filters">
        <button class="filter-btn active" data-filter="all">All projects</button>
    </div>

    <main class="main">
        <div class="kanban">
            <div class="column column-templates">
                <div class="column-header">
                    <div class="column-dot templates"></div>
                    <span class="column-title">ğŸ“‘ Templates</span>
                    <span class="column-count" id="count-templates">0</span>
                    <span class="column-add" onclick="openNewTemplate()" title="Add new template">+</span>
                </div>
                <div class="column-tasks" id="tasks-templates"></div>
            </div>

            <div class="column column-recurring">
                <div class="column-header">
                    <div class="column-dot recurring"></div>
                    <span class="column-title">Recurring</span>
                    <span class="column-count" id="count-recurring">0</span>
                </div>
                <div class="column-tasks" id="tasks-recurring" ondragover="handleCronDragOver(event)" ondragleave="handleCronDragLeave(event)" ondrop="handleCronDrop(event)"></div>
            </div>

            <div class="column column-scheduled">
                <div class="column-header">
                    <div class="column-dot scheduled"></div>
                    <span class="column-title">ğŸ“… Scheduled</span>
                    <span class="column-count" id="count-scheduled">0</span>
                    <span class="column-add" onclick="openScheduledTaskModal()" title="Schedule a task">+</span>
                </div>
                <div class="column-tasks" id="tasks-scheduled" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'scheduled')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot backlog"></div>
                    <span class="column-title">Backlog</span>
                    <span class="column-count" id="count-backlog">0</span>
                    <span class="column-add" onclick="openNewTask('backlog')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-backlog" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'backlog')"></div>
            </div>

            <div class="column column-wide">
                <div class="column-header">
                    <div class="column-dot in-progress"></div>
                    <span class="column-title">In Progress</span>
                    <span class="column-count" id="count-in_progress">0</span>
                    <span class="column-add" onclick="openNewTask('in_progress')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-in_progress" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'in_progress')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot review"></div>
                    <span class="column-title">Review</span>
                    <span class="column-count" id="count-review">0</span>
                    <span class="column-add" onclick="openNewTask('review')" title="Add new task">+</span>
                </div>
                <div class="column-tasks" id="tasks-review" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'review')"></div>
            </div>

            <div class="column">
                <div class="column-header">
                    <div class="column-dot done"></div>
                    <span class="column-title">Done</span>
                    <span class="column-count" id="count-done">0</span>
                    <button class="archive-all-btn" onclick="showArchiveView()" title="View archived tasks" style="background: transparent;">ğŸ“‚ View</button>
                    <button class="archive-all-btn" onclick="archiveAllDone()" title="Archive all done tasks">ğŸ“¦ Archive All</button>
                </div>
                <div class="column-tasks" id="tasks-done" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, 'done')"></div>
            </div>
        </div>

        <aside class="activity" id="activity-sidebar">
            <div class="activity-header">
                <span>ACTIVITY</span>
                <button class="activity-toggle" onclick="toggleActivity()" title="Hide Activity">
                    <span id="activity-toggle-icon">âœ•</span>
                </button>
            </div>
            <div class="activity-list" id="activity-list"></div>
        </aside>
        <button class="activity-reopen" id="activity-reopen" onclick="toggleActivity()" title="Show Activity">
            ACTIVITY
        </button>
    </main>

    </div><!-- END view-tasks -->

    <!-- SKILLS VIEW -->
    <div id="view-skills" class="view" style="display: none;">
        <div class="skills-view">
            <!-- Skills Header with Stats -->
            <div class="skills-header">
                <div class="skills-stats">
                    <div class="skills-stat">
                        <span class="skills-stat-value" id="skills-total">0</span>
                        <span class="skills-stat-label">Total Skills</span>
                    </div>
                    <div class="skills-stat">
                        <span class="skills-stat-value" id="skills-ready">0</span>
                        <span class="skills-stat-label">Ready</span>
                    </div>
                    <div class="skills-stat">
                        <span class="skills-stat-value" id="skills-needs-setup">0</span>
                        <span class="skills-stat-label">Needs Setup</span>
                    </div>
                </div>
                <div class="skills-header-actions">
                    <button class="btn btn-secondary" onclick="refreshSkills()">â†» Refresh</button>
                    <button class="btn btn-clawdhub" onclick="openClawdHub()">
                        ğŸ§© Browse ClawdHub
                    </button>
                </div>
            </div>

            <!-- Skills Filter Bar -->
            <div class="skills-filters">
                <div class="skills-filter-chips">
                    <button class="skills-filter-chip active" data-filter="all" onclick="resetSkillFilters()">All</button>
                    <button class="skills-filter-chip" data-filter="enabled" onclick="toggleSkillFilter('enabled')">âœ… Enabled</button>
                    <button class="skills-filter-chip" data-filter="disabled" onclick="toggleSkillFilter('disabled')">â¸ï¸ Disabled</button>
                    <button class="skills-filter-chip" data-filter="ready" onclick="toggleSkillFilter('ready')">ğŸŸ¢ Ready</button>
                    <button class="skills-filter-chip" data-filter="needs-setup" onclick="toggleSkillFilter('needs-setup')">ğŸŸ¡ Needs Setup</button>
                    <button class="skills-filter-chip" data-filter="builtin" onclick="toggleSkillFilter('builtin')">ğŸ“¦ Built-in</button>
                    <button class="skills-filter-chip" data-filter="workspace" onclick="toggleSkillFilter('workspace')">ğŸ  Workspace</button>
                </div>
            </div>

            <!-- Skills Grid Container -->
            <div id="skills-grid-container">
                <!-- Skills will be rendered here by JavaScript -->
                <div class="skills-empty">
                    <div class="skills-empty-icon">ğŸ§©</div>
                    <div class="skills-empty-title">Loading skills...</div>
                    <div class="skills-empty-text">Please wait while we load your skills.</div>
                </div>
            </div>
        </div>
    </div><!-- END view-skills -->

    <!-- BRAIN VIEW -->
    <div id="view-brain" class="view" style="display: none;">
        <div class="brain-view">
            <!-- Memory Explorer (Left Panel) -->
            <div class="brain-explorer">
                <div class="brain-explorer-header">
                    <div class="brain-explorer-title">Memory Files</div>
                    <div class="brain-search">
                        <span class="brain-search-icon">ğŸ”</span>
                        <input type="text" id="brain-search-input" placeholder="Search memory..." oninput="handleBrainSearch(this.value)">
                    </div>
                </div>
                
                <div class="brain-file-tree" id="brain-file-tree">
                    <!-- Files will be rendered by JavaScript -->
                    <div class="brain-empty">
                        <div class="brain-empty-icon">ğŸ“‚</div>
                        <div class="brain-empty-title">Loading...</div>
                    </div>
                </div>
                
                <div class="brain-tags">
                    <div class="brain-tags-title">Tags</div>
                    <div class="brain-tag-cloud" id="brain-tag-cloud">
                        <!-- Tags will be rendered by JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- Editor (Center Panel) -->
            <div class="brain-editor">
                <div class="brain-editor-header">
                    <div class="brain-editor-tabs" id="brain-editor-tabs">
                        <!-- Tabs will be rendered when files are opened -->
                        <span style="color: var(--text-secondary); font-size: 0.875rem; padding: 0.5rem;">Select a file to edit</span>
                    </div>
                    <div class="brain-editor-actions">
                        <button class="btn btn-secondary btn-small" onclick="toggleBrainPreview()" id="brain-preview-toggle" disabled>
                            ğŸ‘ï¸ Preview
                        </button>
                        <button class="btn btn-secondary btn-small" onclick="openMemoryMerge()">
                            ğŸ”„ Merge Notes
                        </button>
                        <button class="btn btn-primary btn-small" onclick="openKnowledgeBuilder()">
                            ğŸ§™ Add Knowledge
                        </button>
                    </div>
                </div>
                
                <div class="brain-editor-toolbar" id="brain-editor-toolbar" style="display: none;">
                    <button class="brain-toolbar-btn" onclick="brainInsert('**', '**')" title="Bold">ğ</button>
                    <button class="brain-toolbar-btn" onclick="brainInsert('*', '*')" title="Italic">ğ¼</button>
                    <button class="brain-toolbar-btn" onclick="brainInsert('`', '`')" title="Code">&lt;/&gt;</button>
                    <button class="brain-toolbar-btn" onclick="brainInsert('[', '](url)')" title="Link">ğŸ”—</button>
                    <div class="brain-toolbar-divider"></div>
                    <button class="brain-toolbar-btn" onclick="brainInsertLine('- ')" title="List">â€¢ List</button>
                    <button class="brain-toolbar-btn" onclick="brainInsertLine('## ')" title="Heading">H2</button>
                    <button class="brain-toolbar-btn" onclick="brainInsertLine('#')" title="Tag">#tag</button>
                    <div class="brain-toolbar-divider"></div>
                    <button class="brain-toolbar-btn" onclick="brainInsertLine('---')" title="Divider">â€•</button>
                </div>
                
                <div class="brain-editor-content" id="brain-editor-content">
                    <div class="brain-empty">
                        <div class="brain-empty-icon">ğŸ§ </div>
                        <div class="brain-empty-title">Your Memory, Organized</div>
                        <div class="brain-empty-text">
                            Select a file from the explorer to view and edit, or use the Knowledge Builder to add new information.
                        </div>
                    </div>
                </div>
                
                <div class="brain-editor-footer" id="brain-editor-footer" style="display: none;">
                    <div class="brain-footer-left">
                        <span id="brain-cursor-pos">Ln 1, Col 1</span>
                        <span id="brain-word-count">0 words</span>
                        <span id="brain-tag-count">0 tags</span>
                    </div>
                    <div class="brain-footer-right">
                        <span id="brain-save-status">Saved</span>
                    </div>
                </div>
            </div>
            
            <!-- Changelog (Right Panel) -->
            <div class="brain-changelog" id="brain-changelog">
                <div class="brain-changelog-header">
                    <span class="brain-changelog-title">ğŸ“œ Changelog</span>
                    <button class="brain-changelog-toggle" onclick="toggleBrainChangelog()" title="Collapse">
                        âœ•
                    </button>
                </div>
                <div class="brain-changelog-list" id="brain-changelog-list">
                    <!-- Changelog items will be rendered by JavaScript -->
                    <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">ğŸ“œ</div>
                        <div>Loading history...</div>
                    </div>
                </div>
            </div>
        </div>
    </div><!-- END view-brain -->

    <!-- Knowledge Builder Modal -->
    <div class="brain-knowledge-builder" id="brain-knowledge-builder">
        <div class="brain-kb-modal">
            <div class="brain-kb-header">
                <span class="brain-kb-title">ğŸ§™ Knowledge Builder</span>
                <button class="brain-kb-close" onclick="closeKnowledgeBuilder()">Ã—</button>
            </div>
            <div class="brain-kb-content">
                <label style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.5rem; display: block;">
                    Paste or type any information you want to remember:
                </label>
                <textarea class="brain-kb-input" id="brain-kb-input" placeholder="e.g., JetBrains account uses thomas@example.com, password in 1Password. Renewal date is March 15th."></textarea>
                
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
                    <button class="btn btn-secondary btn-small" onclick="processKnowledge('format')">ğŸ“ Format</button>
                    <button class="btn btn-secondary btn-small" onclick="processKnowledge('extract')">ğŸ” Extract Facts</button>
                    <button class="btn btn-secondary btn-small" onclick="processKnowledge('tags')">ğŸ·ï¸ Tags</button>
                    <div style="width: 1px; height: 20px; background: var(--border); margin: 0 0.25rem;"></div>
                    <button class="btn btn-primary btn-small" onclick="processKnowledge('ai')" id="brain-kb-ai-btn" title="Process with AI (requires API key)">ğŸ¤– AI Process</button>
                    <button class="btn btn-secondary btn-small" onclick="showAISettings()" title="Configure AI">âš™ï¸</button>
                </div>
                
                <div class="brain-kb-result" id="brain-kb-result" style="display: none;">
                    <div class="brain-kb-result-label">Result</div>
                    <div id="brain-kb-result-content"></div>
                </div>
                
                <div style="margin-top: 1rem;">
                    <label style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.5rem; display: block;">
                        Save to:
                    </label>
                    <select id="brain-kb-target" style="width: 100%; padding: 0.5rem; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <option value="today">ğŸ“… Today's memory (memory/YYYY-MM-DD.md)</option>
                        <option value="memory">ğŸ§  Long-term memory (MEMORY.md)</option>
                    </select>
                </div>
            </div>
            <div class="brain-kb-footer">
                <button class="btn btn-secondary" onclick="closeKnowledgeBuilder()">Cancel</button>
                <button class="btn btn-primary" onclick="saveKnowledge()" id="brain-kb-save" disabled>Save to Memory</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div class="brain-ai-settings" id="brain-ai-settings">
        <div class="brain-ai-settings-modal">
            <div class="brain-ai-settings-header">
                <span class="brain-ai-settings-title">âš™ï¸ AI Settings</span>
                <button class="brain-kb-close" onclick="hideAISettings()">Ã—</button>
            </div>
            <div class="brain-ai-settings-content">
                <div class="brain-ai-status" id="brain-ai-status">
                    <span>ğŸ”Œ</span>
                    <span id="brain-ai-status-text">Checking...</span>
                </div>
                
                <div class="brain-ai-settings-field">
                    <label for="brain-ai-provider">AI Provider</label>
                    <select id="brain-ai-provider" onchange="updateAIProviderUI()">
                        <option value="openrouter">OpenRouter (recommended)</option>
                        <option value="openai">OpenAI</option>
                        <option value="local">Local only (no API)</option>
                    </select>
                </div>
                
                <div class="brain-ai-settings-field" id="brain-ai-key-field">
                    <label for="brain-ai-key">API Key</label>
                    <input type="password" id="brain-ai-key" placeholder="sk-or-... or sk-...">
                    <div class="brain-ai-settings-hint">
                        Get your key from <a href="https://openrouter.ai/keys" target="_blank" style="color: var(--accent-blue);">openrouter.ai/keys</a>
                    </div>
                </div>
                
                <div class="brain-ai-settings-field" id="brain-ai-model-field">
                    <label for="brain-ai-model">Model</label>
                    <select id="brain-ai-model">
                        <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet (fast)</option>
                        <option value="anthropic/claude-3-opus">Claude 3 Opus (best)</option>
                        <option value="openai/gpt-4o">GPT-4o</option>
                        <option value="openai/gpt-4o-mini">GPT-4o Mini (cheap)</option>
                        <option value="google/gemini-pro-1.5">Gemini 1.5 Pro</option>
                    </select>
                </div>
            </div>
            <div class="brain-ai-settings-footer">
                <button class="btn btn-secondary" onclick="hideAISettings()">Cancel</button>
                <button class="btn btn-primary" onclick="saveAISettings()">Save</button>
            </div>
        </div>
    </div>

    <!-- Diff View Modal -->
    <div class="brain-diff-modal" id="brain-diff-modal">
        <div class="brain-diff-container">
            <div class="brain-diff-header">
                <div>
                    <div class="brain-diff-title" id="brain-diff-title">Commit Details</div>
                    <div class="brain-diff-meta" id="brain-diff-meta"></div>
                </div>
                <button class="brain-diff-close" onclick="closeDiffModal()">Ã—</button>
            </div>
            <div class="brain-diff-content" id="brain-diff-content">
                <div class="brain-diff-loading">Loading diff...</div>
            </div>
        </div>
    </div>

    <!-- Memory Merge Modal -->
    <div class="brain-merge-modal" id="brain-merge-modal">
        <div class="brain-merge-container">
            <div class="brain-merge-header">
                <span class="brain-merge-title">ğŸ”„ Merge Daily Notes to Long-Term Memory</span>
                <button class="brain-kb-close" onclick="closeMemoryMerge()">Ã—</button>
            </div>
            <div class="brain-merge-content">
                <p style="color: var(--text-secondary); margin-bottom: 1rem; font-size: 0.875rem;">
                    Select daily notes to consolidate into MEMORY.md. AI will summarize and deduplicate the content.
                </p>
                
                <div class="brain-merge-files" id="brain-merge-files">
                    <!-- File checkboxes will be rendered here -->
                </div>
                
                <div class="brain-merge-options">
                    <label class="brain-merge-checkbox">
                        <input type="checkbox" id="brain-merge-archive" checked>
                        <span>Archive merged files (add .merged suffix)</span>
                    </label>
                    <label class="brain-merge-checkbox">
                        <input type="checkbox" id="brain-merge-ai" checked>
                        <span>Use AI for smart summarization</span>
                    </label>
                </div>
                
                <div class="brain-merge-preview" id="brain-merge-preview" style="display: none;">
                    <div class="brain-merge-preview-label">Preview</div>
                    <div class="brain-merge-preview-content" id="brain-merge-preview-content"></div>
                </div>
            </div>
            <div class="brain-merge-footer">
                <button class="btn btn-secondary" onclick="closeMemoryMerge()">Cancel</button>
                <button class="btn btn-secondary" onclick="previewMerge()" id="brain-merge-preview-btn">ğŸ‘ï¸ Preview</button>
                <button class="btn btn-primary" onclick="executeMerge()" id="brain-merge-execute" disabled>Merge Selected</button>
            </div>
        </div>
    </div>

    <!-- Skill Detail Panel (Slide-in) -->
    <div class="skill-panel-overlay" id="skill-panel-overlay" onclick="closeSkillPanel()"></div>
    <div class="skill-panel" id="skill-panel">
        <div class="skill-panel-header">
            <div class="skill-panel-title">
                <span class="skill-panel-title-emoji" id="skill-panel-emoji">ğŸ§©</span>
                <span class="skill-panel-title-text" id="skill-panel-name">Skill Name</span>
            </div>
            <button class="skill-panel-close" onclick="closeSkillPanel()" title="Close (Esc)">Ã—</button>
        </div>
        <div class="skill-panel-content" id="skill-panel-content">
            <!-- Content will be rendered by JavaScript -->
        </div>
        <div class="skill-panel-footer" id="skill-panel-footer">
            <button class="btn btn-secondary" onclick="closeSkillPanel()">Close</button>
            <button class="btn btn-primary" id="skill-panel-save" onclick="saveSkillFromPanel()">Save Changes</button>
        </div>
    </div>

    <!-- DOCS VIEW -->
    <div id="view-docs" class="view" style="display: none;">
        <div class="docs-container" style="max-width: 900px; margin: 0 auto; padding: 2rem;">
            <h1 style="margin-bottom: 1.5rem;">ğŸ“š Mission Control Documentation</h1>

            <div class="docs-section" style="margin-bottom: 2rem; background: var(--bg-secondary); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--accent);">
                <h2 style="color: var(--accent); margin-bottom: 0.5rem;">ğŸ“Œ Demo Mode</h2>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    You're currently viewing <strong>sample data</strong>. To manage your own tasks, click <strong>"Connect GitHub"</strong> in the top right corner to link your repository.
                </p>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">ğŸš€ Getting Started</h2>

                <h3 style="margin: 1rem 0 0.5rem;">Installation</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Add Mission Control to your existing MoltBot workspace:
                </p>
                <ol style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>Fork</strong> this repository to your GitHub account</li>
                    <li><strong>Copy dashboard files</strong> to your workspace: <code>index.html</code>, <code>data/</code>, <code>canvas/</code>, <code>scripts/</code>, <code>.github/</code></li>
                    <li>Enable <strong>GitHub Pages</strong> in your repo settings (Settings â†’ Pages â†’ Branch: main)</li>
                    <li>Visit <code>https://[username].github.io/mission-control/</code></li>
                </ol>

                <h3 style="margin: 1.5rem 0 0.5rem;">Connect to GitHub</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Click <strong>"Connect GitHub"</strong> in the top right corner. You'll need a GitHub Personal Access Token with <code>repo</code> permissions.
                </p>
                <ol style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li>Go to <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--accent);">GitHub Settings â†’ Tokens</a></li>
                    <li>Click "Generate new token (classic)"</li>
                    <li>Select scope: <code>repo</code> (Full control of private repositories)</li>
                    <li>Copy the token and paste it in Mission Control</li>
                </ol>

                <h3 style="margin: 1.5rem 0 0.5rem;">Understanding the Board</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Mission Control uses a Kanban-style board with these columns:
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>ğŸ”„ Recurring</strong> - Cron jobs that run on schedule</li>
                    <li><strong>ğŸ“… Scheduled</strong> - One-time tasks with a future date</li>
                    <li><strong>ğŸ“‘ Templates</strong> - Reusable task templates</li>
                    <li><strong>ğŸ“‹ Backlog</strong> - Tasks waiting to be started</li>
                    <li><strong>ğŸš€ In Progress</strong> - Currently being worked on</li>
                    <li><strong>ğŸ‘€ Review</strong> - Done, awaiting approval</li>
                    <li><strong>âœ… Done</strong> - Completed tasks</li>
                </ul>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">âœ¨ Features</h2>

                <h3 style="margin: 1rem 0 0.5rem;">Auto-Save</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    All changes are <strong>automatically saved</strong> to GitHub. No manual "Save" button needed!
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li>Drag & drop tasks between columns â†’ instant save</li>
                    <li>Edit task details â†’ instant save</li>
                    <li>Add/remove subtasks â†’ instant save</li>
                    <li>Add comments â†’ instant save</li>
                </ul>

                <h3 style="margin: 1.5rem 0 0.5rem;">Drag & Drop</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Click and drag any task card to move it between columns. The status updates automatically.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Subtasks</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Break down tasks into smaller steps. Click on a subtask to edit it inline.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Comments</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Add comments to tasks for context or feedback. Comments on <strong>Review</strong> tasks trigger notifications to MoltBot.
                </p>

                <h3 style="margin: 1.5rem 0 0.5rem;">Projects & Tags</h3>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Organize tasks by project. Use the âš™ï¸ Settings to add new projects. Filter tasks using the project buttons.
                </p>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">ğŸ¤– MoltBot Integration</h2>
                <p style="color: var(--text-secondary); line-height: 1.6;">
                    Mission Control is connected to MoltBot via webhooks. When you make changes:
                </p>
                <ul style="color: var(--text-secondary); line-height: 1.8; margin-left: 1.5rem;">
                    <li><strong>Move task to "In Progress"</strong> â†’ MoltBot receives a work order and starts processing</li>
                    <li><strong>Add comment on Review task</strong> â†’ MoltBot sees your feedback</li>
                    <li><strong>MoltBot completes work</strong> â†’ Task moves to "Review" automatically</li>
                </ul>

                <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-top: 1rem;">
                    <strong>ğŸ’¡ Pro Tip:</strong> Write clear task descriptions and subtasks. The more detail you provide, the better MoltBot can execute the task.
                </div>
            </div>

            <div class="docs-section" style="margin-bottom: 2rem;">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">âŒ¨ï¸ Keyboard Shortcuts</h2>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Cmd/Ctrl + Shift + R</code></td>
                        <td style="padding: 0.5rem;">Hard refresh (clear cache)</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Escape</code></td>
                        <td style="padding: 0.5rem;">Close modals</td>
                    </tr>
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.5rem; color: var(--text-secondary);"><code>Enter</code></td>
                        <td style="padding: 0.5rem;">Save inline edits</td>
                    </tr>
                </table>
            </div>

            <div class="docs-section">
                <h2 style="color: var(--accent); margin-bottom: 1rem;">â“ FAQ</h2>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Why don't I see my changes?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        GitHub Pages can cache content. Try a hard refresh (Cmd+Shift+R) or open in an incognito window.
                    </p>
                </details>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">How do I create a new project?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        Click the âš™ï¸ Settings button (when logged in) â†’ Add a new project with ID, name, icon, and color.
                    </p>
                </details>

                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Can multiple people use this?</summary>
                    <p style="color: var(--text-secondary); padding: 0.5rem 0 0 1rem;">
                        Yes! Anyone with repo access can connect their GitHub token. Changes from all users sync automatically.
                    </p>
                </details>
            </div>
        </div>
    </div><!-- END view-docs -->

    <!-- PEOPLE VIEW -->
    <div id="view-people" class="view" style="display: none;">
        <div class="people-container">
            <div class="people-header">
                <h1>ğŸ‘¥ Team</h1>
                <div class="people-stats" id="people-stats">
                    <!-- Stats filled by JS -->
                </div>
            </div>
            <div id="collaborators-container">
                <div class="people-loading">
                    <div class="spinner"></div>
                    <p>Loading collaborators...</p>
                </div>
            </div>
        </div>
    </div><!-- END view-people -->

    <!-- Auth Modal -->
    <div class="modal-overlay" id="auth-modal" onclick="if(event.target===this)hideAuthModal()">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">ğŸ” Connect to GitHub</h2>
                <button class="modal-close" onclick="hideAuthModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Connect your GitHub account to create, edit, and save tasks directly to the repository.
                </p>

                <div class="steps">
                    <div class="step">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <div class="step-title">Create a Personal Access Token</div>
                            <div class="step-description">
                                <a href="https://github.com/settings/tokens/new?scopes=repo&description=Mission%20Control%20Dashboard" target="_blank">
                                    Click here to create a token â†’
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <div class="step-title">Select "repo" scope</div>
                            <div class="step-description">This allows read/write access to repositories</div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <div class="step-title">Paste your token below</div>
                            <div class="step-description">The token starts with "ghp_"</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">GitHub Personal Access Token</label>
                    <input type="password" class="form-input" id="token-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <div class="form-hint">
                        ğŸ”’ Your token is stored locally and never sent anywhere except GitHub.
                    </div>
                    <div class="validation-loading" id="validation-loading">
                        <div class="spinner"></div>
                        <span>Validating token...</span>
                    </div>
                    <div class="validation-success" id="validation-success">
                        <span>âœ“</span>
                        <span>Connected as <strong id="validated-user"></strong></span>
                    </div>
                    <div class="validation-error" id="validation-error">
                        <span>âœ—</span>
                        <span id="error-message">Invalid token</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideAuthModal()">Cancel</button>
                <button class="btn btn-primary" id="btn-save-token" onclick="validateAndSaveToken()" disabled>Connect</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal" onclick="if(event.target===this)hideSettingsModal()">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title">âš™ï¸ Settings</h2>
                <button class="modal-close" onclick="hideSettingsModal()">&times;</button>
            </div>
            <div class="modal-body">
                <h3 style="margin-bottom: 12px; font-size: 1rem;">Gateway Connection</h3>
                <div style="margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">Connect to your Clawdbot Gateway for Run History and real-time sync.</p>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="form-input" id="gateway-url-input" placeholder="http://localhost:3033" style="flex: 1;">
                        <button class="btn btn-primary" onclick="saveGatewayUrl()">Connect</button>
                    </div>
                    <div id="gateway-status" style="font-size: 0.8rem; margin-top: 6px; color: var(--text-secondary);"></div>
                </div>
                
                <h3 style="margin-bottom: 12px; font-size: 1rem;">ğŸ’­ Live Thinking</h3>
                <div style="margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid var(--border);">
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">Enable real-time thinking visibility during task processing. Requires Clawdbot Hooks Token.</p>
                    <div style="display: flex; gap: 8px;">
                        <input type="password" class="form-input" id="hooks-token-input" placeholder="Hooks Token (from clawdbot.json)" style="flex: 1;">
                        <button class="btn btn-secondary" onclick="toggleHooksTokenVisibility()" title="Show/Hide">ğŸ‘ï¸</button>
                        <button class="btn btn-primary" onclick="saveHooksToken()">Save</button>
                    </div>
                    <div id="hooks-token-status" style="font-size: 0.8rem; margin-top: 6px; color: var(--text-secondary);"></div>
                </div>
                
                <h3 style="margin-bottom: 12px; font-size: 1rem;">Projects</h3>
                <div id="projects-list" class="projects-list"></div>

                <div class="add-project-form" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
                    <h4 style="margin-bottom: 8px; font-size: 0.9rem;" id="project-form-title">Add New Project</h4>
                    <div style="display: grid; gap: 8px;">
                        <input type="text" class="form-input" id="new-project-id" placeholder="ID (z.B. marketing)">
                        <input type="text" class="form-input" id="new-project-name" placeholder="Name (z.B. Marketing)">
                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 0.8rem; color: var(--text-secondary);">Icon</label>
                            <div class="emoji-picker" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;">
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ“')">ğŸ“</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ“Š')">ğŸ“Š</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ’¼')">ğŸ’¼</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸš€')">ğŸš€</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ’¡')">ğŸ’¡</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ¯')">ğŸ¯</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ“£')">ğŸ“£</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ› ï¸')">ğŸ› ï¸</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ“±')">ğŸ“±</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸŒ')">ğŸŒ</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ’°')">ğŸ’°</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ“')">ğŸ“</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('ğŸ ')">ğŸ </button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('â¤ï¸')">â¤ï¸</button>
                                <button type="button" class="emoji-btn" onclick="selectEmoji('â­')">â­</button>
                                <input type="text" class="form-input" id="new-project-icon" placeholder="or custom..." style="width: 100px; font-size: 1.1rem;">
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label style="font-size: 0.8rem; color: var(--text-secondary);">Farbe:</label>
                            <input type="color" id="new-project-color" value="#6366f1" style="width: 50px; height: 32px; border: none; cursor: pointer; border-radius: 4px;">
                            <button class="btn btn-secondary" id="btn-cancel-project" onclick="cancelEditProject()" style="display: none;">Cancel</button>
                            <button class="btn btn-primary" id="btn-save-project" onclick="saveProject()" style="flex: 1;">+ Add Project</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Commit Modal -->
    <div class="modal-overlay" id="commit-modal" onclick="if(event.target===this)hideCommitModal()">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">ğŸ’¾ Save Changes to GitHub</h2>
                <button class="modal-close" onclick="hideCommitModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Commit Message</label>
                    <input type="text" class="form-input" id="commit-message" placeholder="Update tasks" autocomplete="off">
                    <div class="form-hint">
                        Describe what you changed (optional - will use default if empty)
                    </div>
                </div>
                <div id="changes-summary" style="margin-top: 1rem; padding: 1rem; background: var(--bg-card); border-radius: 6px; font-size: 0.875rem;">
                    <!-- Changes will be listed here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="hideCommitModal()">Cancel</button>
                <button class="btn btn-primary" id="btn-commit" onclick="commitChanges()">
                    <span id="commit-btn-text">Commit & Push</span>
                    <div class="spinner" id="commit-spinner" style="display: none;"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Task Edit Modal -->
    <div class="modal-overlay" id="task-modal" onclick="if(event.target===this)hideTaskModal()">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h2 class="modal-title" id="task-modal-title">Edit Task</h2>
                <button class="modal-close" onclick="hideTaskModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" class="form-input" id="task-title" placeholder="Task title">
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-input" id="task-description" rows="3" placeholder="Task description" style="resize: vertical;"></textarea>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div class="form-group">
                        <label class="form-label">Status</label>
                        <select class="form-input" id="task-status">
                            <option value="scheduled">Scheduled</option>
                            <option value="backlog">Backlog</option>
                            <option value="in_progress">In Progress</option>
                            <option value="review">Review</option>
                            <option value="done">Done</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Priority</label>
                        <select class="form-input" id="task-priority">
                            <option value="low">Low</option>
                            <option value="medium">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Project</label>
                    <select class="form-input" id="task-project">
                        <!-- Populated dynamically from STATE.data.projects -->
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <div id="tags-chips" class="tags-chips-container" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;"></div>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" class="form-input" id="new-tag-input" placeholder="Add tag..." style="flex: 1;" onkeydown="if(event.key==='Enter'){event.preventDefault();addTag();}">
                        <button class="btn btn-secondary btn-small" onclick="addTag()">+ Add</button>
                    </div>
                    <input type="hidden" id="task-tags">
                </div>

                <!-- Subtasks Section -->
                <div class="form-group" id="subtasks-section">
                    <label class="form-label">Subtasks</label>
                    <div class="subtasks-list" id="subtasks-list"></div>
                    <div class="subtask-add">
                        <input type="text" class="form-input" id="new-subtask-input" placeholder="Add new subtask...">
                        <button class="btn btn-secondary btn-small" onclick="addSubtask()">+ Add</button>
                    </div>
                </div>

                <!-- Comments Section -->
                <div class="form-group" id="comments-section">
                    <label class="form-label">Comments</label>
                    <div class="comments-list" id="comments-list"></div>
                    <div class="comment-add">
                        <textarea class="form-input" id="new-comment-input" rows="2" placeholder="Add a comment..."></textarea>
                        <button class="btn btn-secondary btn-small" onclick="addComment()">Post Comment</button>
                    </div>
                </div>
                
                <!-- Learnings Section (visible only in review status) -->
                <div class="form-group" id="learnings-section" style="display: none;">
                    <label class="form-label">
                        ğŸ§  Learnings from this Task
                        <span class="learnings-hint">(Accept learnings to save to Memory)</span>
                    </label>
                    <div class="learnings-list" id="learnings-list">
                        <!-- Learnings will be rendered here -->
                    </div>
                    <div class="learnings-actions">
                        <button class="btn btn-secondary btn-small" onclick="extractLearnings()">ğŸ” Extract from Comments</button>
                        <button class="btn btn-secondary btn-small" onclick="addManualLearning()">+ Add Learning</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" id="btn-delete-task" onclick="deleteTask()" style="margin-right: auto;">Delete</button>
                <button class="btn btn-secondary" id="btn-task-to-cron" onclick="openTaskToCronWizard(currentEditingTaskId)" title="Convert to recurring cron job">â° As Cron</button>
                <button class="btn btn-secondary" onclick="hideTaskModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTask()">Save Task</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <script>
        // === CONFIG ===
        // Auto-detect repo from GitHub Pages URL (works for any fork)
        const getRepoFromURL = () => {
            const hostname = window.location.hostname;
            const pathname = window.location.pathname;
            // GitHub Pages format: {owner}.github.io/{repo}/
            if (hostname.includes('.github.io')) {
                const owner = hostname.split('.github.io')[0];
                const repo = pathname.split('/')[1] || 'mission-control';
                return { owner, repo };
            }
            // Fallback for local development
            return { owner: 'rdsthomas', repo: 'mission-control' };
        };
        const { owner: detectedOwner, repo: detectedRepo } = getRepoFromURL();
        
        const CONFIG = {
            owner: detectedOwner,
            repo: detectedRepo,
            branch: 'main',
            tasksFile: 'data/tasks.json'
        };

        // === STATE ===
        let STATE = {
            user: null,
            token: null,
            data: null,  // Loaded from GitHub or fallback
            originalData: null,  // For detecting changes
            hasUnsavedChanges: false,
            isLoading: false,
            gatewayUrl: null,  // Set via config or auto-detected
            sessionKey: null,  // Clawdbot session key for thinking visibility
            skills: [],  // Skills list for skill column
            crons: [],   // Crons list for recurring column
            searchQuery: '',  // Current search filter
            thinkingHistory: {},  // Task ID -> thinking blocks
            thinkingPolling: null,  // Polling interval ID
            expandedTasks: new Set()  // Set of expanded task IDs
        };
        
        // Gateway URL detection
        const KNOWN_GATEWAY_URLS = [
            'http://localhost:3033',
            'https://your-gateway.example.com'
        ];
        
        function getGatewayUrl() {
            // 1. Check URL query parameter (highest priority)
            const urlParams = new URLSearchParams(window.location.search);
            const queryGateway = urlParams.get('gateway');
            if (queryGateway) {
                // Save to localStorage for future visits
                localStorage.setItem('mc_gateway_url', queryGateway);
                STATE.gatewayUrl = queryGateway;
                // Clean URL (remove query param)
                if (window.history.replaceState) {
                    const cleanUrl = window.location.pathname + window.location.hash;
                    window.history.replaceState({}, document.title, cleanUrl);
                }
                return queryGateway;
            }
            
            // 2. Check if manually configured in state
            if (STATE.gatewayUrl) return STATE.gatewayUrl;
            
            // 3. Check localStorage
            const stored = localStorage.getItem('mc_gateway_url');
            if (stored) return stored;
            
            // 4. Auto-detect for local development
            const isLocal = location.hostname === 'localhost' || 
                           location.hostname === '127.0.0.1' ||
                           location.protocol === 'file:';
            if (isLocal) return 'http://localhost:3033';
            
            // 5. Return null - will trigger auto-probe
            return null;
        }
        
        function setGatewayUrl(url) {
            STATE.gatewayUrl = url;
            if (url) {
                localStorage.setItem('mc_gateway_url', url);
            } else {
                localStorage.removeItem('mc_gateway_url');
            }
        }
        
        // Auto-probe known Gateway URLs
        async function autoProbeGateway() {
            if (STATE.gatewayUrl || localStorage.getItem('mc_gateway_url')) {
                return getGatewayUrl();
            }
            
            console.log('Auto-probing Gateway URLs...');
            
            for (const url of KNOWN_GATEWAY_URLS) {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 2000);
                    
                    const response = await fetch(`${url}/api/status`, {
                        method: 'GET',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeout);
                    
                    if (response.ok) {
                        console.log(`âœ“ Gateway found at ${url}`);
                        setGatewayUrl(url);
                        return url;
                    }
                } catch (e) {
                    console.log(`âœ— Gateway not available at ${url}`);
                }
            }
            
            console.log('No Gateway found via auto-probe');
            return null;
        }
// === EMBEDDED DATA (fallback when not logged in) ===
        const FALLBACK_DATA = {
            tasks: [
                // === TEMPLATES (reusable task templates) ===
                {
                    id: "task_p01",
                    title: "Weekly backup check",
                    description: "Verify all automated backups completed successfully",
                    status: "backlog",
                    isTemplate: true,
                    baseStatus: "backlog",
                    project: "devops",
                    tags: ["devops", "maintenance"],
                    subtasks: [
                        { id: "sub_001", title: "Check database backups", done: false },
                        { id: "sub_002", title: "Verify file storage sync", done: false },
                        { id: "sub_003", title: "Test restore procedure", done: false }
                    ],
                    priority: "high",
                    executionCount: 0,
                    createdAt: "2026-01-15T09:00:00Z"
                },
                {
                    id: "task_p02",
                    title: "Review analytics dashboard",
                    description: "Check KPIs and identify trends or anomalies",
                    status: "backlog",
                    isTemplate: true,
                    baseStatus: "backlog",
                    project: "growth",
                    tags: ["growth", "analytics"],
                    subtasks: [],
                    priority: "medium",
                    executionCount: 0,
                    createdAt: "2026-01-15T09:00:00Z"
                },
                // === BACKLOG ===
                {
                    id: "task_001",
                    title: "Redesign landing page",
                    description: "Modern refresh with improved conversion focus and mobile-first approach",
                    status: "backlog",
                    project: "design",
                    tags: ["design", "growth"],
                    subtasks: [
                        { id: "sub_001", title: "Competitor analysis", done: false },
                        { id: "sub_002", title: "Wireframe concepts", done: false },
                        { id: "sub_003", title: "Design mockups", done: false },
                        { id: "sub_004", title: "Get stakeholder feedback", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-20T10:00:00Z"
                },
                {
                    id: "task_002",
                    title: "Plan weekend hiking trip",
                    description: "Research trails, check weather, prepare gear for Saturday adventure",
                    status: "backlog",
                    project: "personal",
                    tags: ["personal", "wellness"],
                    subtasks: [
                        { id: "sub_001", title: "Choose trail (moderate difficulty)", done: false },
                        { id: "sub_002", title: "Check weather forecast", done: false },
                        { id: "sub_003", title: "Pack essentials", done: false }
                    ],
                    priority: "low",
                    createdAt: "2026-01-25T18:00:00Z"
                },
                {
                    id: "task_003",
                    title: "Set up CI/CD pipeline",
                    description: "Automate testing and deployment for the main project repository",
                    status: "backlog",
                    project: "devops",
                    tags: ["devops", "automation"],
                    subtasks: [
                        { id: "sub_001", title: "Configure GitHub Actions", done: false },
                        { id: "sub_002", title: "Add test coverage reports", done: false },
                        { id: "sub_003", title: "Set up staging environment", done: false },
                        { id: "sub_004", title: "Document deployment process", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-22T14:00:00Z"
                },
                {
                    id: "task_004",
                    title: "Research email automation tools",
                    description: "Compare options for newsletter and drip campaigns",
                    status: "backlog",
                    project: "growth",
                    tags: ["growth", "research"],
                    subtasks: [],
                    priority: "medium",
                    createdAt: "2026-01-24T11:00:00Z"
                },
                // === IN PROGRESS ===
                {
                    id: "task_005",
                    title: "Implement dark mode",
                    description: "Add theme toggle with system preference detection and persistence",
                    status: "in_progress",
                    project: "devops",
                    tags: ["devops", "design"],
                    subtasks: [
                        { id: "sub_001", title: "Define color variables", done: true },
                        { id: "sub_002", title: "Create theme toggle component", done: true },
                        { id: "sub_003", title: "Persist preference in localStorage", done: false },
                        { id: "sub_004", title: "Test across browsers", done: false }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-23T09:00:00Z"
                },
                {
                    id: "task_006",
                    title: "Write Q1 blog post",
                    description: "Industry trends article for company blog, target 1500 words",
                    status: "in_progress",
                    project: "growth",
                    tags: ["growth", "content"],
                    subtasks: [
                        { id: "sub_001", title: "Outline key points", done: true },
                        { id: "sub_002", title: "Write first draft", done: true },
                        { id: "sub_003", title: "Add visuals and examples", done: false },
                        { id: "sub_004", title: "SEO optimization", done: false }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-21T10:00:00Z"
                },
                {
                    id: "task_007",
                    title: "Organize home office",
                    description: "Declutter desk, improve cable management, add plants",
                    status: "in_progress",
                    project: "personal",
                    tags: ["personal", "wellness"],
                    subtasks: [
                        { id: "sub_001", title: "Sort through papers", done: true },
                        { id: "sub_002", title: "Order cable organizers", done: true },
                        { id: "sub_003", title: "Buy desk plant", done: false }
                    ],
                    priority: "low",
                    createdAt: "2026-01-26T15:00:00Z"
                },
                // === REVIEW ===
                {
                    id: "task_008",
                    title: "API documentation update",
                    description: "Complete overhaul of REST API docs with examples and error codes",
                    status: "review",
                    project: "devops",
                    tags: ["devops", "documentation"],
                    subtasks: [
                        { id: "sub_001", title: "Document all endpoints", done: true },
                        { id: "sub_002", title: "Add request/response examples", done: true },
                        { id: "sub_003", title: "Include authentication guide", done: true },
                        { id: "sub_004", title: "Peer review", done: false }
                    ],
                    priority: "high",
                    createdAt: "2026-01-18T09:00:00Z"
                },
                {
                    id: "task_009",
                    title: "New logo concepts",
                    description: "Three variations for brand refresh, awaiting team vote",
                    status: "review",
                    project: "design",
                    tags: ["design", "branding"],
                    subtasks: [
                        { id: "sub_001", title: "Minimalist version", done: true },
                        { id: "sub_002", title: "Bold/modern version", done: true },
                        { id: "sub_003", title: "Classic refined version", done: true }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-19T11:00:00Z"
                },
                // === DONE ===
                {
                    id: "task_010",
                    title: "Fix login redirect bug",
                    description: "Users were redirected to wrong page after OAuth login",
                    status: "done",
                    project: "devops",
                    tags: ["devops", "bugfix"],
                    subtasks: [
                        { id: "sub_001", title: "Reproduce issue", done: true },
                        { id: "sub_002", title: "Identify root cause", done: true },
                        { id: "sub_003", title: "Implement fix", done: true },
                        { id: "sub_004", title: "Write regression test", done: true }
                    ],
                    priority: "high",
                    createdAt: "2026-01-17T08:00:00Z"
                },
                {
                    id: "task_011",
                    title: "Quarterly tax prep",
                    description: "Gather documents and submit to accountant",
                    status: "done",
                    project: "personal",
                    tags: ["personal", "finance"],
                    subtasks: [
                        { id: "sub_001", title: "Export bank statements", done: true },
                        { id: "sub_002", title: "Organize receipts", done: true },
                        { id: "sub_003", title: "Send to accountant", done: true }
                    ],
                    priority: "high",
                    createdAt: "2026-01-10T09:00:00Z"
                },
                {
                    id: "task_012",
                    title: "Social media content calendar",
                    description: "Plan posts for February across all platforms",
                    status: "done",
                    project: "growth",
                    tags: ["growth", "content"],
                    subtasks: [
                        { id: "sub_001", title: "Identify key dates/events", done: true },
                        { id: "sub_002", title: "Draft post ideas", done: true },
                        { id: "sub_003", title: "Schedule in buffer", done: true }
                    ],
                    priority: "medium",
                    createdAt: "2026-01-12T14:00:00Z"
                }
            ],
            projects: [
                { id: "devops", name: "DevOps", color: "#3b82f6", icon: "ğŸ’»" },
                { id: "growth", name: "Growth", color: "#10b981", icon: "ğŸ“ˆ" },
                { id: "design", name: "Design", color: "#f59e0b", icon: "ğŸ¨" },
                { id: "personal", name: "Personal", color: "#8b5cf6", icon: "ğŸ " },
                { id: "wellness", name: "Wellness", color: "#ec4899", icon: "ğŸ§˜" }
            ],
            activities: [
                { type: "completed", actor: "You", task: "Social media content calendar", time: "2 hours ago" },
                { type: "moved", actor: "AI Assistant", task: "API documentation update", from: "in_progress", to: "review", time: "4 hours ago" },
                { type: "created", actor: "You", task: "Plan weekend hiking trip", time: "yesterday" },
                { type: "completed", actor: "You", task: "Fix login redirect bug", time: "2 days ago" },
                { type: "moved", actor: "AI Assistant", task: "Implement dark mode", from: "backlog", to: "in_progress", time: "3 days ago" }
            ],
            lastUpdated: new Date().toISOString()
        };
        async function loadTasksFromGitHub() {
            if (!STATE.token) {
                console.log('No token, using fallback data');
                STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
                return;
            }

            STATE.isLoading = true;
            showToast('success', 'ğŸ“¥ Loading tasks from GitHub...');

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('Could not load tasks file');
                }

                const fileData = await response.json();
                // UTF-8 safe base64 decode
                const bytes = Uint8Array.from(atob(fileData.content), c => c.charCodeAt(0));
                const content = new TextDecoder().decode(bytes);
                const data = JSON.parse(content);

                STATE.data = data;
                STATE.originalData = JSON.parse(JSON.stringify(data));
                STATE.fileSha = fileData.sha;  // Needed for updates

                console.log('Loaded tasks from GitHub:', data.tasks.length, 'tasks');
                showToast('success', `âœ“ Loaded ${data.tasks.length} tasks from GitHub`);

            } catch (error) {
                console.error('Error loading from GitHub:', error);
                showToast('error', 'Could not load from GitHub, using cached data');
                STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
            }

            STATE.isLoading = false;
            renderAll();
        }

        async function saveTasksToGitHub(commitMessage, forceOverwrite = false) {
            if (!STATE.token || !STATE.data) {
                showToast('error', 'Not logged in');
                return false;
            }

            // Block polling during save
            STATE.isSaving = true;
            
            try {
                // CONFLICT DETECTION: Check if remote has newer version
                if (!forceOverwrite) {
                    const checkResponse = await fetch(
                        `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                        {
                            headers: {
                                'Authorization': `token ${STATE.token}`,
                                'Accept': 'application/vnd.github.v3+json',
                                'If-None-Match': ''  // Bypass cache
                            }
                        }
                    );
                    if (checkResponse.ok) {
                        const remoteFile = await checkResponse.json();
                        if (remoteFile.sha !== STATE.fileSha) {
                            STATE.isSaving = false;
                            // Show conflict dialog
                            const choice = await showConflictDialog();
                            if (choice === 'reload') {
                                // Reload remote version
                                const bytes = Uint8Array.from(atob(remoteFile.content), c => c.charCodeAt(0));
                                const content = new TextDecoder().decode(bytes);
                                STATE.data = JSON.parse(content);
                                STATE.originalData = JSON.parse(JSON.stringify(STATE.data));
                                STATE.fileSha = remoteFile.sha;
                                STATE.hasUnsavedChanges = false;
                                renderAll();
                                showToast('info', 'ğŸ”„ Loaded latest version from GitHub');
                                return false;
                            } else if (choice === 'overwrite') {
                                // Continue with save, using new SHA
                                STATE.fileSha = remoteFile.sha;
                                return saveTasksToGitHub(commitMessage + ' [overwrite]', true);
                            } else {
                                // Cancelled
                                return false;
                            }
                        }
                    }
                }

                const content = btoa(unescape(encodeURIComponent(JSON.stringify(STATE.data, null, 2))));

                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: commitMessage || 'Update tasks via Mission Control',
                            content: content,
                            sha: STATE.fileSha,
                            branch: CONFIG.branch
                        })
                    }
                );

                if (!response.ok) {
                    const error = await response.json();
                    // Handle 409 Conflict specifically
                    if (response.status === 409) {
                        STATE.isSaving = false;
                        showToast('warning', 'âš ï¸ Conflict detected - please refresh');
                        return false;
                    }
                    throw new Error(error.message || 'Failed to save');
                }

                const result = await response.json();
                STATE.fileSha = result.content.sha;
                STATE.originalData = JSON.parse(JSON.stringify(STATE.data));
                STATE.hasUnsavedChanges = false;
                document.getElementById('unsaved-banner').classList.remove('visible');

                showToast('success', 'âœ“ Saved to GitHub!');
                STATE.isSaving = false;
                return true;

            } catch (error) {
                console.error('Error saving to GitHub:', error);
                showToast('error', `Failed to save: ${error.message}`);
                STATE.isSaving = false;
                return false;
            }
        }

        // Conflict resolution dialog
        // === MODAL FACTORY ===
        function createModal({ id, title, body, footer, maxWidth = '500px', onClose = null }) {
            // Remove existing modal with same ID
            const existing = document.getElementById(id);
            if (existing) existing.remove();

            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = id;
            
            // Close on backdrop click
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    closeModal(id);
                    if (onClose) onClose();
                }
            });

            dialog.innerHTML = `
                <div class="modal" style="max-width: ${maxWidth};">
                    <div class="modal-header">
                        <h2 class="modal-title">${title}</h2>
                        <button class="modal-close" onclick="closeModal('${id}')">&times;</button>
                    </div>
                    <div class="modal-body">${body}</div>
                    ${footer ? `<div class="modal-footer">${footer}</div>` : ''}
                </div>
            `;

            document.body.appendChild(dialog);
            return dialog;
        }

        function closeModal(id) {
            const modal = document.getElementById(id);
            if (modal) {
                modal.classList.remove('visible');
                setTimeout(() => modal.remove(), 200);
            }
        }

        // Global ESC key handler for modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const visibleModal = document.querySelector('.modal-overlay.visible');
                if (visibleModal) {
                    closeModal(visibleModal.id);
                }
            }
        });

        function showConflictDialog() {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'modal-overlay visible';
                dialog.id = 'conflict-dialog';
                dialog.innerHTML = `
                    <div class="modal" style="max-width: 450px;">
                        <div class="modal-header">
                            <h2 class="modal-title">âš ï¸ Newer Version Exists</h2>
                        </div>
                        <div class="modal-body">
                            <p style="margin-bottom: 16px;">Someone else (or another process) has updated the tasks since you loaded them.</p>
                            <p style="margin-bottom: 16px;"><strong>What would you like to do?</strong></p>
                        </div>
                        <div class="modal-footer" style="display: flex; gap: 8px; justify-content: flex-end;">
                            <button class="btn btn-secondary" onclick="document.getElementById('conflict-dialog').remove(); window._conflictResolve('cancel')">Cancel</button>
                            <button class="btn btn-primary" onclick="document.getElementById('conflict-dialog').remove(); window._conflictResolve('reload')">ğŸ”„ Load Latest</button>
                            <button class="btn btn-danger" onclick="document.getElementById('conflict-dialog').remove(); window._conflictResolve('overwrite')">âš ï¸ Overwrite</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(dialog);
                window._conflictResolve = resolve;
            });
        }

        // === ERROR BOUNDARY FOR RENDER FUNCTIONS ===
        function safeRender(fn, sectionName = 'section') {
            try {
                fn();
            } catch (error) {
                console.error(`Error rendering ${sectionName}:`, error);
                showToast('error', `Failed to render ${sectionName}. Check console for details.`);
            }
        }

        function renderAll() {
            safeRender(renderFilters, 'filters');
            safeRender(renderTasks, 'tasks');
            safeRender(renderCrons, 'crons');
            safeRender(renderTemplates, 'templates');
            safeRender(renderScheduledTasks, 'scheduled tasks');
            safeRender(renderActivity, 'activity');
            safeRender(updateStats, 'stats');
            safeRender(updateProjectDropdown, 'projects');
        }

        // === CRON RENDERING ===
        async function loadCronsFromGitHub() {
            try {
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/crons.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const content = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    STATE.crons = content.crons || [];
                    STATE.cronsSha = data.sha; // Save SHA for later updates
                    renderCrons();
                }
            } catch (e) {
                console.log('No crons.json found or error loading:', e);
                STATE.crons = [];
            }
        }
        
        // Save crons to GitHub (for fallback when Gateway unavailable)
        async function saveCronsToGitHub(commitMessage) {
            if (!STATE.token) {
                showToast('error', 'Not logged in - cannot save crons');
                return false;
            }
            
            try {
                const content = btoa(unescape(encodeURIComponent(JSON.stringify({ crons: STATE.crons }, null, 2))));
                
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/crons.json`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: commitMessage || 'Update crons via Mission Control',
                            content: content,
                            sha: STATE.cronsSha,
                            branch: CONFIG.branch
                        })
                    }
                );
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to save crons');
                }
                
                const result = await response.json();
                STATE.cronsSha = result.content.sha;
                return true;
                
            } catch (error) {
                console.error('Error saving crons to GitHub:', error);
                showToast('error', `Failed to save crons: ${error.message}`);
                return false;
            }
        }

        function renderCrons() {
            const container = document.getElementById('tasks-recurring');
            const countEl = document.getElementById('count-recurring');
            let crons = STATE.crons || [];
            
            // Apply project filter (matches project OR tags containing the filter)
            if (currentFilter !== 'all') {
                crons = crons.filter(c => 
                    c.project === currentFilter || 
                    (c.tags || []).includes(currentFilter)
                );
            }
            
            // Apply search filter (also search in tags)
            if (searchQuery) {
                crons = crons.filter(c => {
                    const nameMatch = (c.name || '').toLowerCase().includes(searchQuery);
                    const promptMatch = (c.prompt || '').toLowerCase().includes(searchQuery);
                    const scheduleMatch = (c.scheduleHuman || c.schedule || '').toLowerCase().includes(searchQuery);
                    const tagMatch = (c.tags || []).some(tag => tag.toLowerCase().includes(searchQuery));
                    return nameMatch || promptMatch || scheduleMatch || tagMatch;
                });
            }
            
            // Auto-Sort: By lastRunAt (newest first), enabled jobs first
            crons.sort((a, b) => {
                // Enabled jobs first
                if (a.enabled !== b.enabled) return a.enabled ? -1 : 1;
                // Then by lastRunAt (newest first)
                const timeA = a.lastRunAt ? new Date(a.lastRunAt).getTime() : 0;
                const timeB = b.lastRunAt ? new Date(b.lastRunAt).getTime() : 0;
                return timeB - timeA;
            });
            
            countEl.textContent = crons.filter(c => c.enabled).length;
            
            if (crons.length === 0) {
                container.innerHTML = searchQuery || currentFilter !== 'all' 
                    ? '<div class="empty-state">No matching cron jobs</div>'
                    : '<div class="empty-state">No recurring jobs</div>';
                return;
            }
            
            container.innerHTML = crons.map(cron => {
                const statusClass = cron.pendingExecution ? 'pending' :
                                   cron.pending ? 'pending' :
                                   !cron.enabled ? 'disabled' : 
                                   cron.lastStatus === 'error' ? 'error' : 
                                   isRunning(cron) ? 'running' : 'ok';
                const statusText = cron.pendingExecution ? 'Queued â³' :
                                  cron.pending ? 'Pending sync' :
                                  !cron.enabled ? 'Disabled' :
                                  isRunning(cron) ? 'Running...' :
                                  cron.lastStatus === 'error' ? 'Error' : 'Active';
                const nextRun = cron.pendingExecution ? 'Will run on sync' : 
                               cron.pending ? 'â³' : (cron.nextRunAt ? formatRelativeTime(new Date(cron.nextRunAt)) : 'N/A');
                
                const projectData = cron.project ? (STATE.data?.projects || []).find(p => p.id === cron.project) : null;
                const projectTag = projectData ? `<span class="task-tag" style="background: ${projectData.color}20; color: ${projectData.color};">${projectData.icon || ''} ${projectData.name}</span>` : '';
                const cronTags = (cron.tags || []).map(tag => `<span class="task-tag ${tag}">${tag}</span>`).join('');
                const allTags = [projectTag, cronTags].filter(Boolean).join('');
                
                return `
                    <div class="cron-card" 
                         data-cron-id="${cron.id}"
                         draggable="true"
                         ondragstart="handleCronDragStart(event, '${cron.id}')"
                         ondragend="handleCronDragEnd(event)"
                         onclick="openCronDetail('${cron.id}')">
                        <div class="cron-name">${cron.name}</div>
                        <div class="cron-schedule">${cron.scheduleHuman || cronToHuman(cron.schedule) || cron.schedule}</div>
                        ${allTags ? `<div class="task-tags" style="margin: 0.5rem 0;">${allTags}</div>` : ''}
                        <div class="cron-status">
                            <span class="cron-status-dot ${statusClass}"></span>
                            <span>${statusText}</span>
                        </div>
                        <div class="cron-next">Next: ${nextRun}</div>
                    </div>
                `;
            }).join('');
        }

        function isRunning(cron) {
            if (!cron.nextRunAt) return false;
            const nextRun = new Date(cron.nextRunAt).getTime();
            const now = Date.now();
            // Smart running detection:
            // 1. nextRunAt is in the past (job should have started)
            // 2. Within expected duration window (avgDurationMs or fallback to 5 min)
            const expectedDuration = cron.avgDurationMs || 300000; // Default 5 minutes
            const maxRunTime = Math.max(expectedDuration, 60000); // At least 1 minute window
            return nextRun <= now && (now - nextRun) < maxRunTime;
        }

        function formatRelativeTime(date) {
            const now = new Date();
            const diff = date - now;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (diff < 0) return 'overdue';
            if (minutes < 60) return `in ${minutes}m`;
            if (hours < 24) return `in ${hours}h`;
            return `in ${days}d`;
        }

        // === SKILLS RENDERING ===
        async function loadSkillsFromGitHub() {
            try {
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/skills.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const content = JSON.parse(decodeURIComponent(escape(atob(data.content))));
                    // Support both old format (array) and new format ({skills: []})
                    STATE.skills = Array.isArray(content) ? content : (content.skills || []);
                    STATE.skillsSha = data.sha; // Store SHA for updates
                    renderSkills();
                }
            } catch (e) {
                console.log('No skills.json found or error loading:', e);
                STATE.skills = [];
                renderSkills();
            }
        }
        
        function renderSkills() {
            // Render the Skills tab (full page view)
            renderSkillsTab();
        }
        
        function getSkillStatusBadge(skill) {
            const status = skill.configStatus || 'ready';
            const hint = skill.configHint || '';
            
            const badges = {
                'ready': { icon: 'âœ…', class: 'ready' },
                'needs-config': { icon: 'âš ï¸', class: 'needs-config' },
                'missing-deps': { icon: 'âŒ', class: 'missing-deps' },
                'unknown': { icon: 'â“', class: 'needs-config' }
            };
            
            const badge = badges[status] || badges['ready'];
            const tooltip = hint ? ` title="${escapeHtml(hint)}"` : '';
            
            return `<span class="skill-config-badge ${badge.class}"${tooltip}>${badge.icon}</span>`;
        }
        
        function renderSkillDepsSection(skill) {
            const cliDeps = skill.cliDeps || { required: [], found: [], missing: [] };
            const configDeps = skill.configDeps || { required: [], satisfied: [], missing: [] };
            
            // Don't show section if no dependencies detected
            if (cliDeps.required.length === 0 && configDeps.required.length === 0) {
                return '<div class="form-hint" style="margin-top: 0.5rem;">No dependencies detected. This skill should work out of the box.</div>';
            }
            
            let html = '<div class="skill-deps-section">';
            
            // CLI Dependencies
            if (cliDeps.required.length > 0) {
                html += `
                    <div class="skill-deps-title">ğŸ”§ CLI Dependencies</div>
                    <div class="skill-deps-list">
                `;
                for (const cmd of cliDeps.required) {
                    const isFound = cliDeps.found.includes(cmd);
                    html += `
                        <div class="skill-dep-item ${isFound ? 'found' : 'missing'}">
                            <span class="skill-dep-icon">${isFound ? 'âœ…' : 'âŒ'}</span>
                            <code>${cmd}</code>
                            ${isFound ? '<span style="color: var(--text-secondary); font-size: 0.75rem;">(installed)</span>' : '<span style="color: var(--accent-red); font-size: 0.75rem;">(not found)</span>'}
                        </div>
                    `;
                }
                html += '</div>';
            }
            
            // Config/Auth Dependencies
            if (configDeps.required.length > 0) {
                html += `
                    <div class="skill-deps-title" style="margin-top: ${cliDeps.required.length > 0 ? '1rem' : '0'};">ğŸ”‘ Configuration</div>
                    <div class="skill-deps-list">
                `;
                for (const req of configDeps.required) {
                    const isSatisfied = configDeps.satisfied.some(r => 
                        (r.type === 'env' && req.type === 'env' && r.name === req.name) ||
                        (r.type === 'file' && req.type === 'file' && r.path === req.path) ||
                        (r.type === 'command' && req.type === 'command' && r.cmd === req.cmd)
                    );
                    
                    let label = '';
                    if (req.type === 'env') {
                        label = `$${req.name}`;
                    } else if (req.type === 'file') {
                        label = req.path || req.name;
                    } else if (req.type === 'command') {
                        label = req.name || req.cmd;
                    }
                    
                    html += `
                        <div class="skill-dep-item ${isSatisfied ? 'found' : 'missing'}">
                            <span class="skill-dep-icon">${isSatisfied ? 'âœ…' : 'âŒ'}</span>
                            <code>${escapeHtml(label)}</code>
                            ${isSatisfied ? '<span style="color: var(--text-secondary); font-size: 0.75rem;">(configured)</span>' : '<span style="color: var(--accent-red); font-size: 0.75rem;">(missing)</span>'}
                        </div>
                    `;
                }
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        function openSkillDetail(skillId) {
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) {
                showToast('error', 'Skill not found');
                return;
            }
            
            const isEditable = skill.editable === true;
            const skillMdContent = skill.skillMdContent || '';
            const statusBadge = getSkillStatusBadge(skill);
            const depsSection = renderSkillDepsSection(skill);
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'skill-editor-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 800px; max-height: 90vh;">
                    <div class="modal-header">
                        <h2 class="modal-title">${skill.emoji || 'ğŸ”§'} ${skill.name} ${statusBadge}</h2>
                        <button class="modal-close" onclick="closeSkillDetail()">&times;</button>
                    </div>
                    <div class="modal-body" style="max-height: calc(90vh - 140px); overflow-y: auto;">
                        <!-- Tabs -->
                        <div class="skill-tabs" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 1px solid var(--border-color);">
                            <button class="skill-tab active" onclick="switchSkillTab('overview', this)">ğŸ“‹ Overview</button>
                            <button class="skill-tab" onclick="switchSkillTab('deps', this)">ğŸ”§ Dependencies</button>
                            <button class="skill-tab" onclick="switchSkillTab('editor', this)">ğŸ“ SKILL.md ${!isEditable ? '(read-only)' : ''}</button>
                        </div>
                        
                        <!-- Overview Tab -->
                        <div id="skill-tab-overview" class="skill-tab-content">
                            <div class="form-group">
                                <label class="form-label">Description</label>
                                <div class="skill-detail-text">${skill.description || 'No description available'}</div>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Details</label>
                                <div class="skill-detail-meta">
                                    <div><strong>Location:</strong> <code style="font-size: 0.8rem; word-break: break-all;">${skill.location || 'Unknown'}</code></div>
                                    <div><strong>Source:</strong> <span class="skill-source-badge ${skill.source}">${skill.source === 'builtin' ? 'ğŸ“¦ Built-in (read-only)' : skill.source === 'workspace' ? 'ğŸ“ Workspace (editable)' : skill.source || 'Unknown'}</span></div>
                                    ${skill.homepage ? `<div><strong>Homepage:</strong> <a href="${skill.homepage}" target="_blank" rel="noopener">${skill.homepage}</a></div>` : ''}
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                    <input type="checkbox" id="skill-enabled-toggle" ${skill.enabled !== false ? 'checked' : ''}>
                                    <span>Enabled</span>
                                </label>
                                <div class="form-hint">Disabled skills won't appear in the agent's available_skills list.</div>
                            </div>
                        </div>
                        
                        <!-- Dependencies Tab -->
                        <div id="skill-tab-deps" class="skill-tab-content" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Skill Dependencies & Configuration</label>
                                ${depsSection}
                            </div>
                        </div>
                        
                        <!-- SKILL.md Editor Tab -->
                        <div id="skill-tab-editor" class="skill-tab-content" style="display: none;">
                            ${isEditable ? `
                                <div class="form-group">
                                    <label class="form-label">Edit SKILL.md</label>
                                    <textarea id="skill-md-editor" class="form-input skill-md-textarea" rows="20" 
                                              style="font-family: monospace; font-size: 0.85rem; line-height: 1.4;"
                                              placeholder="SKILL.md content...">${escapeHtml(skillMdContent)}</textarea>
                                    <div class="form-hint">Changes will be saved to: ${skill.location}/SKILL.md</div>
                                </div>
                            ` : `
                                <div class="form-group">
                                    <label class="form-label">SKILL.md (read-only)</label>
                                    <div class="skill-md-readonly" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                                        <pre style="margin: 0; white-space: pre-wrap; font-size: 0.85rem; line-height: 1.4;">${escapeHtml(skillMdContent) || 'Content not available for built-in skills. View the file directly at:\n' + skill.location + '/SKILL.md'}</pre>
                                    </div>
                                    <div class="form-hint" style="margin-top: 0.5rem;">
                                        ğŸ’¡ Built-in skills cannot be edited. To customize, copy to ~/clawd/skills/${skill.id}/ and edit there.
                                    </div>
                                </div>
                            `}
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeSkillDetail()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveSkillChanges('${skill.id}')">${isEditable ? 'Save All Changes' : 'Save Settings'}</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function switchSkillTab(tabName, button) {
            // Hide all tabs
            document.querySelectorAll('.skill-tab-content').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.skill-tab').forEach(el => el.classList.remove('active'));
            
            // Show selected tab
            document.getElementById('skill-tab-' + tabName).style.display = 'block';
            button.classList.add('active');
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function closeSkillDetail() {
            const dialog = document.getElementById('skill-editor-dialog');
            if (dialog) dialog.remove();
        }
        
        async function saveSkillChanges(skillId) {
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) return;
            
            const enabled = document.getElementById('skill-enabled-toggle').checked;
            const editorEl = document.getElementById('skill-md-editor');
            const newSkillMdContent = editorEl ? editorEl.value : null;
            
            // Track what changed
            const changes = [];
            
            // Update enabled status
            if (skill.enabled !== enabled) {
                skill.enabled = enabled;
                skill.pendingSync = true;
                changes.push(enabled ? 'enabled' : 'disabled');
            }
            
            // Update SKILL.md content (for editable skills)
            if (skill.editable && newSkillMdContent !== null && newSkillMdContent !== skill.skillMdContent) {
                skill.pendingSkillMdContent = newSkillMdContent;
                skill.skillMdContent = newSkillMdContent; // Update local state
                changes.push('SKILL.md updated');
            }
            
            if (changes.length === 0) {
                closeSkillDetail();
                showToast('info', 'No changes to save');
                return;
            }
            
            // Save to GitHub
            try {
                await saveSkillsToGitHub(`Update skill ${skill.name}: ${changes.join(', ')}`);
                closeSkillDetail();
                renderSkills();
                showToast('success', `${skill.name}: ${changes.join(', ')} (syncs on next cron run)`);
            } catch (error) {
                showToast('error', 'Failed to save: ' + error.message);
            }
        }
        
        async function saveSkillsToGitHub(commitMessage) {
            if (!STATE.token) {
                showToast('error', 'Not logged in - cannot save');
                return;
            }
            
            const content = btoa(unescape(encodeURIComponent(JSON.stringify({ 
                skills: STATE.skills,
                updatedAt: new Date().toISOString()
            }, null, 2))));
            
            // Get current SHA
            const getResponse = await fetch(
                `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/skills.json`,
                { headers: { 'Authorization': `token ${STATE.token}` } }
            );
            
            let sha = null;
            if (getResponse.ok) {
                const data = await getResponse.json();
                sha = data.sha;
            }
            
            const body = {
                message: commitMessage || 'Update skills via Mission Control',
                content,
                branch: 'main'
            };
            if (sha) body.sha = sha;
            
            const response = await fetch(
                `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/data/skills.json`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${STATE.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                }
            );
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Failed to save');
            }
        }
        
        function createSkillTicket(skillId) {
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) return;
            
            closeSkillDetail();
            
            // Open new task modal with prefilled skill context
            openNewTask('backlog');
            
            // Wait for modal to render, then prefill
            setTimeout(() => {
                const titleInput = document.querySelector('#new-task-modal input[type="text"]');
                const descTextarea = document.querySelector('#new-task-modal textarea');
                
                if (titleInput) {
                    titleInput.value = `[${skill.name}] `;
                    titleInput.focus();
                    titleInput.setSelectionRange(titleInput.value.length, titleInput.value.length);
                }
                
                if (descTextarea) {
                    descTextarea.value = `**Skill:** ${skill.emoji} ${skill.name}\n**Pfad:** ${skill.location}/SKILL.md\n\n---\n\n`;
                }
            }, 100);
        }

        // =====================================================
        // SKILLS TAB - Full Page Layout Functions
        // =====================================================
        
        // State for Skills Tab
        STATE.skillsFilter = 'all';
        STATE.skillsFilters = [];  // Multi-select filters
        STATE.skillsSearchQuery = '';
        
        function renderSkillsTab() {
            const container = document.getElementById('skills-grid-container');
            if (!container) return;
            
            const skills = STATE.skills || [];
            const filters = STATE.skillsFilters || [];
            const searchQuery = (STATE.skillsSearchQuery || '').toLowerCase();
            
            // Filter skills
            let filteredSkills = skills.filter(skill => {
                // Search filter
                if (searchQuery) {
                    const matchesSearch = 
                        (skill.name || '').toLowerCase().includes(searchQuery) ||
                        (skill.description || '').toLowerCase().includes(searchQuery) ||
                        (skill.id || '').toLowerCase().includes(searchQuery);
                    if (!matchesSearch) return false;
                }
                
                // Multi-filter: if no filters selected, show all
                if (filters.length === 0) return true;
                
                // Group filters by category for AND logic between categories
                const enabledFilters = filters.filter(f => f === 'enabled' || f === 'disabled');
                const statusFilters = filters.filter(f => f === 'ready' || f === 'needs-setup');
                const sourceFilters = filters.filter(f => f === 'builtin' || f === 'workspace');
                
                // Check each category - within category: OR, between categories: AND
                const matchesEnabled = enabledFilters.length === 0 || enabledFilters.some(f => {
                    if (f === 'enabled') return skill.enabled !== false;
                    if (f === 'disabled') return skill.enabled === false;
                    return false;
                });
                
                const matchesStatus = statusFilters.length === 0 || statusFilters.some(f => {
                    if (f === 'ready') return (skill.configStatus || 'ready') === 'ready';
                    if (f === 'needs-setup') return skill.configStatus === 'needs-config' || skill.configStatus === 'missing-deps';
                    return false;
                });
                
                const matchesSource = sourceFilters.length === 0 || sourceFilters.some(f => {
                    if (f === 'builtin') return skill.source === 'builtin';
                    if (f === 'workspace') return skill.source === 'workspace';
                    return false;
                });
                
                // AND between categories (smallest common denominator)
                return matchesEnabled && matchesStatus && matchesSource;
            });
            
            // Sort alphabetically
            filteredSkills.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
            
            // Update stats
            updateSkillsStats(skills);
            
            // Render empty state
            if (filteredSkills.length === 0) {
                container.innerHTML = `
                    <div class="skills-empty">
                        <div class="skills-empty-icon">ğŸ”</div>
                        <div class="skills-empty-title">No skills found</div>
                        <div class="skills-empty-text">
                            ${searchQuery ? 'Try a different search term or clear filters.' : 'No skills match the selected filter.'}
                        </div>
                    </div>
                `;
                return;
            }
            
            // Group skills by category (auto-categories)
            const builtinSkills = filteredSkills.filter(s => s.source === 'builtin');
            const workspaceSkills = filteredSkills.filter(s => s.source === 'workspace');
            
            let html = '';
            
            // Workspace Skills first (if any)
            // Show if: no filters OR workspace filter active OR not specifically filtering only for builtin
            const showWorkspace = workspaceSkills.length > 0 && (filters.length === 0 || !filters.includes('builtin') || filters.includes('workspace'));
            if (showWorkspace) {
                html += `
                    <div class="skills-category">
                        <div class="skills-category-header">
                            <span class="skills-category-title">ğŸ  Workspace Skills</span>
                            <span class="skills-category-count">${workspaceSkills.length}</span>
                        </div>
                        <div class="skills-grid">
                            ${workspaceSkills.map(skill => renderSkillCard(skill)).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Built-in Skills
            const showBuiltin = builtinSkills.length > 0 && (filters.length === 0 || !filters.includes('workspace') || filters.includes('builtin'));
            if (showBuiltin) {
                html += `
                    <div class="skills-category">
                        <div class="skills-category-header">
                            <span class="skills-category-title">ğŸ“¦ Built-in Skills</span>
                            <span class="skills-category-count">${builtinSkills.length}</span>
                        </div>
                        <div class="skills-grid">
                            ${builtinSkills.map(skill => renderSkillCard(skill)).join('')}
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function renderSkillCard(skill) {
            const statusBadge = getSkillStatusBadge(skill);
            const isDisabled = skill.enabled === false;
            const isMissingDeps = skill.configStatus === 'missing-deps';
            const sourceBadge = skill.source === 'builtin' 
                ? '<span class="skill-source-badge builtin">Built-in</span>'
                : '<span class="skill-source-badge workspace">Workspace</span>';
            
            // Toggle for installed skills, "Install" button for missing deps
            const actionElement = isMissingDeps
                ? `<button class="skill-install-btn" onclick="event.stopPropagation(); installSkill('${skill.id}')">
                       Install
                   </button>`
                : `<label class="skill-toggle" onclick="event.stopPropagation()">
                       <input type="checkbox" 
                              ${!isDisabled ? 'checked' : ''} 
                              onchange="toggleSkillEnabled('${skill.id}', this.checked)">
                       <span class="skill-toggle-slider"></span>
                   </label>`;
            
            return `
                <div class="skill-card-full${isDisabled ? ' disabled' : ''}${isMissingDeps ? ' not-installed' : ''}" 
                     onclick="openSkillPanel('${skill.id}')"
                     data-skill-id="${skill.id}">
                    <div class="skill-card-top">
                        <div class="skill-card-info">
                            <span class="skill-card-emoji">${skill.emoji || 'ğŸ”§'}</span>
                            <span class="skill-card-title">${escapeHtml(skill.name)}</span>
                        </div>
                        ${actionElement}
                    </div>
                    <div class="skill-card-desc">${escapeHtml(skill.description || 'No description')}</div>
                    <div class="skill-card-footer">
                        <div class="skill-card-badges">
                            ${sourceBadge}
                            ${statusBadge}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function updateSkillsStats(skills) {
            const total = skills.length;
            const ready = skills.filter(s => (s.configStatus || 'ready') === 'ready').length;
            const needsSetup = skills.filter(s => s.configStatus === 'needs-config' || s.configStatus === 'missing-deps').length;
            
            const totalEl = document.getElementById('skills-total');
            const readyEl = document.getElementById('skills-ready');
            const needsSetupEl = document.getElementById('skills-needs-setup');
            
            if (totalEl) totalEl.textContent = total;
            if (readyEl) readyEl.textContent = ready;
            if (needsSetupEl) needsSetupEl.textContent = needsSetup;
        }
        
        function handleSkillSearch(query) {
            STATE.skillsSearchQuery = query;
            // Show/hide clear button
            const clearBtn = document.getElementById('skills-search-clear');
            if (clearBtn) {
                clearBtn.style.display = query ? 'block' : 'none';
            }
            renderSkillsTab();
        }
        
        function clearSkillSearch() {
            const input = document.getElementById('skills-search-input');
            if (input) {
                input.value = '';
                input.focus();
            }
            handleSkillSearch('');
        }
        
        function toggleSkillFilter(filter) {
            // Initialize filters array if needed
            if (!STATE.skillsFilters) {
                STATE.skillsFilters = [];
            }
            
            // Toggle the filter
            const index = STATE.skillsFilters.indexOf(filter);
            if (index > -1) {
                STATE.skillsFilters.splice(index, 1);
            } else {
                STATE.skillsFilters.push(filter);
            }
            
            // Update active states
            updateFilterChipStates();
            renderSkillsTab();
        }
        
        function resetSkillFilters() {
            STATE.skillsFilters = [];
            updateFilterChipStates();
            renderSkillsTab();
        }
        
        function updateFilterChipStates() {
            const filters = STATE.skillsFilters || [];
            const allActive = filters.length === 0;
            
            document.querySelectorAll('.skills-filter-chip').forEach(chip => {
                const filter = chip.dataset.filter;
                if (filter === 'all') {
                    chip.classList.toggle('active', allActive);
                } else {
                    chip.classList.toggle('active', filters.includes(filter));
                }
            });
        }
        
        // Keep old function for compatibility
        function setSkillFilter(filter) {
            if (filter === 'all') {
                resetSkillFilters();
            } else {
                STATE.skillsFilters = [filter];
                updateFilterChipStates();
                renderSkillsTab();
            }
        }
        
        async function toggleSkillEnabled(skillId, enabled) {
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) return;
            
            // Update local state
            skill.enabled = enabled;
            skill.pendingSync = true;
            
            // Re-render card to update visual state
            const card = document.querySelector(`[data-skill-id="${skillId}"]`);
            if (card) {
                card.classList.toggle('disabled', !enabled);
            }
            
            // Show toast
            showToast('success', `${skill.name} ${enabled ? 'enabled' : 'disabled'}`);
            
            // Update stats
            updateSkillsStats(STATE.skills);
            
            // Save to GitHub
            try {
                await saveSkillsToGitHub(`${enabled ? 'Enable' : 'Disable'} skill: ${skill.name}`);
            } catch (e) {
                console.error('Failed to save skill state:', e);
                showToast('error', 'Failed to save - changes may not persist');
            }
        }
        
        function installSkill(skillId) {
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) return;
            
            // Open ClawdHub page for this skill
            const clawdhubUrl = `https://clawdhub.com/skills/${skill.id}`;
            window.open(clawdhubUrl, '_blank');
            
            showToast('info', `Opening ClawdHub to install ${skill.name}...`);
        }
        
        function openSkillPanel(skillId) {
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) {
                showToast('error', 'Skill not found');
                return;
            }
            
            STATE.currentPanelSkillId = skillId;
            
            // Update panel header
            document.getElementById('skill-panel-emoji').textContent = skill.emoji || 'ğŸ”§';
            document.getElementById('skill-panel-name').textContent = skill.name;
            
            // Build panel content
            const isEditable = skill.editable === true;
            const statusBadge = getSkillStatusBadge(skill);
            const depsSection = renderSkillDepsSection(skill);
            
            const content = `
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">Description</div>
                    <div class="skill-detail-text">${escapeHtml(skill.description || 'No description available')}</div>
                </div>
                
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">Status</div>
                    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                        ${statusBadge}
                        <span class="skill-source-badge ${skill.source}">${skill.source === 'builtin' ? 'ğŸ“¦ Built-in' : 'ğŸ  Workspace'}</span>
                        ${skill.enabled !== false 
                            ? '<span style="color: #10b981;">âœ“ Enabled</span>' 
                            : '<span style="color: var(--text-secondary);">â—‹ Disabled</span>'}
                    </div>
                </div>
                
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">Location</div>
                    <code style="font-size: 0.8rem; word-break: break-all; color: var(--text-secondary);">${escapeHtml(skill.location || 'Unknown')}</code>
                </div>
                
                ${skill.homepage ? `
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">Homepage</div>
                    <a href="${skill.homepage}" target="_blank" rel="noopener" style="color: var(--accent-blue);">${skill.homepage}</a>
                </div>
                ` : ''}
                
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">Dependencies</div>
                    ${depsSection}
                </div>
                
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">Settings</div>
                    <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; padding: 0.5rem 0;">
                        <input type="checkbox" id="panel-skill-enabled" ${skill.enabled !== false ? 'checked' : ''} style="width: 18px; height: 18px;">
                        <span>Enabled</span>
                    </label>
                    <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        Disabled skills won't appear in the agent's available skills list.
                    </div>
                </div>
                
                ${isEditable ? `
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">SKILL.md</div>
                    <textarea id="panel-skill-md-editor" class="skill-md-textarea" rows="12" 
                              style="font-family: monospace; font-size: 0.8rem;"
                              placeholder="SKILL.md content...">${escapeHtml(skill.skillMdContent || '')}</textarea>
                </div>
                ` : `
                <div class="skill-panel-section">
                    <div class="skill-panel-section-title">SKILL.md (read-only)</div>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 8px; max-height: 200px; overflow-y: auto;">
                        <pre style="margin: 0; white-space: pre-wrap; font-size: 0.8rem; color: var(--text-secondary);">${escapeHtml(skill.skillMdContent || 'Content not available for built-in skills.')}</pre>
                    </div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem;">
                        ğŸ’¡ Built-in skills cannot be edited. Copy to workspace to customize.
                    </div>
                </div>
                `}
            `;
            
            document.getElementById('skill-panel-content').innerHTML = content;
            
            // Update save button text
            document.getElementById('skill-panel-save').textContent = isEditable ? 'Save All Changes' : 'Save Settings';
            
            // Show panel
            document.getElementById('skill-panel-overlay').classList.add('visible');
            document.getElementById('skill-panel').classList.add('visible');
            
            // Add ESC key listener
            document.addEventListener('keydown', handleSkillPanelEsc);
        }
        
        function closeSkillPanel() {
            document.getElementById('skill-panel-overlay').classList.remove('visible');
            document.getElementById('skill-panel').classList.remove('visible');
            document.removeEventListener('keydown', handleSkillPanelEsc);
            STATE.currentPanelSkillId = null;
        }
        
        function handleSkillPanelEsc(e) {
            if (e.key === 'Escape') {
                closeSkillPanel();
            }
        }
        
        async function saveSkillFromPanel() {
            const skillId = STATE.currentPanelSkillId;
            if (!skillId) return;
            
            const skill = (STATE.skills || []).find(s => s.id === skillId);
            if (!skill) return;
            
            const enabledCheckbox = document.getElementById('panel-skill-enabled');
            const mdEditor = document.getElementById('panel-skill-md-editor');
            
            const enabled = enabledCheckbox ? enabledCheckbox.checked : skill.enabled;
            const newMdContent = mdEditor ? mdEditor.value : null;
            
            const changes = [];
            
            // Update enabled status
            if (skill.enabled !== enabled) {
                skill.enabled = enabled;
                skill.pendingSync = true;
                changes.push(enabled ? 'enabled' : 'disabled');
            }
            
            // Update SKILL.md content (for editable skills)
            if (newMdContent !== null && skill.editable && newMdContent !== skill.skillMdContent) {
                skill.skillMdContent = newMdContent;
                skill.pendingSync = true;
                changes.push('updated SKILL.md');
            }
            
            if (changes.length === 0) {
                showToast('info', 'No changes to save');
                closeSkillPanel();
                return;
            }
            
            try {
                await saveSkillsToGitHub(`Update skill ${skill.name}: ${changes.join(', ')}`);
                showToast('success', `Saved: ${changes.join(', ')}`);
                renderSkillsTab();
                closeSkillPanel();
            } catch (e) {
                console.error('Failed to save skill:', e);
                showToast('error', 'Failed to save changes');
            }
        }
        
        async function refreshSkills() {
            showToast('info', 'Refreshing skills...');
            await loadSkillsFromGitHub();
            renderSkillsTab();
            showToast('success', 'Skills refreshed');
        }
        
        function openClawdHub() {
            window.open('https://clawdhub.com', '_blank');
        }

        // =====================================================
        // BRAIN TAB - Memory Management Functions
        // =====================================================
        
        // State for Brain Tab
        STATE.brainMemoryFiles = [];      // List of memory files from GitHub
        STATE.brainOpenFiles = [];         // Currently open files (tabs)
        STATE.brainActiveFile = null;      // Currently active file path
        STATE.brainFileContents = {};      // Cached file contents by path
        STATE.brainModifiedFiles = {};     // Track modified files
        STATE.brainTags = new Set();       // All extracted tags
        STATE.brainActiveTag = null;       // Currently filtered tag
        STATE.brainSearchQuery = '';       // Search query
        STATE.brainSearchResults = {};     // Search results per file
        STATE.brainChangelog = [];         // Git history
        STATE.brainPreviewMode = false;    // Preview toggle
        STATE.brainChangelogCollapsed = false;
        STATE.brainContentsLoaded = false; // Track if all contents are loaded
        
        async function renderBrainTab() {
            // Load memory files if not loaded
            if (STATE.brainMemoryFiles.length === 0) {
                await loadMemoryFiles();
            }
            renderMemoryFileTree();
            renderBrainTagCloud();
            renderBrainChangelog();
            
            // Pre-load all file contents for search (in background)
            if (!STATE.brainContentsLoaded && STATE.brainMemoryFiles.length > 0) {
                STATE.brainContentsLoaded = true;
                loadAllMemoryContents().then(() => {
                    console.log('All memory contents loaded for search');
                });
            }
        }
        
        async function loadMemoryFiles() {
            if (!STATE.token) {
                showBrainEmpty('Connect to GitHub to view your memory files.');
                return;
            }
            
            try {
                // Load MEMORY.md
                const memoryFiles = [];
                
                // Get MEMORY.md
                try {
                    const memoryMd = await fetchGitHubFile('MEMORY.md');
                    if (memoryMd) {
                        memoryFiles.push({
                            path: 'MEMORY.md',
                            name: 'MEMORY.md',
                            type: 'long-term',
                            sha: memoryMd.sha
                        });
                    }
                } catch (e) {
                    console.log('MEMORY.md not found');
                }
                
                // Get memory/ folder contents
                try {
                    const memoryFolder = await fetchGitHubDirectory('memory');
                    if (memoryFolder && Array.isArray(memoryFolder)) {
                        for (const file of memoryFolder) {
                            if (file.name.endsWith('.md')) {
                                memoryFiles.push({
                                    path: file.path,
                                    name: file.name,
                                    type: 'daily',
                                    sha: file.sha
                                });
                            }
                        }
                    }
                } catch (e) {
                    console.log('memory/ folder not found');
                }
                
                // Sort: MEMORY.md first, then daily files by date descending
                memoryFiles.sort((a, b) => {
                    if (a.type === 'long-term') return -1;
                    if (b.type === 'long-term') return 1;
                    return b.name.localeCompare(a.name);
                });
                
                STATE.brainMemoryFiles = memoryFiles;
                
            } catch (error) {
                console.error('Error loading memory files:', error);
                showToast('error', 'Failed to load memory files');
            }
        }
        
        async function fetchGitHubFile(path) {
            const response = await fetch(
                `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${path}?ref=${CONFIG.branch}`,
                { headers: { 'Authorization': `token ${STATE.token}` } }
            );
            if (!response.ok) return null;
            return await response.json();
        }
        
        async function fetchGitHubDirectory(path) {
            const response = await fetch(
                `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${path}?ref=${CONFIG.branch}`,
                { headers: { 'Authorization': `token ${STATE.token}` } }
            );
            if (!response.ok) return null;
            return await response.json();
        }
        
        function renderMemoryFileTree() {
            const container = document.getElementById('brain-file-tree');
            if (!container) return;
            
            let files = STATE.brainMemoryFiles;
            const searchQuery = (STATE.brainSearchQuery || '').toLowerCase();
            const activeTag = STATE.brainActiveTag;
            
            if (files.length === 0) {
                container.innerHTML = `
                    <div class="brain-empty">
                        <div class="brain-empty-icon">ğŸ“‚</div>
                        <div class="brain-empty-title">No memory files</div>
                        <div class="brain-empty-text">Create your first memory entry with the Knowledge Builder.</div>
                    </div>
                `;
                return;
            }
            
            // Filter by tag
            if (activeTag) {
                files = files.filter(f => {
                    const content = STATE.brainFileContents[f.path] || '';
                    return content.toLowerCase().includes(activeTag.toLowerCase());
                });
            }
            
            // Filter by search query
            if (searchQuery.length >= 2) {
                files = files.filter(f => {
                    // Check filename
                    if (f.name.toLowerCase().includes(searchQuery)) return true;
                    // Check content
                    const content = STATE.brainFileContents[f.path] || '';
                    return content.toLowerCase().includes(searchQuery);
                });
            }
            
            // Group files
            const longTermFiles = files.filter(f => f.type === 'long-term');
            const dailyFiles = files.filter(f => f.type === 'daily');
            
            let html = '';
            
            // Show filter status
            const totalFiles = STATE.brainMemoryFiles.length;
            const filteredCount = files.length;
            if (activeTag || searchQuery.length >= 2) {
                html += `
                    <div class="brain-filter-status">
                        Showing ${filteredCount} of ${totalFiles} files
                        ${activeTag ? `<span class="brain-filter-tag">#${activeTag}</span>` : ''}
                        ${searchQuery.length >= 2 ? `<span class="brain-filter-query">"${escapeHtml(searchQuery)}"</span>` : ''}
                        <button class="brain-filter-clear" onclick="clearBrainFilters()">Clear</button>
                    </div>
                `;
            }
            
            // Long-term memory section
            if (longTermFiles.length > 0) {
                html += `
                    <div class="brain-file-group">
                        <div class="brain-file-group-header" onclick="toggleBrainFileGroup(this)">
                            <span>ğŸ§  Long-term Memory</span>
                            <span class="brain-file-group-count">${longTermFiles.length}</span>
                        </div>
                        <div class="brain-file-group-items">
                            ${longTermFiles.map(f => renderBrainFileItem(f, searchQuery)).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Daily notes section
            if (dailyFiles.length > 0) {
                html += `
                    <div class="brain-file-group">
                        <div class="brain-file-group-header" onclick="toggleBrainFileGroup(this)">
                            <span>ğŸ“… Daily Notes</span>
                            <span class="brain-file-group-count">${dailyFiles.length}</span>
                        </div>
                        <div class="brain-file-group-items">
                            ${dailyFiles.map(f => renderBrainFileItem(f, searchQuery)).join('')}
                        </div>
                    </div>
                `;
            }
            
            // No results message
            if (files.length === 0) {
                html += `
                    <div class="brain-empty">
                        <div class="brain-empty-icon">ğŸ”</div>
                        <div class="brain-empty-title">No matches found</div>
                        <div class="brain-empty-text">Try a different search term or clear filters.</div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function clearBrainFilters() {
            STATE.brainSearchQuery = '';
            STATE.brainActiveTag = null;
            STATE.brainSearchResults = {};
            document.getElementById('brain-search-input').value = '';
            renderMemoryFileTree();
            renderBrainTagCloud();
        }
        
        function renderBrainFileItem(file, searchQuery = '') {
            const isActive = STATE.brainActiveFile === file.path;
            const isModified = STATE.brainModifiedFiles[file.path];
            const icon = file.type === 'long-term' ? 'ğŸ§ ' : 'ğŸ“„';
            const hasSearchMatch = STATE.brainSearchResults[file.path] && STATE.brainSearchResults[file.path].length > 0;
            
            // Format date from filename if daily
            let displayName = file.name;
            if (file.type === 'daily') {
                const match = file.name.match(/(\d{4}-\d{2}-\d{2})/);
                if (match) {
                    const date = new Date(match[1]);
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    
                    if (match[1] === today.toISOString().split('T')[0]) {
                        displayName = 'Today';
                    } else if (match[1] === yesterday.toISOString().split('T')[0]) {
                        displayName = 'Yesterday';
                    } else {
                        displayName = date.toLocaleDateString('de-DE', { 
                            day: 'numeric', month: 'short', year: 'numeric' 
                        });
                    }
                }
            }
            
            // Build search match preview
            let matchPreview = '';
            if (hasSearchMatch) {
                const matches = STATE.brainSearchResults[file.path].slice(0, 2);
                matchPreview = `
                    <div class="brain-file-matches">
                        ${matches.map(m => `
                            <div class="brain-file-match">
                                <span class="brain-file-match-line">L${m.line}:</span>
                                <span class="brain-file-match-text">${escapeHtml(m.text.substring(0, 50))}...</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            return `
                <div class="brain-file-item${isActive ? ' active' : ''}${isModified ? ' modified' : ''}${hasSearchMatch ? ' has-match' : ''}" 
                     onclick="openMemoryFile('${file.path}')">
                    <div class="brain-file-item-header">
                        <span class="brain-file-icon">${icon}</span>
                        <span class="brain-file-name">${escapeHtml(displayName)}</span>
                        ${hasSearchMatch ? `<span class="brain-file-match-count">${STATE.brainSearchResults[file.path].length}</span>` : ''}
                    </div>
                    ${matchPreview}
                </div>
            `;
        }
        
        function toggleBrainFileGroup(header) {
            const items = header.nextElementSibling;
            items.style.display = items.style.display === 'none' ? 'block' : 'none';
            header.classList.toggle('collapsed');
        }
        
        async function openMemoryFile(path) {
            STATE.brainActiveFile = path;
            
            // Add to open files if not already open
            if (!STATE.brainOpenFiles.includes(path)) {
                STATE.brainOpenFiles.push(path);
            }
            
            // Load content if not cached
            if (!STATE.brainFileContents[path]) {
                try {
                    const fileData = await fetchGitHubFile(path);
                    if (fileData && fileData.content) {
                        STATE.brainFileContents[path] = atob(fileData.content);
                        extractTagsFromContent(STATE.brainFileContents[path]);
                    }
                } catch (error) {
                    console.error('Error loading file:', error);
                    showToast('error', 'Failed to load file');
                    return;
                }
            }
            
            renderBrainEditor();
            renderBrainEditorTabs();
            renderMemoryFileTree();
        }
        
        function extractTagsFromContent(content) {
            const tags = content.match(/#[a-zA-Z0-9_-]+/g) || [];
            tags.forEach(tag => STATE.brainTags.add(tag));
            renderBrainTagCloud();
        }
        
        function renderBrainTagCloud() {
            const container = document.getElementById('brain-tag-cloud');
            if (!container) return;
            
            const tags = Array.from(STATE.brainTags).sort();
            
            if (tags.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.75rem;">No tags yet</span>';
                return;
            }
            
            container.innerHTML = tags.map(tag => `
                <span class="brain-tag${STATE.brainActiveTag === tag ? ' active' : ''}" 
                      onclick="toggleBrainTagFilter('${escapeHtml(tag)}')">
                    ${escapeHtml(tag)}
                </span>
            `).join('');
        }
        
        function toggleBrainTagFilter(tag) {
            STATE.brainActiveTag = STATE.brainActiveTag === tag ? null : tag;
            renderBrainTagCloud();
            renderMemoryFileTree();
        }
        
        function renderBrainEditorTabs() {
            const container = document.getElementById('brain-editor-tabs');
            if (!container) return;
            
            if (STATE.brainOpenFiles.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.875rem; padding: 0.5rem;">Select a file to edit</span>';
                return;
            }
            
            container.innerHTML = STATE.brainOpenFiles.map(path => {
                const file = STATE.brainMemoryFiles.find(f => f.path === path);
                const name = file ? file.name : path;
                const isActive = STATE.brainActiveFile === path;
                const isModified = STATE.brainModifiedFiles[path];
                
                return `
                    <div class="brain-editor-tab${isActive ? ' active' : ''}" onclick="openMemoryFile('${path}')">
                        <span>${escapeHtml(name)}${isModified ? ' â€¢' : ''}</span>
                        <span class="brain-editor-tab-close" onclick="event.stopPropagation(); closeBrainTab('${path}')">Ã—</span>
                    </div>
                `;
            }).join('');
        }
        
        function closeBrainTab(path) {
            const index = STATE.brainOpenFiles.indexOf(path);
            if (index > -1) {
                STATE.brainOpenFiles.splice(index, 1);
                delete STATE.brainFileContents[path];
                delete STATE.brainModifiedFiles[path];
                
                // Switch to another tab or clear editor
                if (STATE.brainActiveFile === path) {
                    if (STATE.brainOpenFiles.length > 0) {
                        openMemoryFile(STATE.brainOpenFiles[Math.max(0, index - 1)]);
                    } else {
                        STATE.brainActiveFile = null;
                        renderBrainEditor();
                    }
                }
                renderBrainEditorTabs();
            }
        }
        
        function renderBrainEditor() {
            const contentContainer = document.getElementById('brain-editor-content');
            const toolbar = document.getElementById('brain-editor-toolbar');
            const footer = document.getElementById('brain-editor-footer');
            const previewToggle = document.getElementById('brain-preview-toggle');
            
            if (!STATE.brainActiveFile) {
                contentContainer.innerHTML = `
                    <div class="brain-empty">
                        <div class="brain-empty-icon">ğŸ§ </div>
                        <div class="brain-empty-title">Your Memory, Organized</div>
                        <div class="brain-empty-text">
                            Select a file from the explorer to view and edit, or use the Knowledge Builder to add new information.
                        </div>
                    </div>
                `;
                toolbar.style.display = 'none';
                footer.style.display = 'none';
                previewToggle.disabled = true;
                return;
            }
            
            const content = STATE.brainFileContents[STATE.brainActiveFile] || '';
            
            toolbar.style.display = 'flex';
            footer.style.display = 'flex';
            previewToggle.disabled = false;
            
            if (STATE.brainPreviewMode) {
                contentContainer.innerHTML = `
                    <div class="brain-preview">
                        ${renderMarkdown(content)}
                    </div>
                `;
            } else {
                contentContainer.innerHTML = `
                    <textarea class="brain-textarea" 
                              id="brain-editor-textarea"
                              spellcheck="false"
                              oninput="handleBrainEdit()"
                              onkeyup="updateBrainCursorPos()"
                              onclick="updateBrainCursorPos()">${escapeHtml(content)}</textarea>
                `;
            }
            
            updateBrainStats(content);
        }
        
        function handleBrainEdit() {
            const textarea = document.getElementById('brain-editor-textarea');
            if (!textarea || !STATE.brainActiveFile) return;
            
            const newContent = textarea.value;
            STATE.brainFileContents[STATE.brainActiveFile] = newContent;
            STATE.brainModifiedFiles[STATE.brainActiveFile] = true;
            
            // Update UI
            renderBrainEditorTabs();
            renderMemoryFileTree();
            updateBrainStats(newContent);
            
            // Extract new tags
            extractTagsFromContent(newContent);
            
            // Update save status
            document.getElementById('brain-save-status').textContent = 'Unsaved changes';
            document.getElementById('brain-save-status').style.color = 'var(--accent-yellow)';
            
            // Debounced auto-save
            clearTimeout(STATE.brainSaveTimeout);
            STATE.brainSaveTimeout = setTimeout(() => saveBrainFile(), 2000);
        }
        
        function updateBrainCursorPos() {
            const textarea = document.getElementById('brain-editor-textarea');
            if (!textarea) return;
            
            const text = textarea.value.substring(0, textarea.selectionStart);
            const lines = text.split('\n');
            const line = lines.length;
            const col = lines[lines.length - 1].length + 1;
            
            document.getElementById('brain-cursor-pos').textContent = `Ln ${line}, Col ${col}`;
        }
        
        function updateBrainStats(content) {
            const words = content.trim().split(/\s+/).filter(w => w.length > 0).length;
            const tags = (content.match(/#[a-zA-Z0-9_-]+/g) || []).length;
            
            const wordCount = document.getElementById('brain-word-count');
            const tagCount = document.getElementById('brain-tag-count');
            
            if (wordCount) wordCount.textContent = `${words} words`;
            if (tagCount) tagCount.textContent = `${tags} tags`;
        }
        
        async function saveBrainFile() {
            if (!STATE.brainActiveFile || !STATE.brainModifiedFiles[STATE.brainActiveFile]) return;
            
            const content = STATE.brainFileContents[STATE.brainActiveFile];
            const path = STATE.brainActiveFile;
            
            document.getElementById('brain-save-status').textContent = 'Saving...';
            
            try {
                // Get current SHA
                const fileData = await fetchGitHubFile(path);
                const sha = fileData ? fileData.sha : null;
                
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${path}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Update ${path} via Brain Tab`,
                            content: btoa(unescape(encodeURIComponent(content))),
                            sha: sha,
                            branch: CONFIG.branch
                        })
                    }
                );
                
                if (response.ok) {
                    STATE.brainModifiedFiles[path] = false;
                    document.getElementById('brain-save-status').textContent = 'Saved';
                    document.getElementById('brain-save-status').style.color = 'var(--accent-green)';
                    renderBrainEditorTabs();
                    renderMemoryFileTree();
                    
                    // Refresh changelog
                    loadBrainChangelog();
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Error saving file:', error);
                document.getElementById('brain-save-status').textContent = 'Save failed';
                document.getElementById('brain-save-status').style.color = 'var(--accent-red)';
                showToast('error', 'Failed to save file');
            }
        }
        
        function toggleBrainPreview() {
            STATE.brainPreviewMode = !STATE.brainPreviewMode;
            const btn = document.getElementById('brain-preview-toggle');
            btn.innerHTML = STATE.brainPreviewMode ? 'âœï¸ Edit' : 'ğŸ‘ï¸ Preview';
            renderBrainEditor();
        }
        
        // Editor toolbar functions
        function brainInsert(before, after) {
            const textarea = document.getElementById('brain-editor-textarea');
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            const selected = text.substring(start, end);
            
            textarea.value = text.substring(0, start) + before + selected + after + text.substring(end);
            textarea.selectionStart = start + before.length;
            textarea.selectionEnd = start + before.length + selected.length;
            textarea.focus();
            
            handleBrainEdit();
        }
        
        function brainInsertLine(prefix) {
            const textarea = document.getElementById('brain-editor-textarea');
            if (!textarea) return;
            
            const start = textarea.selectionStart;
            const text = textarea.value;
            
            // Find start of current line
            let lineStart = start;
            while (lineStart > 0 && text[lineStart - 1] !== '\n') {
                lineStart--;
            }
            
            textarea.value = text.substring(0, lineStart) + prefix + text.substring(lineStart);
            textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
            textarea.focus();
            
            handleBrainEdit();
        }
        
        function handleBrainSearch(query) {
            STATE.brainSearchQuery = query.toLowerCase();
            STATE.brainSearchResults = {};
            
            if (query.length >= 2) {
                // Search in cached file contents
                for (const [path, content] of Object.entries(STATE.brainFileContents)) {
                    const lowerContent = content.toLowerCase();
                    const lowerQuery = query.toLowerCase();
                    
                    if (lowerContent.includes(lowerQuery)) {
                        // Find context around matches
                        const lines = content.split('\n');
                        const matchLines = [];
                        
                        lines.forEach((line, i) => {
                            if (line.toLowerCase().includes(lowerQuery)) {
                                matchLines.push({
                                    line: i + 1,
                                    text: line.trim().substring(0, 80)
                                });
                            }
                        });
                        
                        STATE.brainSearchResults[path] = matchLines;
                    }
                }
            }
            
            renderMemoryFileTree();
        }
        
        async function loadAllMemoryContents() {
            // Pre-load all memory file contents for search
            const loadPromises = STATE.brainMemoryFiles.map(async (file) => {
                if (!STATE.brainFileContents[file.path]) {
                    try {
                        const fileData = await fetchGitHubFile(file.path);
                        if (fileData && fileData.content) {
                            STATE.brainFileContents[file.path] = atob(fileData.content);
                            extractTagsFromContent(STATE.brainFileContents[file.path]);
                        }
                    } catch (e) {
                        console.warn('Failed to load', file.path);
                    }
                }
            });
            
            await Promise.all(loadPromises);
            renderBrainTagCloud();
        }
        
        async function loadFileContent(path) {
            // Return from cache if available
            if (STATE.brainFileContents[path]) {
                return STATE.brainFileContents[path];
            }
            
            // Load from GitHub
            try {
                const fileData = await fetchGitHubFile(path);
                if (fileData && fileData.content) {
                    const content = atob(fileData.content);
                    STATE.brainFileContents[path] = content;
                    return content;
                }
            } catch (e) {
                console.warn('Failed to load', path);
            }
            
            return '';
        }
        
        // Changelog functions
        async function loadBrainChangelog() {
            if (!STATE.token) return;
            
            try {
                // Fetch commits for memory files
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/commits?path=memory&per_page=20`,
                    { headers: { 'Authorization': `token ${STATE.token}` } }
                );
                
                const commits = await response.json();
                
                // Also get MEMORY.md commits
                const memoryResponse = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/commits?path=MEMORY.md&per_page=10`,
                    { headers: { 'Authorization': `token ${STATE.token}` } }
                );
                
                const memoryCommits = await memoryResponse.json();
                
                // Merge and sort by date
                const allCommits = [...(commits || []), ...(memoryCommits || [])];
                allCommits.sort((a, b) => new Date(b.commit.author.date) - new Date(a.commit.author.date));
                
                // Dedupe by SHA
                const seen = new Set();
                STATE.brainChangelog = allCommits.filter(c => {
                    if (seen.has(c.sha)) return false;
                    seen.add(c.sha);
                    return true;
                }).slice(0, 20);
                
                renderBrainChangelog();
            } catch (error) {
                console.error('Error loading changelog:', error);
            }
        }
        
        function renderBrainChangelog() {
            const container = document.getElementById('brain-changelog-list');
            if (!container) return;
            
            if (STATE.brainChangelog.length === 0) {
                loadBrainChangelog();
                return;
            }
            
            container.innerHTML = STATE.brainChangelog.map(commit => {
                const date = new Date(commit.commit.author.date);
                const relativeTime = getRelativeTime(date);
                const author = commit.commit.author.name;
                const message = commit.commit.message.split('\n')[0];
                const isClawdbot = author.toLowerCase().includes('clawdbot') || author.toLowerCase().includes('jeannie');
                
                return `
                    <div class="brain-changelog-item" onclick="openDiffModal('${commit.sha}')" title="Click to view changes">
                        <div class="brain-changelog-item-header">
                            <span class="brain-changelog-author">${isClawdbot ? 'ğŸ¤–' : 'ğŸ‘¤'} ${escapeHtml(author)}</span>
                            <span class="brain-changelog-time">${relativeTime}</span>
                        </div>
                        <div class="brain-changelog-message">${escapeHtml(message)}</div>
                    </div>
                `;
            }).join('');
        }
        
        function getRelativeTime(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            if (days < 7) return `${days}d ago`;
            return date.toLocaleDateString('de-DE', { day: 'numeric', month: 'short' });
        }
        
        function toggleBrainChangelog() {
            const changelog = document.getElementById('brain-changelog');
            STATE.brainChangelogCollapsed = !STATE.brainChangelogCollapsed;
            changelog.classList.toggle('collapsed', STATE.brainChangelogCollapsed);
        }
        
        // Diff Modal functions
        async function openDiffModal(sha) {
            const modal = document.getElementById('brain-diff-modal');
            const titleEl = document.getElementById('brain-diff-title');
            const metaEl = document.getElementById('brain-diff-meta');
            const contentEl = document.getElementById('brain-diff-content');
            
            modal.classList.add('visible');
            contentEl.innerHTML = '<div class="brain-diff-loading">Loading diff...</div>';
            
            // Find commit info
            const commit = STATE.brainChangelog.find(c => c.sha === sha);
            if (commit) {
                const date = new Date(commit.commit.author.date);
                titleEl.textContent = commit.commit.message.split('\n')[0];
                metaEl.textContent = `${commit.commit.author.name} â€¢ ${date.toLocaleString('de-DE')} â€¢ ${sha.substring(0, 7)}`;
            }
            
            try {
                // Fetch commit details with diff
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/commits/${sha}`,
                    { headers: { 'Authorization': `token ${STATE.token}` } }
                );
                
                const commitData = await response.json();
                
                if (!commitData.files || commitData.files.length === 0) {
                    contentEl.innerHTML = '<div class="brain-diff-loading">No file changes in this commit.</div>';
                    return;
                }
                
                // Filter to memory-related files
                const memoryFiles = commitData.files.filter(f => 
                    f.filename.startsWith('memory/') || 
                    f.filename === 'MEMORY.md' ||
                    f.filename.endsWith('.md')
                );
                
                if (memoryFiles.length === 0) {
                    contentEl.innerHTML = '<div class="brain-diff-loading">No memory file changes in this commit.</div>';
                    return;
                }
                
                // Render diff for each file
                let html = '';
                for (const file of memoryFiles) {
                    html += renderFileDiff(file);
                }
                
                contentEl.innerHTML = html;
            } catch (error) {
                console.error('Error loading diff:', error);
                contentEl.innerHTML = '<div class="brain-diff-loading">Error loading diff. Please try again.</div>';
            }
        }
        
        function renderFileDiff(file) {
            const additions = file.additions || 0;
            const deletions = file.deletions || 0;
            const patch = file.patch || '';
            
            // Parse the patch into lines
            const lines = patch.split('\n');
            let lineHtml = '';
            let oldLine = 0;
            let newLine = 0;
            
            for (const line of lines) {
                let lineClass = '';
                let prefix = ' ';
                let lineNum = '';
                
                if (line.startsWith('@@')) {
                    // Hunk header - extract line numbers
                    lineClass = 'hunk';
                    prefix = '';
                    const match = line.match(/@@ -(\d+),?\d* \+(\d+),?\d* @@/);
                    if (match) {
                        oldLine = parseInt(match[1]) - 1;
                        newLine = parseInt(match[2]) - 1;
                    }
                    lineHtml += `<div class="brain-diff-line ${lineClass}"><div class="brain-diff-line-content">${escapeHtml(line)}</div></div>`;
                    continue;
                } else if (line.startsWith('+')) {
                    lineClass = 'add';
                    prefix = '+';
                    newLine++;
                    lineNum = newLine;
                } else if (line.startsWith('-')) {
                    lineClass = 'del';
                    prefix = '-';
                    oldLine++;
                    lineNum = oldLine;
                } else {
                    oldLine++;
                    newLine++;
                    lineNum = newLine;
                }
                
                lineHtml += `
                    <div class="brain-diff-line ${lineClass}">
                        <div class="brain-diff-line-num">${lineNum}</div>
                        <div class="brain-diff-line-prefix">${prefix}</div>
                        <div class="brain-diff-line-content">${escapeHtml(line.substring(1))}</div>
                    </div>
                `;
            }
            
            // File icon based on filename
            const icon = file.filename === 'MEMORY.md' ? 'ğŸ§ ' : 'ğŸ“„';
            
            return `
                <div class="brain-diff-file">
                    <div class="brain-diff-file-header">
                        <span>${icon} ${file.filename}</span>
                        <div class="brain-diff-stats">
                            <span class="brain-diff-stats-add">+${additions}</span>
                            <span class="brain-diff-stats-del">-${deletions}</span>
                        </div>
                    </div>
                    <div class="brain-diff-lines">
                        ${lineHtml || '<div class="brain-diff-line"><div class="brain-diff-line-content" style="color: var(--text-secondary); padding: 1rem;">Binary file or no changes</div></div>'}
                    </div>
                </div>
            `;
        }
        
        function closeDiffModal() {
            document.getElementById('brain-diff-modal').classList.remove('visible');
        }
        
        // Close diff modal on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const diffModal = document.getElementById('brain-diff-modal');
                if (diffModal && diffModal.classList.contains('visible')) {
                    closeDiffModal();
                }
            }
        });
        
        // Knowledge Builder functions
        function openKnowledgeBuilder() {
            document.getElementById('brain-knowledge-builder').classList.add('visible');
            document.getElementById('brain-kb-input').focus();
            
            // Update AI button status
            const settings = getAISettings();
            const aiBtn = document.getElementById('brain-kb-ai-btn');
            if (settings.provider === 'local' || !settings.apiKey) {
                aiBtn.title = 'Configure AI first (click âš™ï¸)';
                aiBtn.style.opacity = '0.6';
            } else {
                aiBtn.title = `Process with ${settings.provider === 'openrouter' ? 'OpenRouter' : 'OpenAI'}`;
                aiBtn.style.opacity = '1';
            }
        }
        
        function closeKnowledgeBuilder() {
            document.getElementById('brain-knowledge-builder').classList.remove('visible');
            document.getElementById('brain-kb-input').value = '';
            document.getElementById('brain-kb-result').style.display = 'none';
            document.getElementById('brain-kb-save').disabled = true;
        }
        
        // AI Settings functions
        function getAISettings() {
            return {
                provider: localStorage.getItem('brain-ai-provider') || 'local',
                apiKey: localStorage.getItem('brain-ai-key') || '',
                model: localStorage.getItem('brain-ai-model') || 'anthropic/claude-3.5-sonnet'
            };
        }
        
        function showAISettings() {
            const settings = getAISettings();
            document.getElementById('brain-ai-provider').value = settings.provider;
            document.getElementById('brain-ai-key').value = settings.apiKey;
            document.getElementById('brain-ai-model').value = settings.model;
            updateAIProviderUI();
            updateAIStatus();
            document.getElementById('brain-ai-settings').classList.add('visible');
        }
        
        function hideAISettings() {
            document.getElementById('brain-ai-settings').classList.remove('visible');
        }
        
        function updateAIProviderUI() {
            const provider = document.getElementById('brain-ai-provider').value;
            const keyField = document.getElementById('brain-ai-key-field');
            const modelField = document.getElementById('brain-ai-model-field');
            const hint = keyField.querySelector('.brain-ai-settings-hint');
            
            if (provider === 'local') {
                keyField.style.display = 'none';
                modelField.style.display = 'none';
            } else {
                keyField.style.display = 'block';
                modelField.style.display = 'block';
                if (provider === 'openrouter') {
                    hint.innerHTML = 'Get your key from <a href="https://openrouter.ai/keys" target="_blank" style="color: var(--accent-blue);">openrouter.ai/keys</a>';
                } else {
                    hint.innerHTML = 'Get your key from <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--accent-blue);">platform.openai.com</a>';
                }
            }
        }
        
        function updateAIStatus() {
            const settings = getAISettings();
            const statusEl = document.getElementById('brain-ai-status');
            const textEl = document.getElementById('brain-ai-status-text');
            
            if (settings.provider === 'local') {
                statusEl.className = 'brain-ai-status disconnected';
                textEl.textContent = 'Local processing only (no AI)';
            } else if (settings.apiKey) {
                statusEl.className = 'brain-ai-status connected';
                textEl.textContent = `Connected to ${settings.provider === 'openrouter' ? 'OpenRouter' : 'OpenAI'}`;
            } else {
                statusEl.className = 'brain-ai-status disconnected';
                textEl.textContent = 'API key not configured';
            }
        }
        
        function saveAISettings() {
            const provider = document.getElementById('brain-ai-provider').value;
            const apiKey = document.getElementById('brain-ai-key').value.trim();
            const model = document.getElementById('brain-ai-model').value;
            
            localStorage.setItem('brain-ai-provider', provider);
            localStorage.setItem('brain-ai-key', apiKey);
            localStorage.setItem('brain-ai-model', model);
            
            hideAISettings();
            showToast('success', 'AI settings saved');
        }
        
        async function callAI(prompt) {
            const settings = getAISettings();
            
            if (settings.provider === 'local' || !settings.apiKey) {
                throw new Error('AI not configured');
            }
            
            const baseUrl = settings.provider === 'openrouter' 
                ? 'https://openrouter.ai/api/v1' 
                : 'https://api.openai.com/v1';
            
            const response = await fetch(`${baseUrl}/chat/completions`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${settings.apiKey}`,
                    'Content-Type': 'application/json',
                    ...(settings.provider === 'openrouter' && {
                        'HTTP-Referer': window.location.origin,
                        'X-Title': 'Mission Control Brain'
                    })
                },
                body: JSON.stringify({
                    model: settings.provider === 'openrouter' ? settings.model : settings.model.replace('openai/', ''),
                    messages: [{ role: 'user', content: prompt }],
                    max_tokens: 2000,
                    temperature: 0.7
                })
            });
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices[0].message.content;
        }
        
        async function processKnowledge(action) {
            const input = document.getElementById('brain-kb-input').value.trim();
            if (!input) {
                showToast('error', 'Please enter some information first');
                return;
            }
            
            const resultContainer = document.getElementById('brain-kb-result');
            const resultContent = document.getElementById('brain-kb-result-content');
            
            resultContainer.style.display = 'block';
            
            let result = '';
            
            // AI processing
            if (action === 'ai') {
                const settings = getAISettings();
                
                if (settings.provider === 'local' || !settings.apiKey) {
                    showToast('error', 'Configure AI in settings first (click âš™ï¸)');
                    resultContent.innerHTML = '<div style="color: var(--accent-yellow);">âš ï¸ AI not configured. Click âš™ï¸ to add your API key.</div>';
                    return;
                }
                
                resultContent.innerHTML = '<div class="brain-kb-loading">Processing with AI...</div>';
                
                try {
                    const prompt = `You are a memory formatting assistant. Convert the following information into a clean, well-structured memory entry for an AI assistant's knowledge base.

Rules:
- Use markdown formatting
- Start with a descriptive ## heading based on the content
- Extract key facts as bullet points
- Add relevant hashtags at the end (e.g. #account #credentials #process)
- Be concise but preserve all important details
- If it contains credentials or sensitive info, note it clearly
- Use the current date: ${new Date().toISOString().split('T')[0]}

Input:
${input}

Output the formatted memory entry:`;

                    result = await callAI(prompt);
                    showToast('success', 'AI processing complete');
                } catch (error) {
                    console.error('AI error:', error);
                    showToast('error', `AI error: ${error.message}`);
                    resultContent.innerHTML = `<div style="color: var(--accent-red);">âŒ ${escapeHtml(error.message)}</div>`;
                    return;
                }
            }
            // Local processing (fallback/quick options)
            else if (action === 'format') {
                resultContent.innerHTML = '<div style="color: var(--text-secondary);">Formatting...</div>';
                const now = new Date();
                const timestamp = now.toISOString().split('T')[0];
                
                // Smart formatting - detect content type
                const lines = input.split('\n').filter(l => l.trim());
                const hasMultipleLines = lines.length > 1;
                const looksLikeList = lines.some(l => /^[-*â€¢]/.test(l.trim()) || /^\d+[.)]/.test(l.trim()));
                
                if (looksLikeList || hasMultipleLines) {
                    // Format as structured list
                    const formatted = lines.map(l => {
                        const cleaned = l.trim().replace(/^[-*â€¢]\s*/, '').replace(/^\d+[.)]\s*/, '');
                        return `- ${cleaned}`;
                    }).join('\n');
                    result = `## Notes from ${timestamp}\n\n${formatted}\n`;
                } else {
                    // Single item - try to create a heading from first words
                    const words = input.split(' ').slice(0, 4).join(' ');
                    const heading = words.length > 30 ? words.substring(0, 30) + '...' : words;
                    result = `## ${heading}\n\n${input}\n`;
                }
            } else if (action === 'extract') {
                resultContent.innerHTML = '<div style="color: var(--text-secondary);">Extracting facts...</div>';
                // Smarter extraction - handle different formats
                let facts = [];
                
                // Try to extract from sentences
                const sentences = input.split(/[.!?]+/).filter(s => s.trim().length > 5);
                facts = sentences.map(s => {
                    const trimmed = s.trim();
                    // Capitalize first letter
                    return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
                });
                
                // Also extract key-value pairs (e.g., "email: test@test.com")
                const keyValues = input.match(/\b(\w+)\s*[:=]\s*([^\n,]+)/g);
                if (keyValues) {
                    const kvFacts = keyValues.map(kv => `**${kv.trim()}**`);
                    facts = [...new Set([...kvFacts, ...facts])];
                }
                
                result = facts.map(f => `- ${f}`).join('\n');
            } else if (action === 'tags') {
                resultContent.innerHTML = '<div style="color: var(--text-secondary);">Analyzing tags...</div>';
                // Smarter tag extraction
                const text = input.toLowerCase();
                const tagSuggestions = new Set();
                
                // Common categories
                const categories = {
                    account: ['account', 'login', 'password', 'credential', 'email', 'username', 'auth'],
                    process: ['step', 'how to', 'process', 'workflow', 'procedure', 'guide'],
                    contact: ['phone', 'email', 'address', 'contact', 'person', 'name'],
                    finance: ['invoice', 'payment', 'price', 'cost', 'budget', 'expense', 'billing'],
                    project: ['project', 'task', 'deadline', 'milestone', 'sprint', 'feature'],
                    tool: ['api', 'tool', 'software', 'app', 'service', 'platform'],
                    meeting: ['meeting', 'call', 'zoom', 'schedule', 'appointment']
                };
                
                for (const [tag, keywords] of Object.entries(categories)) {
                    if (keywords.some(kw => text.includes(kw))) {
                        tagSuggestions.add(tag);
                    }
                }
                
                // Extract potential proper nouns / names
                const properNouns = input.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || [];
                properNouns.slice(0, 3).forEach(noun => {
                    tagSuggestions.add(noun.toLowerCase().replace(/\s+/g, '-'));
                });
                
                // Frequency-based tags for remaining
                const words = text.match(/\b[a-z]{4,}\b/g) || [];
                const stopWords = new Set(['this', 'that', 'with', 'from', 'have', 'been', 'will', 'would', 'could', 'should', 'about', 'which', 'their', 'there', 'where', 'when', 'what', 'some', 'more', 'into', 'also', 'just', 'only', 'than', 'then', 'very', 'after', 'before']);
                const wordFreq = {};
                words.forEach(w => {
                    if (!stopWords.has(w)) {
                        wordFreq[w] = (wordFreq[w] || 0) + 1;
                    }
                });
                Object.entries(wordFreq)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .forEach(([w]) => tagSuggestions.add(w));
                
                const tags = Array.from(tagSuggestions).slice(0, 7).map(t => `#${t}`);
                result = `Suggested tags:\n\n${tags.join(' ')}`;
            }
            
            resultContent.innerHTML = `<pre style="white-space: pre-wrap; font-family: inherit;">${escapeHtml(result)}</pre>`;
            STATE.brainKBResult = result;
            document.getElementById('brain-kb-save').disabled = false;
        }
        
        async function saveKnowledge() {
            const result = STATE.brainKBResult;
            if (!result) return;
            
            const target = document.getElementById('brain-kb-target').value;
            let targetPath;
            
            if (target === 'today') {
                const today = new Date().toISOString().split('T')[0];
                targetPath = `memory/${today}.md`;
            } else {
                targetPath = 'MEMORY.md';
            }
            
            try {
                // Get existing content or create new
                let existingContent = '';
                let sha = null;
                
                try {
                    const fileData = await fetchGitHubFile(targetPath);
                    if (fileData && fileData.content) {
                        existingContent = atob(fileData.content);
                        sha = fileData.sha;
                    }
                } catch (e) {
                    // File doesn't exist, will create new
                }
                
                // Append new content
                const newContent = existingContent + '\n' + result + '\n';
                
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${targetPath}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Add knowledge via Brain Tab`,
                            content: btoa(unescape(encodeURIComponent(newContent))),
                            sha: sha,
                            branch: CONFIG.branch
                        })
                    }
                );
                
                if (response.ok) {
                    showToast('success', `Knowledge saved to ${targetPath}`);
                    closeKnowledgeBuilder();
                    
                    // Refresh files
                    STATE.brainMemoryFiles = [];
                    STATE.brainFileContents = {};
                    await loadMemoryFiles();
                    renderMemoryFileTree();
                    openMemoryFile(targetPath);
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Error saving knowledge:', error);
                showToast('error', 'Failed to save knowledge');
            }
        }
        
        function showBrainEmpty(message) {
            const container = document.getElementById('brain-file-tree');
            if (container) {
                container.innerHTML = `
                    <div class="brain-empty">
                        <div class="brain-empty-icon">ğŸ”’</div>
                        <div class="brain-empty-title">Connect Required</div>
                        <div class="brain-empty-text">${escapeHtml(message)}</div>
                    </div>
                `;
            }
        }
        
        // =====================================================
        // MEMORY MERGE FUNCTIONS
        // =====================================================
        
        STATE.brainMergeSelected = new Set();
        
        function openMemoryMerge() {
            const modal = document.getElementById('brain-merge-modal');
            const filesContainer = document.getElementById('brain-merge-files');
            
            // Only show daily files (not MEMORY.md)
            const dailyFiles = STATE.brainMemoryFiles.filter(f => f.type === 'daily');
            
            if (dailyFiles.length === 0) {
                showToast('info', 'No daily notes to merge');
                return;
            }
            
            // Render file checkboxes
            let html = '';
            dailyFiles.forEach(file => {
                const displayDate = formatMergeFileDate(file.name);
                const wordCount = getFileWordCount(file.path);
                html += `
                    <label class="brain-merge-file" onclick="toggleMergeFile('${file.path}')">
                        <input type="checkbox" id="merge-${file.path}" onchange="updateMergeSelection()">
                        <div class="brain-merge-file-info">
                            <div class="brain-merge-file-name">ğŸ“… ${displayDate}</div>
                            <div class="brain-merge-file-meta">${file.name} â€¢ ${wordCount} words</div>
                        </div>
                    </label>
                `;
            });
            
            filesContainer.innerHTML = html;
            STATE.brainMergeSelected.clear();
            document.getElementById('brain-merge-preview').style.display = 'none';
            document.getElementById('brain-merge-execute').disabled = true;
            
            modal.classList.add('visible');
        }
        
        function closeMemoryMerge() {
            document.getElementById('brain-merge-modal').classList.remove('visible');
            STATE.brainMergeSelected.clear();
        }
        
        function toggleMergeFile(path) {
            const checkbox = document.getElementById(`merge-${path}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                updateMergeSelection();
            }
        }
        
        function updateMergeSelection() {
            STATE.brainMergeSelected.clear();
            const checkboxes = document.querySelectorAll('.brain-merge-files input[type="checkbox"]:checked');
            checkboxes.forEach(cb => {
                const path = cb.id.replace('merge-', '');
                STATE.brainMergeSelected.add(path);
            });
            
            const executeBtn = document.getElementById('brain-merge-execute');
            executeBtn.disabled = STATE.brainMergeSelected.size === 0;
            executeBtn.textContent = STATE.brainMergeSelected.size > 0 
                ? `Merge ${STATE.brainMergeSelected.size} file${STATE.brainMergeSelected.size > 1 ? 's' : ''}`
                : 'Merge Selected';
        }
        
        function formatMergeFileDate(filename) {
            const match = filename.match(/(\d{4}-\d{2}-\d{2})/);
            if (!match) return filename;
            
            const date = new Date(match[1]);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            if (match[1] === today.toISOString().split('T')[0]) {
                return 'Today';
            } else if (match[1] === yesterday.toISOString().split('T')[0]) {
                return 'Yesterday';
            } else {
                return date.toLocaleDateString('de-DE', { 
                    weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' 
                });
            }
        }
        
        function getFileWordCount(path) {
            const content = STATE.brainFileContents[path] || '';
            return content.split(/\s+/).filter(w => w.length > 0).length;
        }
        
        async function previewMerge() {
            if (STATE.brainMergeSelected.size === 0) return;
            
            const previewDiv = document.getElementById('brain-merge-preview');
            const previewContent = document.getElementById('brain-merge-preview-content');
            const useAI = document.getElementById('brain-merge-ai').checked;
            
            previewDiv.style.display = 'block';
            previewContent.innerHTML = '<div style="color: var(--text-secondary);">Generating preview...</div>';
            
            try {
                // Collect all content
                const contents = [];
                for (const path of STATE.brainMergeSelected) {
                    const content = STATE.brainFileContents[path] || await loadFileContent(path);
                    const date = path.match(/(\d{4}-\d{2}-\d{2})/)?.[1] || 'Unknown';
                    contents.push({ path, date, content });
                }
                
                // Sort by date descending
                contents.sort((a, b) => b.date.localeCompare(a.date));
                
                let mergedContent;
                
                const aiSettings = getAISettings();
                if (useAI && aiSettings.provider !== 'local' && aiSettings.apiKey) {
                    // Use AI for smart merge
                    mergedContent = await aiMergeContent(contents);
                } else {
                    // Simple concatenation with headers
                    mergedContent = simpleMergeContent(contents);
                }
                
                previewContent.textContent = mergedContent;
                STATE.brainMergePreview = mergedContent;
                
            } catch (error) {
                console.error('Preview error:', error);
                previewContent.innerHTML = `<div style="color: var(--accent-red);">Error: ${escapeHtml(error.message)}</div>`;
            }
        }
        
        function simpleMergeContent(contents) {
            let result = `## Merged Notes\n\n_Merged on ${new Date().toISOString().split('T')[0]}_\n\n---\n\n`;
            
            for (const { date, content } of contents) {
                result += `### From ${date}\n\n${content}\n\n---\n\n`;
            }
            
            return result.trim();
        }
        
        async function aiMergeContent(contents) {
            const allContent = contents.map(c => `=== ${c.date} ===\n${c.content}`).join('\n\n');
            
            const prompt = `You are consolidating daily notes into long-term memory. 

Analyze these daily notes and create a clean, deduplicated summary:
- Remove redundant information
- Group related topics together
- Preserve important facts, decisions, and learnings
- Keep the format clean with headers and bullet points
- Remove date-specific details that are no longer relevant
- Keep actionable items and important context

Daily notes to merge:

${allContent}

Output the consolidated content in clean Markdown format:`;

            try {
                const response = await callAI(prompt);
                return response || simpleMergeContent(contents);
            } catch (e) {
                console.error('AI merge failed:', e);
                return simpleMergeContent(contents);
            }
        }
        
        async function executeMerge() {
            if (STATE.brainMergeSelected.size === 0) return;
            
            // Generate preview if not already done
            if (!STATE.brainMergePreview) {
                await previewMerge();
            }
            
            if (!STATE.brainMergePreview) {
                showToast('error', 'Failed to generate merge content');
                return;
            }
            
            const executeBtn = document.getElementById('brain-merge-execute');
            executeBtn.disabled = true;
            executeBtn.textContent = 'Merging...';
            
            try {
                // Load existing MEMORY.md
                let existingMemory = '';
                try {
                    const memoryFile = await fetchGitHubFile('MEMORY.md');
                    if (memoryFile && memoryFile.content) {
                        existingMemory = atob(memoryFile.content);
                    }
                } catch (e) {
                    console.log('No existing MEMORY.md');
                }
                
                // Append merged content
                const newContent = existingMemory 
                    ? `${existingMemory}\n\n---\n\n${STATE.brainMergePreview}`
                    : STATE.brainMergePreview;
                
                // Save to MEMORY.md
                await saveFileToGitHub('MEMORY.md', newContent, 'Merge daily notes to long-term memory');
                
                // Archive merged files if option is checked
                const shouldArchive = document.getElementById('brain-merge-archive').checked;
                if (shouldArchive) {
                    for (const path of STATE.brainMergeSelected) {
                        // Rename by adding .merged suffix (or delete)
                        const content = STATE.brainFileContents[path] || '';
                        const newPath = path.replace('.md', '.merged.md');
                        
                        // Save with .merged suffix
                        await saveFileToGitHub(newPath, content, `Archive merged file: ${path}`);
                        
                        // Delete original
                        await deleteGitHubFile(path, `Delete after merge: ${path}`);
                    }
                }
                
                showToast('success', `Merged ${STATE.brainMergeSelected.size} files to MEMORY.md`);
                closeMemoryMerge();
                
                // Refresh the file list
                STATE.brainMemoryFiles = [];
                STATE.brainFileContents = {};
                STATE.brainContentsLoaded = false;
                await loadMemoryFiles();
                await loadAllMemoryContents();
                renderMemoryFileTree();
                
                // Open MEMORY.md
                openMemoryFile('MEMORY.md');
                
            } catch (error) {
                console.error('Merge error:', error);
                showToast('error', `Merge failed: ${error.message}`);
            } finally {
                executeBtn.disabled = false;
                executeBtn.textContent = 'Merge Selected';
            }
        }
        
        async function saveFileToGitHub(path, content, message) {
            if (!STATE.token) {
                throw new Error('Not logged in');
            }
            
            // Get existing file SHA if it exists
            let sha = null;
            try {
                const existingFile = await fetchGitHubFile(path);
                if (existingFile && existingFile.sha) {
                    sha = existingFile.sha;
                }
            } catch (e) {
                // File doesn't exist, that's OK
            }
            
            const encodedContent = btoa(unescape(encodeURIComponent(content)));
            
            const body = {
                message: message || `Update ${path}`,
                content: encodedContent,
                branch: CONFIG.branch
            };
            
            if (sha) {
                body.sha = sha;
            }
            
            const response = await fetch(
                `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${path}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${STATE.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                }
            );
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Save failed');
            }
            
            return await response.json();
        }
        
        async function deleteGitHubFile(path, message) {
            // Get file SHA first
            const file = await fetchGitHubFile(path);
            if (!file || !file.sha) {
                throw new Error(`File not found: ${path}`);
            }
            
            const response = await fetch(
                `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${path}`,
                {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `token ${STATE.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: message || `Delete ${path}`,
                        sha: file.sha,
                        branch: CONFIG.branch
                    })
                }
            );
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Delete failed');
            }
            
            return true;
        }

        // === AUTH FUNCTIONS ===
        function showAuthModal() {
            document.getElementById('auth-modal').classList.add('visible');
            document.getElementById('token-input').focus();
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.remove('visible');
            document.getElementById('token-input').value = '';
            hideValidationStates();
        }

        function hideValidationStates() {
            document.getElementById('validation-loading').classList.remove('visible');
            document.getElementById('validation-success').classList.remove('visible');
            document.getElementById('validation-error').classList.remove('visible');
        }

        async function validateAndSaveToken() {
            const token = document.getElementById('token-input').value.trim();

            if (!token) {
                showValidationError('Please enter a token');
                return;
            }

            hideValidationStates();
            document.getElementById('validation-loading').classList.add('visible');
            document.getElementById('btn-save-token').disabled = true;

            try {
                // Validate token by fetching user info
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Invalid token');
                }

                const user = await response.json();

                // Check repo access
                const repoResponse = await fetch(`https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (!repoResponse.ok) {
                    throw new Error('No access to repository. Make sure you have "repo" scope.');
                }

                // Success!
                document.getElementById('validation-loading').classList.remove('visible');
                document.getElementById('validation-success').classList.add('visible');
                document.getElementById('validated-user').textContent = user.login;

                // Save to localStorage
                localStorage.setItem('github_token', token);
                localStorage.setItem('github_user', JSON.stringify({
                    login: user.login,
                    avatar_url: user.avatar_url,
                    name: user.name || user.login
                }));

                STATE.token = token;
                STATE.user = user;

                // Update UI and load data
                setTimeout(async () => {
                    hideAuthModal();
                    updateAuthUI();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub();
                    await loadSkillsFromGitHub();
                }, 1000);

            } catch (error) {
                showValidationError(error.message);
            }
        }

        function showValidationError(message) {
            document.getElementById('validation-loading').classList.remove('visible');
            document.getElementById('validation-error').classList.add('visible');
            document.getElementById('error-message').textContent = message;
            document.getElementById('btn-save-token').disabled = false;
        }

        function logout() {
            localStorage.removeItem('github_token');
            localStorage.removeItem('github_user');
            STATE.token = null;
            STATE.user = null;
            STATE.data = JSON.parse(JSON.stringify(FALLBACK_DATA));
            STATE.hasUnsavedChanges = false;
            document.getElementById('unsaved-banner').classList.remove('visible');
            updateAuthUI();
            renderAll();
            showToast('success', 'Logged out');
        }

        function updateAuthUI() {
            const connectBtn = document.getElementById('btn-connect');
            const userProfile = document.getElementById('user-profile');

            if (STATE.user) {
                connectBtn.style.display = 'none';
                userProfile.style.display = 'flex';
                document.getElementById('user-avatar').src = STATE.user.avatar_url;
                document.getElementById('user-name').textContent = STATE.user.name || STATE.user.login;
            } else {
                connectBtn.style.display = 'inline-flex';
                userProfile.style.display = 'none';
            }
        }

        function checkSavedAuth() {
            const token = localStorage.getItem('github_token');
            const userJson = localStorage.getItem('github_user');

            if (token && userJson) {
                STATE.token = token;
                STATE.user = JSON.parse(userJson);
                updateAuthUI();
            }
        }

        // === TOKEN INPUT HANDLING ===
        document.getElementById('token-input').addEventListener('input', function() {
            const value = this.value.trim();
            document.getElementById('btn-save-token').disabled = !value;
            hideValidationStates();
        });

        document.getElementById('token-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                validateAndSaveToken();
            }
        });

        // === TOAST NOTIFICATIONS ===
        function showToast(type, message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${type === 'success' ? 'âœ“' : 'âœ—'}</span>
                <span>${message}</span>
            `;
            container.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // === MARKDOWN RENDERER ===
        function renderMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML first to prevent XSS
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Bold: **text** or __text__
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            
            // Italic: *text* or _text_ (but not inside words)
            html = html.replace(/(?<!\w)\*(?!\*)(.+?)(?<!\*)\*(?!\w)/g, '<em>$1</em>');
            html = html.replace(/(?<!\w)_(?!_)(.+?)(?<!_)_(?!\w)/g, '<em>$1</em>');
            
            // Inline code: `code`
            html = html.replace(/`([^`]+)`/g, '<code style="background: var(--bg-secondary); padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">$1</code>');
            
            // Links: [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: var(--accent-blue);">$1</a>');
            
            // URLs without markdown (auto-link)
            html = html.replace(/(^|[^"=])(https?:\/\/[^\s<]+)/g, '$1<a href="$2" target="_blank" style="color: var(--accent-blue);">$2</a>');
            
            // Checkboxes: âœ… and â˜‘ï¸ (already rendered, just style them)
            // Keep emojis as-is
            
            // Tables: | col | col |
            if (html.includes('|') && html.split('\n').some(line => line.trim().startsWith('|'))) {
                const lines = html.split('\n');
                let inTable = false;
                let tableHtml = '';
                const result = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
                        if (!inTable) {
                            inTable = true;
                            tableHtml = '<table style="border-collapse: collapse; margin: 8px 0; font-size: 0.85em; width: 100%;">';
                        }
                        // Skip separator rows (|---|---|)
                        if (trimmed.match(/^\|[\s\-:]+\|$/)) continue;
                        
                        const cells = trimmed.slice(1, -1).split('|').map(c => c.trim());
                        const isHeader = !tableHtml.includes('<tr>');
                        const cellTag = isHeader ? 'th' : 'td';
                        const cellStyle = isHeader 
                            ? 'style="border: 1px solid var(--border); padding: 6px 10px; background: var(--bg-secondary); text-align: left;"'
                            : 'style="border: 1px solid var(--border); padding: 6px 10px;"';
                        tableHtml += `<tr>${cells.map(c => `<${cellTag} ${cellStyle}>${c}</${cellTag}>`).join('')}</tr>`;
                    } else {
                        if (inTable) {
                            inTable = false;
                            tableHtml += '</table>';
                            result.push(tableHtml);
                            tableHtml = '';
                        }
                        result.push(line);
                    }
                }
                if (inTable) {
                    tableHtml += '</table>';
                    result.push(tableHtml);
                }
                html = result.join('\n');
            }
            
            // Line breaks
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }

        // === RENDER FUNCTIONS ===
        function renderTasks(animate = false) {
            const columns = ['backlog', 'in_progress', 'review', 'done'];
            const data = STATE.data || FALLBACK_DATA;
            const priorityOrder = { high: 0, medium: 1, low: 2 };

            // FLIP Animation: Capture old positions
            const oldPositions = {};
            if (animate) {
                document.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId) {
                        oldPositions[taskId] = card.getBoundingClientRect();
                    }
                });
            }

            columns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                let tasks = data.tasks.filter(t => t.status === status && !t.isTemplate && t.status !== 'scheduled');

                // Filter out archived tasks (unless searching with archive enabled)
                if (!(showArchivedInSearch && searchQuery)) {
                    tasks = tasks.filter(t => !t.archived);
                }

                // Apply project filter
                if (currentFilter !== 'all') {
                    tasks = tasks.filter(t => t.project === currentFilter || (t.tags && t.tags.includes(currentFilter)));
                }

                // Auto-Sort: By last activity (newest first), with priority as tiebreaker
                // Uses: lastExecutedAt > updatedAt > createdAt as timestamp
                function getLastActivityTime(task) {
                    if (task.lastExecutedAt) return new Date(task.lastExecutedAt).getTime();
                    if (task.updatedAt) return new Date(task.updatedAt).getTime();
                    if (task.createdAt) return new Date(task.createdAt).getTime();
                    return 0;
                }
                
                if (status === 'done') {
                    // Done: newest completed tasks first
                    tasks.sort((a, b) => {
                        const dateA = a.completedAt ? new Date(a.completedAt).getTime() : 0;
                        const dateB = b.completedAt ? new Date(b.completedAt).getTime() : 0;
                        return dateB - dateA; // Descending (newest first)
                    });
                } else {
                    // Other columns: priority first, then by last activity (newest first)
                    tasks.sort((a, b) => {
                        const prioA = priorityOrder[a.priority] ?? 1;
                        const prioB = priorityOrder[b.priority] ?? 1;
                        if (prioA !== prioB) return prioA - prioB;
                        // Sort by last activity (newest first)
                        const timeA = getLastActivityTime(a);
                        const timeB = getLastActivityTime(b);
                        return timeB - timeA; // Descending
                    });
                }

                const count = document.getElementById(`count-${status}`);
                count.textContent = tasks.length;
                container.innerHTML = tasks.length === 0
                    ? '<div class="empty-state">No tasks</div>'
                    : tasks.map(renderTaskCard).join('');
            });

            // FLIP Animation: Animate from old to new positions
            if (animate && Object.keys(oldPositions).length > 0) {
                document.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId && oldPositions[taskId]) {
                        const oldPos = oldPositions[taskId];
                        const newPos = card.getBoundingClientRect();
                        const deltaY = oldPos.top - newPos.top;

                        if (Math.abs(deltaY) > 5) {
                            card.style.transform = `translateY(${deltaY}px)`;
                            card.style.transition = 'none';

                            requestAnimationFrame(() => {
                                card.style.transition = 'transform 0.4s cubic-bezier(0.2, 0, 0.2, 1)';
                                card.style.transform = 'translateY(0)';
                            });
                        }
                    }
                });
            }

            updateStats();
            
            // Re-apply search filter after rendering
            if (searchQuery) {
                applySearchFilter();
            }
        }

        function renderTaskCard(task) {
            const subtasks = task.subtasks || [];
            const subtasksDone = subtasks.filter(s => s.done).length;
            const subtasksTotal = subtasks.length;
            const progress = subtasksTotal > 0 ? Math.round((subtasksDone / subtasksTotal) * 100) : 0;
            const commentsCount = (task.comments || []).length;
            const isArchived = task.archived === true;

            // Review actions
            const reviewActions = task.status === 'review' ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn done" onclick="quickMoveTask('${task.id}', 'done')" title="Mark as Done">âœ“ Done</button>
                    <button class="task-action-btn backlog" onclick="quickMoveTask('${task.id}', 'backlog')" title="Move to Backlog">â†© Backlog</button>
                </div>
            ` : '';

            // Archive/Unarchive actions for done tasks
            const archiveActions = task.status === 'done' && !isArchived ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn archive" onclick="archiveTask('${task.id}')" title="Archive this task">ğŸ“¦ Archive</button>
                </div>
            ` : '';

            // Unarchive button for archived tasks
            const unarchiveActions = isArchived ? `
                <div class="task-actions" onclick="event.stopPropagation()">
                    <button class="task-action-btn unarchive" onclick="unarchiveTask('${task.id}')" title="Restore from archive">ğŸ“¤ Unarchive</button>
                </div>
            ` : '';

            // Archived badge
            const archivedBadge = isArchived ? `
                <span class="archived-badge">ğŸ“¦ Archived</span>
            ` : '';

            // Comment indicator
            const commentIndicator = commentsCount > 0 ? `
                <div class="task-comment-indicator" title="${commentsCount} comment${commentsCount > 1 ? 's' : ''}">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <span>${commentsCount}</span>
                </div>
            ` : '';
            
            // Processing indicator with timeout warning
            // ENHANCED: Show live status for ALL "In Progress" tasks
            const isInProgress = task.status === 'in_progress';
            const hasExplicitProcessing = task.processingStartedAt || task.processing;
            
            // Get the latest comment for live status display
            const latestComment = (task.comments || []).slice(-1)[0];
            const hasRecentActivity = latestComment && (Date.now() - new Date(latestComment.createdAt).getTime() < 30 * 60 * 1000); // 30 min
            
            // Show processing state for ALL in_progress tasks with recent activity
            const isProcessing = isInProgress && (hasExplicitProcessing || hasRecentActivity || task.comments?.length > 0);
            let processingIndicator = '';
            let processingClass = '';
            let liveStatusBanner = '';
            
            if (isInProgress) {
                // Always show live status for in_progress tasks
                if (hasExplicitProcessing && task.processingStartedAt) {
                    const startedAt = new Date(task.processingStartedAt);
                    const now = new Date();
                    const minutesElapsed = Math.floor((now - startedAt) / 60000);
                    const isTimeout = minutesElapsed >= 30;
                    
                    processingClass = isTimeout ? ' processing-timeout' : ' processing';
                    const timeText = minutesElapsed < 1 ? 'gerade gestartet' : 
                                     minutesElapsed === 1 ? '1 Min' : `${minutesElapsed} Min`;
                    
                    processingIndicator = `
                        <div class="processing-indicator${isTimeout ? ' timeout' : ''}" title="${task.isTemporary ? 'Cron job executing...' : 'Agent arbeitet an diesem Task...'}">
                            <div class="spinner"></div>
                            <span>${isTimeout ? 'âš ï¸ ' : ''}In Bearbeitung seit <span class="processing-time${isTimeout ? ' timeout' : ''}" data-started-at="${task.processingStartedAt}">${timeText}</span></span>
                        </div>
                    `;
                } else if (hasRecentActivity) {
                    // Show recent activity as processing
                    processingClass = ' processing';
                    const minutesAgo = Math.floor((Date.now() - new Date(latestComment.createdAt).getTime()) / 60000);
                    const timeText = minutesAgo < 1 ? 'gerade eben' : minutesAgo === 1 ? 'vor 1 Min' : `vor ${minutesAgo} Min`;
                    processingIndicator = `
                        <div class="processing-indicator" title="Letzte AktivitÃ¤t: ${timeText}">
                            <div class="spinner"></div>
                            <span>Aktiv (${timeText})</span>
                        </div>
                    `;
                } else {
                    // No recent activity but still in progress - waiting state
                    processingClass = ' processing-waiting';
                }
                
                // Live status banner showing latest comment preview
                if (latestComment) {
                    const commentText = latestComment.content || latestComment.text || '';
                    const preview = commentText.length > 80 ? commentText.substring(0, 80) + '...' : commentText;
                    const author = latestComment.author || 'Agent';
                    liveStatusBanner = `
                        <div class="live-status-banner" title="Letzter Status von ${author}">
                            <span class="live-status-author">${author}:</span>
                            <span class="live-status-text">${escapeHtml(preview)}</span>
                        </div>
                    `;
                }
            }
            // Note: Processing indicator only shown for in_progress tasks with live status
            // Tasks in review/done should NOT show processing indicator even if processingStartedAt exists

            return `
                <div class="task-card priority-${task.priority}${isArchived ? ' archived' : ''}${processingClass}" data-task-id="${task.id}"
                     draggable="${!isArchived}"
                     ondragstart="handleDragStart(event, '${task.id}')"
                     ondragend="handleDragEnd(event)"
                     onclick="openTaskDetail('${task.id}')">
                    <div class="task-title">
                        <span class="task-title-text">${task.title}</span>
                        ${archivedBadge}
                    </div>
                    ${processingIndicator}
                    ${liveStatusBanner}
                    <div class="task-description">${task.description}</div>
                    <div class="task-meta">
                        <div class="task-tags">
                            ${task.tags.map(tag => `<span class="task-tag ${tag}">${tag}</span>`).join('')}
                        </div>
                        ${commentIndicator}
                    </div>
                    ${subtasksTotal > 0 ? `
                        <div class="task-subtasks">
                            <div class="subtask-progress">
                                <span>${subtasksDone}/${subtasksTotal}</span>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${progress}%"></div>
                                </div>
                                <span>${progress}%</span>
                            </div>
                        </div>
                    ` : ''}
                    ${reviewActions}
                    ${archiveActions}
                    ${unarchiveActions}
                    ${task.status === 'in_progress' && commentsCount > 0 ? `
                        <div class="thinking-section" onclick="event.stopPropagation()">
                            <button class="thinking-toggle" onclick="toggleThinkingPanel('${task.id}')">
                                ğŸ’­ Activity Log <span class="thinking-badge">${hasRecentActivity ? 'Live' : commentsCount}</span>
                            </button>
                            <div class="thinking-panel" id="thinking-panel-${task.id}" style="display: ${hasRecentActivity ? 'block' : 'none'};">
                                <div class="thinking-panel-header">
                                    ğŸ’­ Agent Activity Stream
                                </div>
                                <div id="thinking-content-${task.id}">
                                    ${renderActivityLog(task.comments || [], 'thinking-panel-' + task.id)}
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        function toggleThinkingPanel(taskId) {
            const panel = document.getElementById(`thinking-panel-${taskId}`);
            if (!panel) return;
            
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Start polling when panel is opened
                startThinkingPolling(taskId);
            } else {
                // Stop polling when panel is closed
                stopThinkingPolling();
            }
        }

        function quickMoveTask(taskId, newStatus) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const oldStatus = task.status;
                task.status = newStatus;
                // Set completedAt when moving to done
                if (newStatus === 'done') {
                    task.completedAt = new Date().toISOString();
                } else if (oldStatus === 'done') {
                    delete task.completedAt; // Remove if moving out of done
                }
                // Clear processing state when moving OUT of in_progress
                if (oldStatus === 'in_progress' && newStatus !== 'in_progress') {
                    task.processingStartedAt = null;
                    task.processing = null;
                }
                STATE.data.lastUpdated = new Date().toISOString();
                renderTasks();

                // AUTO-SAVE
                debouncedAutoSave(`Move "${task.title}" â†’ ${newStatus}`);
            }
        }

        // === DRAG & DROP (Trello-style smooth) ===
        let draggedTaskId = null;
        let draggedElement = null;
        let dropTargetInfo = null;
        let lastDropTargetInfo = null;
        let dragOverThrottle = null;

        function handleDragStart(event, taskId) {
            draggedTaskId = taskId;
            draggedElement = event.target;

            // Small delay before adding dragging class for smoother pickup
            requestAnimationFrame(() => {
                event.target.classList.add('dragging');
            });

            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', taskId);
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');

            // Clear all space indicators
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.classList.remove('drag-over');
            });
            document.querySelectorAll('.drop-indicator').forEach(el => {
                el.classList.remove('visible');
            });

            draggedTaskId = null;
            draggedElement = null;
            dropTargetInfo = null;
            lastDropTargetInfo = null;
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            // Throttle to reduce jank
            if (dragOverThrottle) return;
            dragOverThrottle = setTimeout(() => { dragOverThrottle = null; }, 50);

            const container = event.currentTarget;

            // Only add drag-over to the hovered container
            document.querySelectorAll('.column-tasks').forEach(col => {
                if (col !== container) col.classList.remove('drag-over');
            });
            container.classList.add('drag-over');

            // Find insert position based on mouse Y
            const cards = [...container.querySelectorAll('.task-card:not(.dragging)')];
            const mouseY = event.clientY;

            // Clear space classes from cards not in this container
            document.querySelectorAll('.column-tasks').forEach(col => {
                if (col !== container) {
                    col.querySelectorAll('.task-card').forEach(card => {
                        card.classList.remove('make-space-above', 'make-space-below');
                    });
                }
            });

            // Find which card we're hovering over/between
            let insertBeforeId = null;
            let insertIndex = cards.length;
            let targetCard = null;

            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                const rect = card.getBoundingClientRect();
                const cardMiddle = rect.top + rect.height / 2;

                if (mouseY < cardMiddle) {
                    insertBeforeId = card.getAttribute('data-task-id');
                    insertIndex = i;
                    targetCard = card;
                    break;
                }
            }

            // Check if position changed
            const newDropInfo = JSON.stringify({ insertBeforeId, insertIndex, containerId: container.id });
            if (newDropInfo === JSON.stringify(lastDropTargetInfo)) return;
            lastDropTargetInfo = { insertBeforeId, insertIndex, containerId: container.id };

            // Clear all space classes in this container first
            cards.forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            // Add space above the target card (Trello-style gap opening)
            if (targetCard) {
                targetCard.classList.add('make-space-above');
            }

            dropTargetInfo = { insertBeforeId, insertIndex };
        }

        function handleDragLeave(event) {
            // Only remove if actually leaving the container (not entering a child)
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;

            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                event.currentTarget.classList.remove('drag-over');
                event.currentTarget.querySelectorAll('.task-card').forEach(card => {
                    card.classList.remove('make-space-above', 'make-space-below');
                });
            }
        }

        function handleDrop(event, newStatus) {
            event.preventDefault();

            const container = event.currentTarget;
            container.classList.remove('drag-over');

            // Clear all spacing classes
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            if (!draggedTaskId || !STATE.user) return;

            const task = STATE.data.tasks.find(t => t.id === draggedTaskId);
            if (!task) return;

            const oldStatus = task.status;
            const statusChanged = task.status !== newStatus;
            task.status = newStatus;

            // Set completedAt when moving to done
            if (newStatus === 'done') {
                task.completedAt = new Date().toISOString();
            } else if (oldStatus === 'done') {
                delete task.completedAt;
            }
            
            // Clear processing state when moving OUT of in_progress
            if (oldStatus === 'in_progress' && newStatus !== 'in_progress') {
                task.processingStartedAt = null;
                task.processing = null;
            }

            // Calculate new sortOrder based on drop position
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            let tasksInColumn = STATE.data.tasks
                .filter(t => t.status === newStatus && t.id !== task.id)
                .sort((a, b) => {
                    const prioA = priorityOrder[a.priority] ?? 1;
                    const prioB = priorityOrder[b.priority] ?? 1;
                    if (prioA !== prioB) return prioA - prioB;
                    return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                });

            // Find insert position
            let insertIdx = tasksInColumn.length;
            if (dropTargetInfo?.insertBeforeId) {
                const targetIdx = tasksInColumn.findIndex(t => t.id === dropTargetInfo.insertBeforeId);
                if (targetIdx >= 0) insertIdx = targetIdx;
            }

            // Insert task at position
            tasksInColumn.splice(insertIdx, 0, task);

            // Recalculate sortOrder for all tasks in this column (within same priority groups)
            let currentPriority = null;
            let orderCounter = 0;
            tasksInColumn.forEach(t => {
                if (t.priority !== currentPriority) {
                    currentPriority = t.priority;
                    orderCounter = 0;
                }
                t.sortOrder = orderCounter++;
            });

            STATE.data.lastUpdated = new Date().toISOString();

            // Add activity if status changed
            if (statusChanged) {
                STATE.data.activities = STATE.data.activities || [];
                STATE.data.activities.unshift({
                    type: 'moved',
                    actor: STATE.user?.login || 'User',
                    task: task.title,
                    from: oldStatus,
                    to: newStatus,
                    time: 'just now'
                });
                renderActivity();
                
                // AUTO-EXTRACT LEARNINGS when moved to review
                if (newStatus === 'review' && task.comments && task.comments.length > 0) {
                    autoExtractLearningsForTask(task);
                }
            }

            // Optimistic UI: Immediately re-render affected columns
            // Use requestAnimationFrame to ensure DOM is ready after drag operation
            requestAnimationFrame(() => {
                renderTasksSmooth(oldStatus, newStatus, task.id);
            });

            // AUTO-SAVE (async, doesn't block UI)
            const action = statusChanged
                ? `Move "${task.title}" â†’ ${newStatus}`
                : `Reorder "${task.title}"`;
            debouncedAutoSave(action);

            dropTargetInfo = null;
            lastDropTargetInfo = null;
        }

        // Smooth render that only animates affected columns
        function renderTasksSmooth(oldStatus, newStatus, movedTaskId) {
            // Always render both columns to ensure consistency
            const affectedColumns = oldStatus === newStatus
                ? [newStatus]
                : [oldStatus, newStatus];
            
            // First, remove any lingering dragged elements to prevent duplicates
            document.querySelectorAll('.task-card.dragging').forEach(el => el.remove());

            const priorityOrder = { high: 0, medium: 1, low: 2 };
            const data = STATE.data || FALLBACK_DATA;

            // Capture old positions for FLIP animation
            const oldPositions = {};
            affectedColumns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                container.querySelectorAll('.task-card').forEach(card => {
                    const taskId = card.getAttribute('data-task-id');
                    if (taskId) {
                        oldPositions[taskId] = card.getBoundingClientRect();
                    }
                });
            });

            // Re-render only affected columns
            affectedColumns.forEach(status => {
                const container = document.getElementById(`tasks-${status}`);
                let tasks = data.tasks.filter(t => t.status === status && !t.isTemplate && t.status !== 'scheduled');
                
                // Filter out archived tasks (same as renderTasks)
                if (!(showArchivedInSearch && searchQuery)) {
                    tasks = tasks.filter(t => !t.archived);
                }

                // Apply project filter
                if (currentFilter !== 'all') {
                    tasks = tasks.filter(t => t.project === currentFilter || (t.tags && t.tags.includes(currentFilter)));
                }

                // Auto-Sort helper (same as renderTasks)
                function getLastActivityTime(task) {
                    if (task.lastExecutedAt) return new Date(task.lastExecutedAt).getTime();
                    if (task.updatedAt) return new Date(task.updatedAt).getTime();
                    if (task.createdAt) return new Date(task.createdAt).getTime();
                    return 0;
                }
                
                // Sort: Done column by completedAt (newest first), others by priority + last activity
                if (status === 'done') {
                    tasks.sort((a, b) => {
                        const dateA = a.completedAt ? new Date(a.completedAt).getTime() : 0;
                        const dateB = b.completedAt ? new Date(b.completedAt).getTime() : 0;
                        return dateB - dateA;
                    });
                } else {
                    tasks.sort((a, b) => {
                        const prioA = priorityOrder[a.priority] ?? 1;
                        const prioB = priorityOrder[b.priority] ?? 1;
                        if (prioA !== prioB) return prioA - prioB;
                        // Sort by last activity (newest first)
                        const timeA = getLastActivityTime(a);
                        const timeB = getLastActivityTime(b);
                        return timeB - timeA;
                    });
                }

                // Update count
                const count = document.getElementById(`count-${status}`);
                count.textContent = tasks.length;

                // Disable transitions during DOM update
                container.classList.add('no-transition');
                container.innerHTML = tasks.length === 0
                    ? '<div class="empty-state">No tasks</div>'
                    : tasks.map(renderTaskCard).join('');

                // Force reflow
                container.offsetHeight;
                container.classList.remove('no-transition');
            });

            // FLIP animation for smooth movement
            requestAnimationFrame(() => {
                affectedColumns.forEach(status => {
                    const container = document.getElementById(`tasks-${status}`);
                    container.querySelectorAll('.task-card').forEach(card => {
                        const taskId = card.getAttribute('data-task-id');
                        if (taskId && oldPositions[taskId]) {
                            const oldPos = oldPositions[taskId];
                            const newPos = card.getBoundingClientRect();
                            // Only animate Y-axis (vertical) - no horizontal movement
                            const deltaY = oldPos.top - newPos.top;

                            if (Math.abs(deltaY) > 5) {
                                card.style.transform = `translateY(${deltaY}px)`;
                                card.style.transition = 'none';

                                requestAnimationFrame(() => {
                                    card.style.transition = 'transform 0.25s cubic-bezier(0.2, 0, 0.2, 1)';
                                    card.style.transform = 'translateY(0)';
                                });
                            }
                        } else if (taskId === movedTaskId) {
                            // New card entering - just fade in, no scale
                            card.style.opacity = '0';
                            requestAnimationFrame(() => {
                                card.style.transition = 'opacity 0.2s ease';
                                card.style.opacity = '1';
                            });
                        }
                    });
                });
            });

            updateStats();
        }

        // === DEBOUNCE UTILITY ===
        function debounce(fn, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        // === AUTO-SAVE FUNKTION ===
        async function autoSave(action) {
            if (!STATE.token || !STATE.user) {
                showToast('warning', 'Not logged in - changes not saved');
                markAsChanged();
                return;
            }

            const commitMessage = `${action} (via Mission Control)`;
            showToast('info', 'ğŸ’¾ Saving...');

            const success = await saveTasksToGitHub(commitMessage);
            if (!success) {
                markAsChanged(); // Show "unsaved changes" if failed
            }
        }

        // Debounced version for non-critical saves (2 second delay)
        // Use this for edits, moves, renames - NOT for deletes
        const debouncedAutoSave = debounce(autoSave, 2000);

        function renderActivity() {
            const container = document.getElementById('activity-list');
            const data = STATE.data || FALLBACK_DATA;
            const activities = data.activities || FALLBACK_DATA.activities;
            container.innerHTML = activities.map(a => `
                <div class="activity-item">
                    <div class="activity-dot ${a.type}"></div>
                    <div class="activity-content">
                        <span class="activity-actor">${a.actor}</span>
                        <span class="activity-action">${getActionText(a)}</span>
                        <span class="activity-task">${a.task}</span>
                        <div class="activity-time">${a.time}</div>
                    </div>
                </div>
            `).join('');
        }

        function getActionText(activity) {
            switch(activity.type) {
                case 'created': return ' created ';
                case 'moved': return ` moved to ${activity.to} `;
                case 'completed': return ' completed ';
                case 'deleted': return ' deleted ';
                case 'archive': return ' archived ';
                case 'unarchive': return ' unarchived ';
                default: return ' updated ';
            }
        }

        // Add activity to the activity feed
        function addActivity(text, type = 'updated') {
            STATE.data.activities = STATE.data.activities || [];
            
            // Parse the text to extract task name (format: "ğŸ“¦ Archived: Task Name" or similar)
            const taskMatch = text.match(/:\s*(.+)$/) || text.match(/Archived\s+\d+\s+tasks?/);
            const taskName = taskMatch ? taskMatch[1] || taskMatch[0] : text;
            
            STATE.data.activities.unshift({
                type: type,
                actor: STATE.user?.login || 'User',
                task: taskName,
                time: 'just now'
            });
            
            renderActivity();
        }

        function renderFilters() {
            const container = document.getElementById('filters');
            const data = STATE.data || FALLBACK_DATA;
            const projects = data.projects || FALLBACK_DATA.projects;
            const projectButtons = projects.map(p =>
                `<button class="filter-btn" data-filter="${p.id}" onclick="filterByProject('${p.id}')">${p.icon} ${p.name}</button>`
            ).join('');
            container.innerHTML = `
                <button class="filter-btn active" data-filter="all" onclick="filterByProject('all')">All projects</button>
                ${projectButtons}
            `;
        }

        let currentFilter = 'all';
        let searchQuery = '';
        let showArchivedInSearch = false;

        // === ARCHIVE FUNCTIONS ===
        function archiveTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                task.archived = true;
                task.archivedAt = new Date().toISOString();
                addActivity(`ğŸ“¦ Archived: ${task.title}`, 'archive');
                renderTasks();
                saveToGitHub();
            }
        }

        function unarchiveTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                delete task.archived;
                delete task.archivedAt;
                // Move back to done or backlog
                task.status = 'done';
                addActivity(`ğŸ“¤ Unarchived: ${task.title}`, 'unarchive');
                renderTasks();
                saveToGitHub();
            }
        }

        function archiveAllDone() {
            const doneTasks = STATE.data.tasks.filter(t => t.status === 'done' && !t.archived);
            if (doneTasks.length === 0) {
                showToast('No tasks to archive', 'info');
                return;
            }
            
            const count = doneTasks.length;
            doneTasks.forEach(task => {
                task.archived = true;
                task.archivedAt = new Date().toISOString();
            });
            
            addActivity(`ğŸ“¦ Archived ${count} task${count > 1 ? 's' : ''} from Done`, 'archive');
            renderTasks();
            debouncedAutoSave(`Archive ${count} task${count > 1 ? 's' : ''}`);
            showToast(`Archived ${count} task${count > 1 ? 's' : ''}`, 'success');
            
            // Check if we need to move old tasks to archive files
            checkAndMoveOldArchivedTasks();
        }
        
        // === TASK 6: ARCHIV-STRATEGIE ===
        let archivedTasksLoaded = false;
        let archiveIndex = null;
        
        async function checkAndMoveOldArchivedTasks() {
            const now = new Date();
            const cutoffDate = new Date(now.getTime() - (90 * 24 * 60 * 60 * 1000)); // 90 days ago
            
            const oldArchivedTasks = STATE.data.tasks.filter(t => 
                t.archived && 
                t.archivedAt && 
                new Date(t.archivedAt) < cutoffDate
            );
            
            if (oldArchivedTasks.length === 0) return;
            
            // Group by month
            const byMonth = {};
            oldArchivedTasks.forEach(task => {
                const date = new Date(task.archivedAt);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!byMonth[key]) byMonth[key] = [];
                byMonth[key].push(task);
            });
            
            console.log(`Moving ${oldArchivedTasks.length} old archived tasks to archive files`);
            
            // For now, just mark them as offloaded (actual file operations would need backend)
            oldArchivedTasks.forEach(task => {
                task.offloadedToArchive = true;
            });
            
            // Update archive index
            await updateArchiveIndex(byMonth);
        }
        
        async function updateArchiveIndex(byMonth) {
            if (!archiveIndex) {
                archiveIndex = { archives: {}, lastUpdated: null };
            }
            
            Object.keys(byMonth).forEach(monthKey => {
                if (!archiveIndex.archives[monthKey]) {
                    archiveIndex.archives[monthKey] = { count: 0, tasks: [] };
                }
                archiveIndex.archives[monthKey].count += byMonth[monthKey].length;
                archiveIndex.archives[monthKey].tasks.push(...byMonth[monthKey].map(t => ({
                    id: t.id,
                    title: t.title,
                    archivedAt: t.archivedAt
                })));
            });
            
            archiveIndex.lastUpdated = new Date().toISOString();
        }
        
        async function loadArchivedTasks() {
            if (archivedTasksLoaded) return;
            
            showToast('info', 'Loading archived tasks...');
            
            try {
                // Load archive index from GitHub
                const token = STATE.token || localStorage.getItem('gh_token');
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/archive/archive-index.json`,
                    { headers: { 'Authorization': `token ${token}` } }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    archiveIndex = JSON.parse(atob(data.content));
                    archivedTasksLoaded = true;
                    showToast('success', `Loaded archive index`);
                }
            } catch (e) {
                console.log('No archive index found or error:', e);
            }
        }
        
        function exportArchivedTasksCSV() {
            const archivedTasks = STATE.data.tasks.filter(t => t.archived);
            
            if (archivedTasks.length === 0) {
                showToast('info', 'No archived tasks to export');
                return;
            }
            
            // CSV Header
            const headers = ['ID', 'Title', 'Description', 'Status', 'Priority', 'Project', 'Tags', 'Created', 'Completed', 'Archived'];
            
            // CSV Rows
            const rows = archivedTasks.map(task => [
                task.id,
                `"${(task.title || '').replace(/"/g, '""')}"`,
                `"${(task.description || '').replace(/"/g, '""').replace(/\n/g, ' ')}"`,
                task.status,
                task.priority,
                task.project || '',
                (task.tags || []).join(';'),
                task.createdAt || '',
                task.completedAt || '',
                task.archivedAt || ''
            ]);
            
            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `archived-tasks-${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            
            showToast('success', `Exported ${archivedTasks.length} archived tasks to CSV`);
        }
        
        function showArchiveView() {
            // Load archived tasks if not already loaded
            loadArchivedTasks();
            
            const archivedTasks = STATE.data.tasks.filter(t => t.archived);
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'archive-view-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 700px; max-height: 80vh;">
                    <div class="modal-header">
                        <h2 class="modal-title">ğŸ“¦ Archive (${archivedTasks.length} tasks)</h2>
                        <button class="modal-close" onclick="closeArchiveView()">&times;</button>
                    </div>
                    <div class="modal-body" style="overflow-y: auto; max-height: 50vh;">
                        ${archivedTasks.length === 0 ? '<div class="empty-state">No archived tasks</div>' : 
                          archivedTasks.map(task => `
                            <div style="padding: 0.75rem; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${task.title}</strong>
                                    <div style="font-size: 0.8rem; color: var(--text-secondary);">
                                        Archived: ${new Date(task.archivedAt).toLocaleDateString()}
                                    </div>
                                </div>
                                <button class="btn btn-secondary btn-small" onclick="unarchiveTask('${task.id}'); closeArchiveView();">
                                    ğŸ“¤ Restore
                                </button>
                            </div>
                          `).join('')
                        }
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="exportArchivedTasksCSV()">ğŸ“¥ Export CSV</button>
                        <button class="btn btn-primary" onclick="closeArchiveView()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeArchiveView() {
            const dialog = document.getElementById('archive-view-dialog');
            if (dialog) dialog.remove();
        }

        function toggleArchiveSearch(enabled) {
            showArchivedInSearch = enabled;
            renderTasks();
            if (searchQuery) {
                applySearchFilter();
            }
        }

        function handleSearch(query) {
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.querySelector('.search-clear');
            
            // Route to skills search if on skills view
            if (STATE.currentView === 'skills') {
                STATE.skillsSearchQuery = query.trim();
                renderSkillsTab();
                
                // Toggle clear button visibility
                if (clearBtn) {
                    clearBtn.style.display = query.length > 0 ? 'block' : 'none';
                }
                return;
            }
            
            // Default: Tasks search
            searchQuery = query.toLowerCase().trim();
            STATE.searchQuery = searchQuery; // Store in STATE for skill filtering
            
            // Re-render tasks if archive search is enabled (to show/hide archived tasks)
            if (showArchivedInSearch) {
                renderTasks();
            }
            
            applySearchFilter();
            renderCrons(); // Also filter cron jobs
            renderSkills(); // Also filter skills
            
            // Keep expanded when has content
            if (searchInput) {
                searchInput.classList.toggle('expanded', query.length > 0);
            }
            
            // Toggle clear button visibility
            if (clearBtn) {
                clearBtn.style.display = query.length > 0 ? 'block' : 'none';
            }
        }

        function applySearchFilter() {
            const cards = document.querySelectorAll('.task-card');
            const data = STATE.data || FALLBACK_DATA;
            
            cards.forEach(card => {
                const taskId = card.getAttribute('data-task-id');
                const task = data.tasks.find(t => t.id === taskId);
                
                if (!task || !searchQuery) {
                    card.classList.remove('search-dimmed');
                    return;
                }
                
                // Search in title, description, tags, and comments
                const titleMatch = task.title.toLowerCase().includes(searchQuery);
                const descMatch = task.description.toLowerCase().includes(searchQuery);
                const tagMatch = task.tags.some(tag => tag.toLowerCase().includes(searchQuery));
                const commentMatch = task.comments && task.comments.some(c => 
                    c.text.toLowerCase().includes(searchQuery) || 
                    c.author.toLowerCase().includes(searchQuery)
                );
                
                if (titleMatch || descMatch || tagMatch || commentMatch) {
                    card.classList.remove('search-dimmed');
                } else {
                    card.classList.add('search-dimmed');
                }
            });
            
            // Update search result count
            const matchCount = document.querySelectorAll('.task-card:not(.search-dimmed)').length;
            const totalCount = cards.length;
            const searchInfo = document.getElementById('search-info');
            if (searchInfo) {
                if (searchQuery) {
                    searchInfo.textContent = `${matchCount}/${totalCount}`;
                    searchInfo.style.display = 'inline';
                } else {
                    searchInfo.style.display = 'none';
                }
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('search-input');
            const clearBtn = document.querySelector('.search-clear');
            
            if (searchInput) {
                searchInput.value = '';
                searchInput.classList.remove('expanded');
                searchInput.blur();
            }
            
            // Hide clear button
            if (clearBtn) {
                clearBtn.style.display = 'none';
            }
            
            // Route to skills clear if on skills view
            if (STATE.currentView === 'skills') {
                STATE.skillsSearchQuery = '';
                renderSkillsTab();
                return;
            }
            
            // Default: Clear tasks search
            searchQuery = '';
            STATE.searchQuery = ''; // Clear STATE too
            
            // Re-render to hide archived tasks when search is cleared
            if (showArchivedInSearch) {
                renderTasks();
            }
            
            applySearchFilter();
            renderCrons(); // Also clear cron filter
            renderSkills(); // Also clear skills filter
        }

        function filterByProject(projectId) {
            currentFilter = projectId;

            // Update active state
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === projectId);
            });

            renderTasks();
            renderCrons();
        }

        function updateStats() {
            const data = STATE.data || FALLBACK_DATA;
            // Exclude archived tasks and templates from stats
            const activeTasks = data.tasks.filter(t => !t.archived && !t.isTemplate);
            const total = activeTasks.length;
            const inProgress = activeTasks.filter(t => t.status === 'in_progress').length;
            const review = activeTasks.filter(t => t.status === 'review').length;
            const completion = total > 0 ? Math.round((review / total) * 100) : 0;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-progress').textContent = inProgress;
            document.getElementById('stat-week').textContent = review;
            document.getElementById('stat-completion').textContent = completion + '%';
        }

        // === TASK EDITING ===
        let currentEditingTaskId = null;
        let currentTaskTags = [];

        // === CRON TAG FUNCTIONS ===
        let currentCronTags = [];

        function renderCronTagChips() {
            const container = document.getElementById('cron-tags-chips');
            if (!container) return;

            if (currentCronTags.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.875rem;">No tags</span>';
                return;
            }

            container.innerHTML = currentCronTags.map(tag => `
                <span class="tag-chip">
                    ${tag}
                    <span class="tag-remove" onclick="removeCronTag('${tag}')" title="Remove">âœ•</span>
                </span>
            `).join('');
        }

        function addCronTag() {
            const input = document.getElementById('new-cron-tag-input');
            const tag = input.value.trim().toLowerCase();
            if (!tag) return;

            if (!currentCronTags.includes(tag)) {
                currentCronTags.push(tag);
                renderCronTagChips();
            }
            input.value = '';
        }

        function removeCronTag(tag) {
            currentCronTags = currentCronTags.filter(t => t !== tag);
            renderCronTagChips();
        }

        // === TAG FUNCTIONS ===
        function renderTagChips() {
            const container = document.getElementById('tags-chips');
            if (!container) return;

            if (currentTaskTags.length === 0) {
                container.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.875rem;">No tags</span>';
                return;
            }

            container.innerHTML = currentTaskTags.map(tag => `
                <span class="tag-chip">
                    ${tag}
                    <span class="tag-remove" onclick="removeTag('${tag}')" title="Remove">âœ•</span>
                </span>
            `).join('');
        }

        function addTag() {
            const input = document.getElementById('new-tag-input');
            const tag = input.value.trim().toLowerCase();
            if (!tag) return;

            if (!currentTaskTags.includes(tag)) {
                currentTaskTags.push(tag);
                renderTagChips();
            }
            input.value = '';
        }

        function removeTag(tag) {
            currentTaskTags = currentTaskTags.filter(t => t !== tag);
            renderTagChips();
        }

        function openTaskDetail(taskId) {
            if (!STATE.user) {
                showToast('error', 'Login to edit tasks');
                return;
            }

            const data = STATE.data || FALLBACK_DATA;
            const task = data.tasks.find(t => t.id === taskId);

            if (!task) {
                showToast('error', 'Task not found');
                return;
            }

            currentEditingTaskId = taskId;
            isEditingTemplate = task.isTemplate === true;

            // Populate modal
            document.getElementById('task-modal-title').textContent = task.isTemplate ? 'ğŸ“‘ Edit Template' : 'Edit Task';
            document.getElementById('task-title').value = task.title;
            document.getElementById('task-description').value = task.description;
            document.getElementById('task-status').value = task.isTemplate ? (task.baseStatus || 'backlog') : task.status;
            document.getElementById('task-priority').value = task.priority;
            document.getElementById('task-project').value = task.project;
            document.getElementById('btn-delete-task').style.display = 'block';
            
            // Show/hide "As Cron" button based on task type
            const asCronBtn = document.getElementById('btn-task-to-cron');
            if (asCronBtn) {
                asCronBtn.style.display = task.isTemplate ? 'none' : 'inline-flex';
            }

            // Render tags as chips
            currentTaskTags = [...(task.tags || [])];
            renderTagChips();

            // Render subtasks
            renderSubtasks(task);

            // Render comments
            renderComments(task);
            
            // Render learnings (only visible in review status)
            renderLearnings(task);

            document.getElementById('task-modal').classList.add('visible');
        }

        function renderSubtasks(task) {
            const container = document.getElementById('subtasks-list');
            if (!task.subtasks || task.subtasks.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
                return;
            }
            container.innerHTML = task.subtasks.map(sub => `
                <div class="subtask-item">
                    <input type="checkbox" ${sub.done ? 'checked' : ''} onchange="toggleSubtask('${task.id}', '${sub.id}')">
                    <span class="subtask-title ${sub.done ? 'done' : ''}"
                          onclick="startEditSubtask('${task.id}', '${sub.id}')"
                          title="Click to edit"
                          style="cursor: pointer;">${sub.title}</span>
                    <button class="subtask-delete" onclick="deleteSubtask('${task.id}', '${sub.id}')" title="Delete">âœ•</button>
                </div>
            `).join('');
        }

        function startEditSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            const subtask = task.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            // Replace span with input
            const container = document.getElementById('subtasks-list');
            const items = container.querySelectorAll('.subtask-item');
            items.forEach(item => {
                const span = item.querySelector('.subtask-title');
                if (span && span.textContent === subtask.title) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = subtask.title;
                    input.className = 'subtask-edit-input';
                    input.style.cssText = 'flex: 1; padding: 4px 8px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary);';

                    input.onblur = () => saveSubtaskEdit(taskId, subtaskId, input.value);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveSubtaskEdit(taskId, subtaskId, input.value);
                        }
                        if (e.key === 'Escape') {
                            renderSubtasks(task);
                        }
                    };

                    span.replaceWith(input);
                    input.focus();
                    input.select();
                }
            });
        }

        function saveSubtaskEdit(taskId, subtaskId, newTitle) {
            newTitle = newTitle.trim();
            if (!newTitle) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            const subtask = task.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            if (subtask.title !== newTitle) {
                const oldTitle = subtask.title;
                subtask.title = newTitle;
                renderSubtasks(task);
                // AUTO-SAVE
                debouncedAutoSave(`Rename subtask "${oldTitle}" â†’ "${newTitle}"`);
            } else {
                renderSubtasks(task);
            }
        }

        function renderComments(task) {
            const container = document.getElementById('comments-list');
            const comments = task.comments || [];
            if (comments.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';
                return;
            }
            container.innerHTML = comments.map((c, idx) => `
                <div class="comment-item" data-comment-idx="${idx}">
                    <div class="comment-header">
                        <span class="comment-author">${c.author}</span>
                        <span class="comment-time">${formatTimeAgo(c.createdAt)}</span>
                        <span class="comment-actions">
                            <button class="comment-action-btn" onclick="editComment('${task.id}', ${idx})" title="Edit">âœï¸</button>
                            <button class="comment-action-btn" onclick="deleteComment('${task.id}', ${idx})" title="Delete">ğŸ—‘ï¸</button>
                        </span>
                    </div>
                    <div class="comment-text" id="comment-text-${idx}">${renderMarkdown(c.text)}</div>
                </div>
            `).join('');
        }

        function editComment(taskId, commentIdx) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;

            const comment = task.comments[commentIdx];
            const textEl = document.getElementById(`comment-text-${commentIdx}`);
            if (!textEl) return;

            const textarea = document.createElement('textarea');
            textarea.value = comment.text;
            textarea.className = 'comment-edit-textarea';
            textarea.style.cssText = 'width: 100%; min-height: 60px; padding: 8px; border: 1px solid var(--accent); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); resize: vertical;';

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.className = 'btn btn-primary btn-small';
            saveBtn.style.marginTop = '8px';
            saveBtn.onclick = () => saveCommentEdit(taskId, commentIdx, textarea.value);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'btn btn-secondary btn-small';
            cancelBtn.style.cssText = 'margin-top: 8px; margin-left: 8px;';
            cancelBtn.onclick = () => renderComments(task);

            textEl.innerHTML = '';
            textEl.appendChild(textarea);
            textEl.appendChild(saveBtn);
            textEl.appendChild(cancelBtn);
            textarea.focus();
        }

        function saveCommentEdit(taskId, commentIdx, newText) {
            newText = newText.trim();
            if (!newText) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments || !task.comments[commentIdx]) return;

            const oldText = task.comments[commentIdx].text;
            if (oldText !== newText) {
                task.comments[commentIdx].text = newText;
                task.comments[commentIdx].editedAt = new Date().toISOString();
                renderComments(task);
                debouncedAutoSave(`Edit comment on "${task.title}"`);
            } else {
                renderComments(task);
            }
        }

        function deleteComment(taskId, commentIdx) {
            if (!confirm('Delete this comment?')) return;

            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.comments) return;

            task.comments.splice(commentIdx, 1);
            renderComments(task);
            autoSave(`Delete comment from "${task.title}"`);
        }

        function formatTimeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffMs = now - date;
            const diffMin = Math.floor(diffMs / 60000);
            const diffHour = Math.floor(diffMs / 3600000);
            const diffDay = Math.floor(diffMs / 86400000);

            if (diffMin < 1) return 'just now';
            if (diffMin < 60) return diffMin + ' min ago';
            if (diffHour < 24) return diffHour + ' hours ago';
            return diffDay + ' days ago';
        }
        
        // =====================================================
        // SELF-LEARNING FUNCTIONS
        // =====================================================
        
        function renderLearnings(task) {
            const container = document.getElementById('learnings-list');
            const section = document.getElementById('learnings-section');
            
            // Only show for review status
            if (task.status !== 'review') {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            const learnings = task.learnings || [];
            if (learnings.length === 0) {
                container.innerHTML = `
                    <div class="learnings-empty">
                        No learnings extracted yet. Click "Extract from Comments" to analyze this task.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = learnings.map((l, idx) => `
                <div class="learning-item ${l.status || 'pending'}">
                    <div class="learning-category">
                        <span class="learning-category-badge ${l.category || 'fact'}">${l.category || 'fact'}</span>
                        ${l.status === 'accepted' ? '<span style="color: var(--accent-green); font-size: 0.75rem;">âœ“ Saved</span>' : ''}
                        ${l.status === 'rejected' ? '<span style="color: var(--accent-red); font-size: 0.75rem;">âœ• Rejected</span>' : ''}
                    </div>
                    <div class="learning-text">${escapeHtml(l.text)}</div>
                    ${l.tags && l.tags.length > 0 ? `
                        <div class="learning-tags">
                            ${l.tags.map(t => `<span class="learning-tag">#${t}</span>`).join('')}
                        </div>
                    ` : ''}
                    ${l.status !== 'accepted' && l.status !== 'rejected' ? `
                        <div class="learning-actions">
                            <button class="learning-action-btn accept" onclick="acceptLearning('${task.id}', ${idx})">âœ“ Accept</button>
                            <button class="learning-action-btn edit" onclick="editLearning('${task.id}', ${idx})">âœï¸ Edit</button>
                            <button class="learning-action-btn reject" onclick="rejectLearning('${task.id}', ${idx})">âœ• Reject</button>
                        </div>
                    ` : ''}
                </div>
            `).join('');
        }
        
        async function extractLearnings() {
            if (!currentEditingTaskId) return;
            
            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (!task) return;
            
            showToast('info', 'Analyzing task...');
            
            try {
                const learnings = await extractLearningsFromTask(task);
                
                if (!task.learnings) task.learnings = [];
                
                // Add new learnings (don't duplicate)
                for (const learning of learnings) {
                    const exists = task.learnings.some(l => l.text === learning.text);
                    if (!exists) {
                        task.learnings.push({
                            ...learning,
                            id: `learn_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                            status: 'pending',
                            createdAt: new Date().toISOString()
                        });
                    }
                }
                
                renderLearnings(task);
                showToast('success', `Found ${learnings.length} potential learnings`);
                
            } catch (error) {
                console.error('Error extracting learnings:', error);
                showToast('error', 'Failed to extract learnings');
            }
        }
        
        // Auto-extract learnings silently when task moves to review
        async function autoExtractLearningsForTask(task) {
            if (!task || !task.comments || task.comments.length === 0) return;
            
            // Don't re-extract if learnings already exist
            if (task.learnings && task.learnings.length > 0) return;
            
            try {
                console.log('Auto-extracting learnings for:', task.title);
                const learnings = await extractLearningsFromTask(task);
                
                if (learnings.length === 0) {
                    console.log('No learnings found for:', task.title);
                    return;
                }
                
                if (!task.learnings) task.learnings = [];
                
                for (const learning of learnings) {
                    const exists = task.learnings.some(l => l.text === learning.text);
                    if (!exists) {
                        task.learnings.push({
                            ...learning,
                            id: `learn_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                            status: 'pending',
                            createdAt: new Date().toISOString()
                        });
                    }
                }
                
                console.log(`Auto-extracted ${learnings.length} learnings for: ${task.title}`);
                showToast('info', `ğŸ§  ${learnings.length} learnings extracted`);
                
            } catch (error) {
                console.error('Auto-extract learnings failed:', error);
            }
        }
        
        async function extractLearningsFromTask(task) {
            // Collect all text from task
            let fullText = `Title: ${task.title}\n\nDescription: ${task.description || ''}\n\n`;
            
            if (task.comments && task.comments.length > 0) {
                fullText += 'Comments:\n';
                task.comments.forEach(c => {
                    fullText += `[${c.author}]: ${c.text}\n\n`;
                });
            }
            
            // Try AI extraction first
            const aiSettings = getAISettings();
            if (aiSettings.provider !== 'local' && aiSettings.apiKey) {
                try {
                    return await aiExtractLearnings(fullText);
                } catch (e) {
                    console.log('AI extraction failed, using local:', e);
                }
            }
            
            // Fallback to local extraction
            return localExtractLearnings(fullText);
        }
        
        async function aiExtractLearnings(text) {
            const prompt = `Analyze this task and its comments. Extract valuable learnings that should be remembered.

Categories:
- technical: Code patterns, architecture decisions, debugging solutions
- process: Workflows, step-by-step procedures, best practices
- preference: How the user wants things done, style preferences
- fact: Important information, contacts, credentials (redact sensitive data)
- correction: What NOT to do, mistakes to avoid

For each learning, provide:
- text: A concise, actionable statement (1-2 sentences)
- category: One of the categories above
- tags: 1-3 relevant tags

Task content:
${text}

Respond with JSON array only:
[{"text": "...", "category": "...", "tags": ["..."]}]`;

            const response = await callAI(prompt);
            
            try {
                // Extract JSON from response
                const jsonMatch = response.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }
            } catch (e) {
                console.error('Failed to parse AI response:', e);
            }
            
            return [];
        }
        
        function localExtractLearnings(text) {
            const learnings = [];
            const lines = text.split('\n');
            
            // Pattern matching for common learning indicators (English + German)
            const patterns = [
                // English patterns
                { regex: /(?:solved|fixed|resolved).*?by\s+(.+)/i, category: 'technical' },
                { regex: /(?:remember|note|important):\s*(.+)/i, category: 'fact' },
                { regex: /(?:don't|never|avoid)\s+(.+)/i, category: 'correction' },
                { regex: /(?:always|should|must)\s+(.+)/i, category: 'preference' },
                { regex: /(?:step|process|workflow):\s*(.+)/i, category: 'process' },
                { regex: /(?:use|using)\s+(.+?)\s+(?:for|to)\s+(.+)/i, category: 'technical' },
                // German patterns
                { regex: /(?:merke?\s*dir|speicher|notier)\s*[,:.]?\s*(.+)/i, category: 'preference' },
                { regex: /(?:bevorzugt|favorit|prÃ¤ferier|am liebsten)\s*(.+)/i, category: 'preference' },
                { regex: /(?:niemals|nie|vermeide|nicht)\s+(.+)/i, category: 'correction' },
                { regex: /(?:immer|stets|unbedingt)\s+(.+)/i, category: 'preference' },
                { regex: /(?:gelÃ¶st|behoben|gefixt)\s*(?:durch|mit|indem)\s*(.+)/i, category: 'technical' },
                { regex: /(?:wichtig|hinweis|achtung)[:\s]+(.+)/i, category: 'fact' },
                { regex: /(?:mein(?:e)?|unser(?:e)?)\s+(?:telefon|mobil|handy|nummer|kennzeichen|auto|fahrzeug|kfz|adresse|mail)/i, category: 'fact' },
                // Contact/credential patterns
                { regex: /(?:kennzeichen|license\s*plate)[:\s]*([A-Z]{1,3}[-\s]?[A-Z]{1,2}[-\s]?\d{1,4})/i, category: 'fact' },
                { regex: /(?:mobil|handy|tel(?:efon)?)[:\s]*(\+?[\d\s\-\/]{8,})/i, category: 'fact' },
                { regex: /(?:e-?mail)[:\s]*([\w\.\-]+@[\w\.\-]+\.\w+)/i, category: 'fact' }
            ];
            
            for (const line of lines) {
                if (line.trim().length < 15) continue;
                
                for (const { regex, category } of patterns) {
                    const match = line.match(regex);
                    if (match) {
                        learnings.push({
                            text: line.trim().substring(0, 250),
                            category,
                            tags: extractTagsFromText(line)
                        });
                        break;
                    }
                }
            }
            
            // Also extract explicit learnings marked with ğŸ§  or "Learning:" / "Merke:"
            const learningMarkers = text.match(/(?:ğŸ§ |learning:|lesson:|takeaway:|lernen:|merke:|notiz:)\s*([^\n]+)/gi) || [];
            for (const marker of learningMarkers) {
                const cleanText = marker.replace(/(?:ğŸ§ |learning:|lesson:|takeaway:|lernen:|merke:|notiz:)\s*/i, '').trim();
                if (cleanText.length > 10) {
                    learnings.push({
                        text: cleanText,
                        category: 'fact',
                        tags: extractTagsFromText(cleanText)
                    });
                }
            }
            
            // Extract full sentences containing preference keywords (more aggressive)
            const preferenceKeywords = /(?:bevorzug|prÃ¤ferier|favorit|am liebsten|fÃ¼r mich|immer bei|standard|default)/i;
            for (const line of lines) {
                if (line.trim().length > 30 && preferenceKeywords.test(line)) {
                    const exists = learnings.some(l => l.text === line.trim().substring(0, 250));
                    if (!exists) {
                        learnings.push({
                            text: line.trim().substring(0, 250),
                            category: 'preference',
                            tags: extractTagsFromText(line)
                        });
                    }
                }
            }
            
            return learnings.slice(0, 15); // Limit to 15 learnings
        }
        
        function extractTagsFromText(text) {
            const tags = [];
            const words = text.toLowerCase().match(/\b[a-z]{4,}\b/g) || [];
            
            const techTerms = ['api', 'database', 'github', 'javascript', 'python', 'react', 'css', 'html', 'docker', 'aws'];
            const stopWords = new Set(['that', 'this', 'with', 'from', 'have', 'been', 'will', 'would', 'could', 'should']);
            
            for (const word of words) {
                if (techTerms.includes(word)) {
                    tags.push(word);
                }
            }
            
            // Add most frequent non-stop word
            const wordFreq = {};
            words.filter(w => !stopWords.has(w)).forEach(w => {
                wordFreq[w] = (wordFreq[w] || 0) + 1;
            });
            
            const topWord = Object.entries(wordFreq).sort((a, b) => b[1] - a[1])[0];
            if (topWord && !tags.includes(topWord[0])) {
                tags.push(topWord[0]);
            }
            
            return tags.slice(0, 3);
        }
        
        function addManualLearning() {
            if (!currentEditingTaskId) return;
            
            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (!task) return;
            
            const text = prompt('Enter the learning:');
            if (!text || text.trim().length < 5) return;
            
            const category = prompt('Category (technical/process/preference/fact/correction):', 'fact') || 'fact';
            
            if (!task.learnings) task.learnings = [];
            
            task.learnings.push({
                id: `learn_${Date.now()}`,
                text: text.trim(),
                category,
                tags: extractTagsFromText(text),
                status: 'pending',
                createdAt: new Date().toISOString()
            });
            
            renderLearnings(task);
            showToast('success', 'Learning added');
        }
        
        async function acceptLearning(taskId, learningIdx) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.learnings || !task.learnings[learningIdx]) return;
            
            const learning = task.learnings[learningIdx];
            learning.status = 'accepted';
            learning.acceptedAt = new Date().toISOString();
            
            // Save to memory file
            try {
                await saveLearningToMemory(learning, task);
                renderLearnings(task);
                debouncedAutoSave(`Accept learning from "${task.title}"`);
                showToast('success', 'Learning saved to memory');
            } catch (error) {
                console.error('Failed to save learning:', error);
                showToast('error', 'Failed to save to memory');
                learning.status = 'pending';
            }
        }
        
        async function saveLearningToMemory(learning, task) {
            const today = new Date().toISOString().split('T')[0];
            const targetPath = `memory/${today}.md`;
            
            // Format the learning entry
            const entry = `
### Learning from: ${task.title}
_${learning.category} â€¢ ${new Date().toLocaleString('de-DE')}_

${learning.text}

${learning.tags.map(t => `#${t}`).join(' ')}

---
`;
            
            // Load existing file or create new
            let existingContent = '';
            try {
                const file = await fetchGitHubFile(targetPath);
                if (file && file.content) {
                    existingContent = atob(file.content);
                }
            } catch (e) {
                // File doesn't exist, start fresh
                existingContent = `# Daily Notes - ${today}\n\n`;
            }
            
            const newContent = existingContent + entry;
            await saveFileToGitHub(targetPath, newContent, `Add learning from task: ${task.title}`);
            
            return true;
        }
        
        function editLearning(taskId, learningIdx) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.learnings || !task.learnings[learningIdx]) return;
            
            const learning = task.learnings[learningIdx];
            const newText = prompt('Edit learning:', learning.text);
            
            if (newText && newText.trim().length > 5) {
                learning.text = newText.trim();
                learning.tags = extractTagsFromText(newText);
                renderLearnings(task);
            }
        }
        
        function rejectLearning(taskId, learningIdx) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.learnings || !task.learnings[learningIdx]) return;
            
            task.learnings[learningIdx].status = 'rejected';
            renderLearnings(task);
        }

        function toggleSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                if (subtask) {
                    subtask.done = !subtask.done;
                    renderSubtasks(task);
                    renderTasks();
                    // AUTO-SAVE mit Debounce
                    debouncedAutoSave(`${subtask.done ? 'âœ“' : 'â—‹'} "${subtask.title}" in "${task.title}"`);
                }
            }
        }

        function deleteSubtask(taskId, subtaskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                const subtaskTitle = subtask?.title || 'Subtask';
                task.subtasks = task.subtasks.filter(s => s.id !== subtaskId);
                renderSubtasks(task);
                renderTasks();
                // AUTO-SAVE
                autoSave(`Remove subtask "${subtaskTitle}" from "${task.title}"`);
            }
        }

        function addSubtask() {
            if (!currentEditingTaskId) return;
            const input = document.getElementById('new-subtask-input');
            const title = input.value.trim();
            if (!title) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (task) {
                const newId = 'sub_' + Date.now();
                task.subtasks.push({ id: newId, title: title, done: false });
                renderSubtasks(task);
                renderTasks();
                input.value = '';
                // AUTO-SAVE
                debouncedAutoSave(`Add subtask "${title}" to "${task.title}"`);
            }
        }

        // Note: debouncedAutoSave is now defined earlier using debounce() utility

        async function addComment() {
            if (!currentEditingTaskId) return;
            const input = document.getElementById('new-comment-input');
            const text = input.value.trim();
            if (!text) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            if (task) {
                // Store original state for rollback
                const originalStatus = task.status;
                const originalComments = task.comments ? [...task.comments] : [];
                
                if (!task.comments) task.comments = [];
                const newComment = {
                    id: 'c_' + Date.now(),
                    author: STATE.user?.login || 'User',
                    text: text,
                    createdAt: new Date().toISOString()
                };
                task.comments.push(newComment);
                renderComments(task);
                input.value = '';

                // AUTO-MOVE: Review â†’ In Progress when comment is added (signals rework needed)
                let commitMsg;
                const wasReview = task.status === 'review';
                if (wasReview) {
                    task.status = 'in_progress';
                    commitMsg = `ğŸ’¬ Rework "${task.title}": ${text.substring(0, 50)}${text.length > 50 ? '...' : ''} (review â†’ in_progress)`;
                } else {
                    commitMsg = `Comment on "${task.title}": ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`;
                }
                
                // Save to GitHub
                const success = await saveTasksToGitHub(commitMsg, true); // forceOverwrite=true to skip conflict dialog
                if (success) {
                    if (wasReview) {
                        showToast('info', 'ğŸ”„ Task moved to In Progress for rework');
                    }
                    renderAll();
                } else {
                    // FULL ROLLBACK: Revert BOTH status AND comment if save failed
                    task.status = originalStatus;
                    task.comments = originalComments;
                    renderComments(task);
                    renderAll();
                    showToast('error', 'âŒ Could not save comment - changes reverted');
                }
            }
        }

        function openNewTask(status = 'backlog') {
            if (!STATE.user) {
                showToast('error', 'Login to add tasks');
                return;
            }

            currentEditingTaskId = null;

            // Reset modal
            document.getElementById('task-modal-title').textContent = 'New Task';
            document.getElementById('task-title').value = '';
            document.getElementById('task-description').value = '';
            document.getElementById('task-status').value = status;
            document.getElementById('task-priority').value = 'medium';
            document.getElementById('task-project').value = 'system';
            document.getElementById('btn-delete-task').style.display = 'none';

            // Reset tags
            currentTaskTags = [];
            renderTagChips();

            // Clear subtasks and comments for new task
            document.getElementById('subtasks-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
            document.getElementById('comments-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';

            document.getElementById('task-modal').classList.add('visible');
        }

        function hideTaskModal() {
            document.getElementById('task-modal').classList.remove('visible');
            currentEditingTaskId = null;
            isEditingTemplate = false;
        }

        function saveTask() {
            const title = document.getElementById('task-title').value.trim();
            const description = document.getElementById('task-description').value.trim();
            const status = document.getElementById('task-status').value;
            const priority = document.getElementById('task-priority').value;
            const project = document.getElementById('task-project').value;
            const tags = currentTaskTags.length > 0 ? [...currentTaskTags] : [project];

            if (!title) {
                showToast('error', 'Title is required');
                return;
            }

            if (currentEditingTaskId) {
                // Update existing task or template
                const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
                if (task) {
                    task.title = title;
                    task.description = description;
                    task.priority = priority;
                    task.project = project;
                    task.tags = tags.length > 0 ? tags : [project];
                    
                    if (isEditingTemplate) {
                        task.baseStatus = status; // Store the status to use when executing
                    } else {
                        task.status = status;
                    }
                }
            } else {
                // Create new task or template
                const newItem = {
                    id: (isEditingTemplate ? 'template_' : 'task_') + Date.now(),
                    title: title,
                    description: description,
                    project: project,
                    tags: tags.length > 0 ? tags : [project],
                    subtasks: [],
                    priority: priority,
                    createdAt: new Date().toISOString()
                };
                
                if (isEditingTemplate) {
                    newItem.isTemplate = true;
                    newItem.baseStatus = status;
                    newItem.executionCount = 0;
                } else {
                    newItem.status = status;
                }
                
                STATE.data.tasks.push(newItem);
            }

            STATE.data.lastUpdated = new Date().toISOString();
            hideTaskModal();
            
            if (isEditingTemplate) {
                renderTemplates();
            } else {
                renderTasks(true); // Animate reorder
            }
            
            isEditingTemplate = false;

            // AUTO-SAVE
            const itemType = isEditingTemplate ? 'template' : 'task';
            const action = currentEditingTaskId ? `Update ${itemType} "${title}"` : `Create ${itemType} "${title}"`;
            debouncedAutoSave(action);
        }

        function deleteTask() {
            if (!currentEditingTaskId) return;

            if (!confirm('Are you sure you want to delete this task?')) return;

            const task = STATE.data.tasks.find(t => t.id === currentEditingTaskId);
            const taskTitle = task?.title || 'Task';

            STATE.data.tasks = STATE.data.tasks.filter(t => t.id !== currentEditingTaskId);
            STATE.data.lastUpdated = new Date().toISOString();
            hideTaskModal();
            renderTasks();

            // AUTO-SAVE
            autoSave(`Delete "${taskTitle}"`);
        }

        function markAsChanged() {
            STATE.hasUnsavedChanges = true;
            document.getElementById('unsaved-banner').classList.add('visible');
        }

        function discardChanges() {
            if (STATE.originalData) {
                STATE.data = JSON.parse(JSON.stringify(STATE.originalData));
            }
            STATE.hasUnsavedChanges = false;
            document.getElementById('unsaved-banner').classList.remove('visible');
            renderTasks();
            showToast('success', 'Changes discarded');
        }

        // === COMMIT MODAL ===
        function showCommitModal() {
            if (!STATE.hasUnsavedChanges) {
                showToast('error', 'No changes to save');
                return;
            }

            document.getElementById('commit-message').value = '';
            document.getElementById('changes-summary').innerHTML = generateChangesSummary();
            document.getElementById('commit-modal').classList.add('visible');
        }

        function hideCommitModal() {
            document.getElementById('commit-modal').classList.remove('visible');
        }

        // === SETTINGS MODAL ===
        function showSettingsModal() {
            renderProjectsList();
            // Show current gateway URL
            const gatewayInput = document.getElementById('gateway-url-input');
            const gatewayStatus = document.getElementById('gateway-status');
            const currentUrl = getGatewayUrl();
            if (gatewayInput) {
                gatewayInput.value = currentUrl || '';
            }
            if (gatewayStatus) {
                gatewayStatus.textContent = currentUrl ? 'âœ… Connected' : 'âš ï¸ Not connected';
                gatewayStatus.style.color = currentUrl ? 'var(--accent-green)' : 'var(--text-secondary)';
            }
            // Show current session key (legacy)
            const sessionInput = document.getElementById('session-key-input');
            const sessionStatus = document.getElementById('session-key-status');
            const currentSession = getSessionKey();
            if (sessionInput) {
                sessionInput.value = currentSession || '';
            }
            if (sessionStatus) {
                sessionStatus.textContent = currentSession ? 'âœ… Configured' : 'âš ï¸ Not set';
                sessionStatus.style.color = currentSession ? 'var(--accent-green)' : 'var(--text-secondary)';
            }
            // Show current hooks token
            const hooksInput = document.getElementById('hooks-token-input');
            const hooksStatus = document.getElementById('hooks-token-status');
            const currentHooksToken = getHooksToken();
            if (hooksInput) {
                hooksInput.value = currentHooksToken || '';
            }
            if (hooksStatus) {
                hooksStatus.textContent = currentHooksToken ? 'âœ… Token configured' : 'âš ï¸ Not set (using fallback)';
                hooksStatus.style.color = currentHooksToken ? 'var(--accent-green)' : 'var(--text-secondary)';
            }
            document.getElementById('settings-modal').classList.add('visible');
        }

        function hideSettingsModal() {
            document.getElementById('settings-modal').classList.remove('visible');
        }
        
        async function saveGatewayUrl() {
            const input = document.getElementById('gateway-url-input');
            const status = document.getElementById('gateway-status');
            const url = input.value.trim();
            
            if (!url) {
                setGatewayUrl(null);
                status.textContent = 'âš ï¸ Disconnected';
                status.style.color = 'var(--text-secondary)';
                return;
            }
            
            status.textContent = 'ğŸ”„ Testing connection...';
            status.style.color = 'var(--text-secondary)';
            
            try {
                const response = await fetch(url + '/api/health', { 
                    method: 'GET',
                    timeout: 5000 
                });
                if (response.ok) {
                    setGatewayUrl(url);
                    status.textContent = 'âœ… Connected!';
                    status.style.color = 'var(--accent-green)';
                    showToast('success', 'Gateway connected');
                } else {
                    status.textContent = 'âŒ Connection failed (bad response)';
                    status.style.color = 'var(--accent-red)';
                }
            } catch (err) {
                // Try anyway - might just not have /health endpoint
                setGatewayUrl(url);
                status.textContent = 'âš ï¸ Saved (could not verify)';
                status.style.color = 'var(--accent-yellow)';
                showToast('info', 'Gateway URL saved');
            }
        }
        
        // === HOOKS TOKEN FOR LIVE THINKING ===
        function toggleHooksTokenVisibility() {
            const input = document.getElementById('hooks-token-input');
            input.type = input.type === 'password' ? 'text' : 'password';
        }
        
        async function saveHooksToken() {
            const input = document.getElementById('hooks-token-input');
            const status = document.getElementById('hooks-token-status');
            const token = input.value.trim();
            
            if (!token) {
                setHooksToken(null);
                status.textContent = 'âš ï¸ Token cleared';
                status.style.color = 'var(--text-secondary)';
                return;
            }
            
            status.textContent = 'ğŸ”„ Testing connection...';
            status.style.color = 'var(--text-secondary)';
            
            try {
                const response = await fetch(`${THINKING_API_URL}?token=${encodeURIComponent(token)}&limit=1`);
                const data = await response.json();
                
                if (response.ok && data.ok) {
                    setHooksToken(token);
                    status.textContent = 'âœ… Token valid! Live thinking enabled.';
                    status.style.color = 'var(--accent-green)';
                    showToast('success', 'Live thinking enabled');
                } else {
                    status.textContent = 'âŒ Invalid token: ' + (data.error || 'Unknown error');
                    status.style.color = 'var(--accent-red)';
                }
            } catch (err) {
                // Network error - save anyway, might work later
                setHooksToken(token);
                status.textContent = 'âš ï¸ Saved (could not verify - API may be offline)';
                status.style.color = 'var(--accent-yellow)';
                showToast('info', 'Token saved');
            }
        }
        
        // Load hooks token on settings modal open
        function loadHooksTokenOnModalOpen() {
            const input = document.getElementById('hooks-token-input');
            const stored = getHooksToken();
            if (input && stored) {
                input.value = stored;
            }
        }
        
        // === THINKING VISIBILITY (Legacy - kept for compatibility) ===
        function getSessionKey() {
            if (STATE.sessionKey) return STATE.sessionKey;
            return localStorage.getItem('mc_session_key');
        }
        
        function setSessionKey(key) {
            STATE.sessionKey = key;
            if (key) {
                localStorage.setItem('mc_session_key', key);
            } else {
                localStorage.removeItem('mc_session_key');
            }
        }
        
        function saveSessionKey() {
            const input = document.getElementById('session-key-input');
            const status = document.getElementById('session-key-status');
            const key = input.value.trim();
            
            if (!key) {
                setSessionKey(null);
                status.textContent = 'âš ï¸ No session key configured';
                status.style.color = 'var(--text-secondary)';
                stopThinkingPolling();
                return;
            }
            
            setSessionKey(key);
            status.textContent = 'âœ… Session key saved';
            status.style.color = 'var(--accent-green)';
            showToast('success', 'Session key saved');
        }
        
        // Thinking API configuration
        const THINKING_API_URL = 'https://your-gateway.example.com/api/thinking';
        
        // Get stored hooks token from localStorage
        function getHooksToken() {
            return localStorage.getItem('mc_hooks_token') || '';
        }
        
        function setHooksToken(token) {
            if (token) {
                localStorage.setItem('mc_hooks_token', token);
            } else {
                localStorage.removeItem('mc_hooks_token');
            }
        }
        
        // Fetch REAL thinking blocks from Clawdbot Gateway API
        async function fetchThinkingBlocks(taskId) {
            const token = getHooksToken();
            
            // If no token, fall back to comment-based approach
            if (!token) {
                return fetchThinkingFromComments(taskId);
            }
            
            try {
                const response = await fetch(`${THINKING_API_URL}?token=${encodeURIComponent(token)}&limit=50`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    console.warn('Thinking API error:', response.status);
                    // Fall back to comments
                    return fetchThinkingFromComments(taskId);
                }
                
                const data = await response.json();
                
                if (data.ok && data.thinking) {
                    // Transform to expected format
                    return data.thinking.map(block => ({
                        text: block.content || block.thinking || '',
                        timestamp: new Date(block.timestamp).getTime() || Date.now()
                    }));
                }
                
                return [];
            } catch (error) {
                console.warn('Thinking API fetch error:', error);
                // Fall back to comment-based approach
                return fetchThinkingFromComments(taskId);
            }
        }
        
        // Fallback: Extract thinking from task comments (prefix: "ğŸ’­ Thinking:")
        function fetchThinkingFromComments(taskId) {
            const task = STATE.tasks.find(t => t.id === taskId);
            if (!task || !task.comments) {
                return [];
            }
            
            const thinkingBlocks = [];
            for (const comment of task.comments) {
                const content = comment.content || comment.text || '';
                if (content.includes('ğŸ’­ Thinking:') || content.startsWith('ğŸ’­')) {
                    let text = content;
                    if (content.includes('ğŸ’­ Thinking:')) {
                        text = content.split('ğŸ’­ Thinking:').slice(1).join('ğŸ’­ Thinking:').trim();
                    } else if (content.startsWith('ğŸ’­')) {
                        text = content.substring(1).trim();
                    }
                    
                    thinkingBlocks.push({
                        text: text,
                        timestamp: new Date(comment.createdAt).getTime() || Date.now()
                    });
                }
            }
            
            return thinkingBlocks;
        }
        
        function startThinkingPolling(taskId) {
            stopThinkingPolling(); // Clear any existing polling
            
            console.log('Starting thinking polling for task:', taskId);
            const hasToken = !!getHooksToken();
            
            // Poll interval: 3s with API, 5s with comments (GitHub rate limit)
            const pollInterval = hasToken ? 3000 : 5000;
            
            STATE.thinkingPolling = setInterval(async () => {
                if (!hasToken) {
                    // Reload tasks to get latest comments
                    await loadTasks();
                }
                const blocks = await fetchThinkingBlocks(taskId);
                if (blocks && blocks.length > 0) {
                    STATE.thinkingHistory[taskId] = blocks;
                    renderThinkingPanel(taskId, blocks);
                }
            }, pollInterval);
            
            // Initial fetch
            (async () => {
                const blocks = await fetchThinkingBlocks(taskId);
                if (blocks && blocks.length > 0) {
                    STATE.thinkingHistory[taskId] = blocks;
                    renderThinkingPanel(taskId, blocks);
                }
            })();
        }
        
        function stopThinkingPolling() {
            if (STATE.thinkingPolling) {
                clearInterval(STATE.thinkingPolling);
                STATE.thinkingPolling = null;
            }
        }
        
        function renderThinkingPanel(taskId, blocks) {
            const panel = document.getElementById(`thinking-panel-${taskId}`);
            if (!panel) return;
            
            if (!blocks || blocks.length === 0) {
                panel.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No thinking data yet...</div>';
                return;
            }
            
            // Show last 10 blocks, most recent at bottom
            const recentBlocks = blocks.slice(-10);
            panel.innerHTML = recentBlocks.map(block => {
                const time = new Date(block.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const text = block.text.length > 200 ? block.text.substring(0, 200) + '...' : block.text;
                return `<div class="thinking-block">
                    <span class="thinking-time">[${time}]</span>
                    <span class="thinking-text">${escapeHtml(text)}</span>
                </div>`;
            }).join('');
            
            // Auto-scroll to bottom
            panel.scrollTop = panel.scrollHeight;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Track seen comment IDs for animation
        const seenCommentIds = new Set();
        
        // Render activity log from comments (for In Progress tasks)
        function renderActivityLog(comments, panelId) {
            if (!comments || comments.length === 0) {
                return '<div style="color: var(--text-secondary); font-style: italic;">Noch keine AktivitÃ¤t...</div>';
            }
            
            // Show last 10 comments, most recent at bottom
            const recentComments = comments.slice(-10);
            let hasNewComments = false;
            
            const html = recentComments.map(comment => {
                const content = comment.content || comment.text || '';
                const time = new Date(comment.createdAt).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                const date = new Date(comment.createdAt).toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' });
                const author = comment.author || 'Agent';
                const preview = content.length > 300 ? content.substring(0, 300) + '...' : content;
                const isThinking = content.includes('ğŸ’­') || content.toLowerCase().includes('thinking');
                const isNew = !seenCommentIds.has(comment.id);
                const thinkingClass = isThinking ? ' is-thinking' : '';
                // Only add 'new' class for truly new comments (not seen before)
                const newClass = isNew ? ' new' : '';
                
                if (isNew) hasNewComments = true;
                
                // Mark as seen AFTER checking
                seenCommentIds.add(comment.id);
                
                return '<div class="thinking-block' + thinkingClass + newClass + '" data-comment-id="' + comment.id + '">' +
                    '<span class="thinking-time">[' + date + ' ' + time + ']</span> ' +
                    '<span class="thinking-author">' + author + ':</span> ' +
                    '<span class="thinking-text">' + escapeHtml(preview).replace(/\n/g, '<br>') + '</span>' +
                '</div>';
            }).join('');
            
            // Only auto-scroll if there are NEW comments
            if (panelId && hasNewComments) {
                setTimeout(() => {
                    const panel = document.getElementById(panelId);
                    if (panel) {
                        panel.scrollTop = panel.scrollHeight;
                    }
                }, 50);
            }
            
            return html;
        }

        function renderProjectsList() {
            const container = document.getElementById('projects-list');
            const projects = STATE.data?.projects || [];

            if (projects.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary);">No projects yet</div>';
                return;
            }

            container.innerHTML = projects.map(p => `
                <div class="project-item">
                    <span class="project-icon">${p.icon}</span>
                    <span class="project-color" style="background: ${p.color}"></span>
                    <span class="project-name">${p.name}</span>
                    <span class="project-id">${p.id}</span>
                    <div class="project-actions">
                        <button onclick="editProject('${p.id}')" title="Edit">âœï¸</button>
                        <button onclick="deleteProject('${p.id}')" title="Delete">ğŸ—‘ï¸</button>
                    </div>
                </div>
            `).join('');

            // Update project dropdown in task modal
            updateProjectDropdown();
        }

        let editingProjectId = null;

        function saveProject() {
            const id = document.getElementById('new-project-id').value.trim().toLowerCase().replace(/\s+/g, '-');
            const name = document.getElementById('new-project-name').value.trim();
            const icon = document.getElementById('new-project-icon').value.trim() || 'ğŸ“';
            const color = document.getElementById('new-project-color').value;

            if (!id || !name) {
                showToast('error', 'ID and Name are required');
                return;
            }

            if (editingProjectId) {
                // UPDATE existing project
                const project = STATE.data.projects.find(p => p.id === editingProjectId);
                if (project) {
                    // If ID changed, update all tasks using this project
                    if (editingProjectId !== id) {
                        STATE.data.tasks.forEach(t => {
                            if (t.project === editingProjectId) t.project = id;
                        });
                    }
                    project.id = id;
                    project.name = name;
                    project.icon = icon;
                    project.color = color;
                    debouncedAutoSave(`Update project "${name}"`);
                }
            } else {
                // ADD new project
                if (STATE.data.projects.some(p => p.id === id)) {
                    showToast('error', 'Project ID already exists');
                    return;
                }
                STATE.data.projects.push({ id, name, icon, color });
                debouncedAutoSave(`Add project "${name}"`);
            }

            // Reset form
            clearProjectForm();
            renderProjectsList();
            renderFilters();
        }

        function editProject(projectId) {
            const project = STATE.data.projects.find(p => p.id === projectId);
            if (!project) return;

            // Load data into form
            editingProjectId = projectId;
            document.getElementById('new-project-id').value = project.id;
            document.getElementById('new-project-name').value = project.name;
            document.getElementById('new-project-icon').value = project.icon;
            document.getElementById('new-project-color').value = project.color;

            // Update UI
            document.getElementById('project-form-title').textContent = `Edit Project: ${project.name}`;
            document.getElementById('btn-save-project').textContent = 'ğŸ’¾ Save Changes';
            document.getElementById('btn-cancel-project').style.display = 'block';

            // Clear emoji selection
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.textContent.trim() === project.icon);
            });

            // Scroll to form
            document.querySelector('.add-project-form').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelEditProject() {
            clearProjectForm();
        }

        function clearProjectForm() {
            editingProjectId = null;
            document.getElementById('new-project-id').value = '';
            document.getElementById('new-project-name').value = '';
            document.getElementById('new-project-icon').value = '';
            document.getElementById('new-project-color').value = '#6366f1';
            document.getElementById('project-form-title').textContent = 'Add New Project';
            document.getElementById('btn-save-project').textContent = '+ Add Project';
            document.getElementById('btn-cancel-project').style.display = 'none';
            document.querySelectorAll('.emoji-btn').forEach(btn => btn.classList.remove('selected'));
        }

        function deleteProject(projectId) {
            const project = STATE.data.projects.find(p => p.id === projectId);
            if (!project) return;

            // Check if any tasks use this project
            const tasksUsingProject = STATE.data.tasks.filter(t => t.project === projectId);
            if (tasksUsingProject.length > 0) {
                if (!confirm(`${tasksUsingProject.length} task(s) use this project. Delete anyway? Tasks will be moved to "system".`)) {
                    return;
                }
                // Move tasks to system
                tasksUsingProject.forEach(t => t.project = 'system');
            }

            STATE.data.projects = STATE.data.projects.filter(p => p.id !== projectId);

            renderProjectsList();
            renderFilters();
            autoSave(`Delete project "${project.name}"`);
        }

        function updateProjectDropdown() {
            const select = document.getElementById('task-project');
            if (!select) return;

            const projects = STATE.data?.projects || [];
            select.innerHTML = projects.map(p =>
                `<option value="${p.id}">${p.icon} ${p.name}</option>`
            ).join('');
        }

        function selectEmoji(emoji) {
            document.getElementById('new-project-icon').value = emoji;
            // Visual feedback
            document.querySelectorAll('.emoji-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }

        // === VIEW SWITCHING ===
        STATE.currentView = 'tasks';
        
        function switchView(viewName) {
            STATE.currentView = viewName;
            
            // Hide all views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.view').forEach(v => v.style.display = 'none');

            // Show selected view
            const view = document.getElementById('view-' + viewName);
            if (view) {
                view.classList.add('active');
                view.style.display = 'block';
            }

            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === viewName);
            });
            
            // Update header search placeholder based on view
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                if (viewName === 'skills') {
                    searchInput.placeholder = 'Search skills...';
                    // Set value from skills search state
                    searchInput.value = STATE.skillsSearchQuery || '';
                } else {
                    searchInput.placeholder = 'Search tasks...';
                    // Restore tasks search value
                    searchInput.value = STATE.searchQuery || '';
                }
            }
            
            // Render Skills tab when selected
            if (viewName === 'skills') {
                renderSkillsTab();
            }
            
            // Render Brain tab when selected
            if (viewName === 'brain') {
                renderBrainTab();
            }
        }

        function generateChangesSummary() {
            const current = STATE.data.tasks.length;
            const original = STATE.originalData ? STATE.originalData.tasks.length : current;
            const diff = current - original;

            let html = '<strong>Changes to commit:</strong><br>';
            if (diff > 0) {
                html += `â€¢ Added ${diff} new task(s)<br>`;
            } else if (diff < 0) {
                html += `â€¢ Deleted ${Math.abs(diff)} task(s)<br>`;
            }
            html += `â€¢ Total tasks: ${current}`;

            return html;
        }

        async function commitChanges() {
            const message = document.getElementById('commit-message').value.trim() || 'Update tasks via Mission Control';

            document.getElementById('commit-btn-text').textContent = 'Saving...';
            document.getElementById('commit-spinner').style.display = 'inline-block';
            document.getElementById('btn-commit').disabled = true;

            const success = await saveTasksToGitHub(message);

            document.getElementById('commit-btn-text').textContent = 'Commit & Push';
            document.getElementById('commit-spinner').style.display = 'none';
            document.getElementById('btn-commit').disabled = false;

            if (success) {
                hideCommitModal();
            }
        }

        // === ACTIVITY TOGGLE ===
        function toggleActivity() {
            const sidebar = document.getElementById('activity-sidebar');
            const icon = document.getElementById('activity-toggle-icon');
            const reopen = document.getElementById('activity-reopen');
            const isCollapsed = sidebar.classList.toggle('collapsed');
            icon.textContent = isCollapsed ? 'â˜°' : 'âœ•';
            reopen.style.display = isCollapsed ? 'flex' : 'none';
            localStorage.setItem('activity-collapsed', isCollapsed);
        }

        // === AUTO-POLLING ===
        let lastDataHash = null;
        let lastPollTime = Date.now();
        const POLL_INTERVAL_NORMAL = 30000; // 30 seconds when idle
        const POLL_INTERVAL_ACTIVE = 10000; // 10 seconds when tasks are in progress
        let pollIntervalId = null;
        
        function getPollInterval() {
            // Faster polling when there are in-progress tasks
            const hasInProgress = STATE.data?.tasks?.some(t => t.status === 'in_progress');
            return hasInProgress ? POLL_INTERVAL_ACTIVE : POLL_INTERVAL_NORMAL;
        }

        function hashData(data) {
            return JSON.stringify(data);
        }

        async function pollForUpdates() {
            // Don't poll during active drag operations or while saving
            if (!STATE.token || STATE.hasUnsavedChanges || document.hidden || draggedTaskId || STATE.isSaving) return;

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/contents/${CONFIG.tasksFile}`,
                    {
                        headers: {
                            'Authorization': `token ${STATE.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'If-None-Match': ''  // Bypass cache
                        }
                    }
                );

                if (!response.ok) return;

                const fileData = await response.json();
                const bytes = Uint8Array.from(atob(fileData.content), c => c.charCodeAt(0));
                const content = new TextDecoder().decode(bytes);
                const newData = JSON.parse(content);

                const newHash = hashData(newData);
                if (lastDataHash && newHash !== lastDataHash) {
                    STATE.data = newData;
                    STATE.originalData = JSON.parse(JSON.stringify(newData));
                    STATE.fileSha = fileData.sha;
                    renderAll();
                    showToast('success', 'ğŸ”„ Dashboard updated');
                }
                lastDataHash = newHash;
                lastPollTime = Date.now();
                updateLiveIndicator();

            } catch (error) {
                console.log('Poll error:', error);
            }
        }

        function updateLiveIndicator() {
            const indicator = document.getElementById('live-indicator');
            if (indicator) {
                const seconds = Math.round((Date.now() - lastPollTime) / 1000);
                indicator.textContent = seconds < 5 ? 'Live' : `${seconds}s ago`;
                indicator.className = 'live-indicator ' + (seconds < 35 ? 'live' : 'stale');
            }
        }

        // Start polling with dynamic interval
        function startDynamicPolling() {
            if (pollIntervalId) clearInterval(pollIntervalId);
            const interval = getPollInterval();
            pollIntervalId = setInterval(() => {
                pollForUpdates();
                // Adjust interval if needed
                const newInterval = getPollInterval();
                if (newInterval !== interval) {
                    startDynamicPolling();
                }
            }, interval);
        }
        startDynamicPolling();
        setInterval(updateLiveIndicator, 1000);

        // === TEMPLATES FUNCTIONS ===
        function renderTemplates() {
            const container = document.getElementById('tasks-templates');
            const countEl = document.getElementById('count-templates');
            const data = STATE.data || FALLBACK_DATA;
            const templates = data.tasks.filter(t => t.isTemplate === true);
            
            countEl.textContent = templates.length;
            
            if (templates.length === 0) {
                container.innerHTML = '<div class="empty-state">No templates yet</div>';
                return;
            }
            
            container.innerHTML = templates.map(template => {
                const execCount = template.executionCount || 0;
                return `
                    <div class="template-card" data-template-id="${template.id}" onclick="openTemplateDetail('${template.id}')">
                        <div class="template-name">${template.title}</div>
                        <div class="template-description">${template.description || ''}</div>
                        <div class="template-meta">
                            <span class="execution-count" title="Times executed">
                                â–¶ ${execCount}x
                            </span>
                            ${template.tags ? template.tags.map(t => `<span class="task-tag ${t}">${t}</span>`).join('') : ''}
                        </div>
                        <div class="template-actions" onclick="event.stopPropagation()">
                            <button class="template-action-btn run" onclick="executeTemplate('${template.id}')" title="Run template">â–¶ Run</button>
                            <button class="template-action-btn" onclick="duplicateTemplate('${template.id}')" title="Duplicate">ğŸ“‹ Copy</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function openNewTemplate() {
            if (!STATE.user) {
                showToast('error', 'Login to create templates');
                return;
            }
            
            currentEditingTaskId = null;
            isEditingTemplate = true;
            
            document.getElementById('task-modal-title').textContent = 'ğŸ“‘ New Template';
            document.getElementById('task-title').value = '';
            document.getElementById('task-description').value = '';
            document.getElementById('task-status').value = 'backlog';
            document.getElementById('task-priority').value = 'medium';
            document.getElementById('task-project').value = 'system';
            document.getElementById('btn-delete-task').style.display = 'none';
            
            currentTaskTags = [];
            renderTagChips();
            
            document.getElementById('subtasks-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No subtasks yet</div>';
            document.getElementById('comments-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 0.875rem;">No comments yet</div>';
            
            document.getElementById('task-modal').classList.add('visible');
        }

        let isEditingTemplate = false;

        function openTemplateDetail(templateId) {
            if (!STATE.user) {
                showToast('error', 'Login to edit templates');
                return;
            }
            
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            currentEditingTaskId = templateId;
            isEditingTemplate = true;
            
            document.getElementById('task-modal-title').textContent = 'ğŸ“‘ Edit Template';
            document.getElementById('task-title').value = template.title;
            document.getElementById('task-description').value = template.description;
            document.getElementById('task-status').value = template.baseStatus || 'backlog';
            document.getElementById('task-priority').value = template.priority;
            document.getElementById('task-project').value = template.project;
            document.getElementById('btn-delete-task').style.display = 'block';
            
            currentTaskTags = [...(template.tags || [])];
            renderTagChips();
            
            renderSubtasks(template);
            renderComments(template);
            
            document.getElementById('task-modal').classList.add('visible');
        }

        function executeTemplate(templateId) {
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            // Create task from template
            const newTask = structuredClone(template);
            newTask.id = 'task_' + Date.now();
            newTask.isTemplate = false;
            newTask.status = template.baseStatus || 'backlog';
            newTask.createdAt = new Date().toISOString();
            newTask.createdFromTemplate = templateId;
            delete newTask.executionCount;
            delete newTask.baseStatus;
            
            // Clear subtask completion status
            if (newTask.subtasks) {
                newTask.subtasks = newTask.subtasks.map(s => ({
                    ...s,
                    id: 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    done: false
                }));
            }
            
            STATE.data.tasks.push(newTask);
            
            // Increment execution counter
            template.executionCount = (template.executionCount || 0) + 1;
            
            renderTemplates();
            renderTasks();
            debouncedAutoSave(`Execute template "${template.title}"`);
            showToast('success', `Created task from template: ${newTask.title}`);
        }

        // Task 8: Template-Duplikat
        function duplicateTemplate(templateId) {
            const data = STATE.data || FALLBACK_DATA;
            const template = data.tasks.find(t => t.id === templateId);
            
            if (!template) {
                showToast('error', 'Template not found');
                return;
            }
            
            // Deep copy
            const newTemplate = structuredClone(template);
            newTemplate.id = 'template_' + Date.now();
            newTemplate.createdAt = new Date().toISOString();
            newTemplate.executionCount = 0;
            
            // Generate suffix
            const baseName = template.title.replace(/ \(Kopie( \d+)?\)$/, '');
            const existingCopies = data.tasks.filter(t => 
                t.isTemplate && 
                (t.title === baseName + ' (Kopie)' || t.title.match(new RegExp(`^${baseName.replace(/[.*+?^${}()|[\]\\]/g, '\$&')} \\(Kopie \\d+\\)$`)))
            );
            
            if (existingCopies.length === 0) {
                newTemplate.title = baseName + ' (Kopie)';
            } else {
                newTemplate.title = baseName + ' (Kopie ' + (existingCopies.length + 1) + ')';
            }
            
            // Reset subtask IDs
            if (newTemplate.subtasks) {
                newTemplate.subtasks = newTemplate.subtasks.map(s => ({
                    ...s,
                    id: 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
                }));
            }
            
            STATE.data.tasks.push(newTemplate);
            renderTemplates();
            debouncedAutoSave(`Duplicate template "${template.title}"`);
            
            // Open edit modal with focus on title
            setTimeout(() => {
                openTemplateDetail(newTemplate.id);
                setTimeout(() => {
                    const titleInput = document.getElementById('task-title');
                    if (titleInput) {
                        titleInput.focus();
                        titleInput.select();
                    }
                }, 100);
            }, 200);
        }

        // Template Done Confirmation Dialog
        function showTemplateExecutionDialog(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task || !task.createdFromTemplate) {
                quickMoveTask(taskId, 'done');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'template-execution-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">âœ… Task Completed</h2>
                        <button class="modal-close" onclick="closeTemplateDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem;">This task was created from a template. What would you like to do?</p>
                    </div>
                    <div class="modal-footer" style="flex-direction: column; gap: 0.5rem;">
                        <button class="btn btn-primary" style="width: 100%;" onclick="executeOnlyFromDialog('${taskId}')">
                            â–¶ Just Execute (stays available)
                        </button>
                        <button class="btn btn-secondary" style="width: 100%;" onclick="archiveFromDialog('${taskId}')">
                            ğŸ“¦ Archive Task
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }

        function closeTemplateDialog() {
            const dialog = document.getElementById('template-execution-dialog');
            if (dialog) dialog.remove();
        }

        function executeOnlyFromDialog(taskId) {
            closeTemplateDialog();
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (task) {
                // Move to done but don't archive - will auto-return
                task.status = 'done';
                task.completedAt = new Date().toISOString();
                
                // Auto-return to backlog after marking done
                setTimeout(() => {
                    if (task.status === 'done' && !task.archived) {
                        task.status = task.baseStatus || 'backlog';
                        delete task.completedAt;
                        // Reset subtasks
                        if (task.subtasks) {
                            task.subtasks.forEach(s => s.done = false);
                        }
                        renderTasks();
                        showToast('success', `Task "${task.title}" returned to backlog`);
                    }
                }, 2000);
                
                renderTasks();
                debouncedAutoSave(`Complete "${task.title}" (auto-return)`);
            }
        }

        function archiveFromDialog(taskId) {
            closeTemplateDialog();
            quickMoveTask(taskId, 'done');
        }

        // === SCHEDULED TASKS FUNCTIONS (Task 7) ===
        function renderScheduledTasks() {
            const container = document.getElementById('tasks-scheduled');
            const countEl = document.getElementById('count-scheduled');
            const data = STATE.data || FALLBACK_DATA;
            const scheduled = data.tasks.filter(t => t.scheduledAt && t.status === 'scheduled');
            
            countEl.textContent = scheduled.length;
            
            if (scheduled.length === 0) {
                container.innerHTML = '<div class="empty-state">No scheduled tasks</div>';
                return;
            }
            
            // Sort by scheduledAt
            scheduled.sort((a, b) => new Date(a.scheduledAt) - new Date(b.scheduledAt));
            
            container.innerHTML = scheduled.map(task => {
                const scheduledDate = new Date(task.scheduledAt);
                const now = new Date();
                const isOverdue = scheduledDate < now;
                const countdown = formatScheduledCountdown(scheduledDate);
                
                return `
                    <div class="scheduled-card ${isOverdue ? 'overdue' : ''}" data-task-id="${task.id}" onclick="openTaskDetail('${task.id}')">
                        <div class="scheduled-name">${task.title}</div>
                        <div class="scheduled-time">
                            <span class="countdown ${isOverdue ? 'overdue' : ''}">
                                ${isOverdue ? 'âš ï¸ Overdue' : 'â° ' + countdown}
                            </span>
                        </div>
                        <div class="task-description">${task.description || ''}</div>
                    </div>
                `;
            }).join('');
            
            // Check for overdue tasks
            checkScheduledTasks();
        }

        function formatScheduledCountdown(date) {
            const now = new Date();
            const diff = date - now;
            
            if (diff < 0) return 'Overdue';
            
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (days > 0) return `in ${days}d ${hours % 24}h`;
            if (hours > 0) return `in ${hours}h ${minutes % 60}m`;
            return `in ${minutes}m`;
        }

        function checkScheduledTasks() {
            const data = STATE.data || FALLBACK_DATA;
            const scheduled = data.tasks.filter(t => t.scheduledAt && t.status === 'scheduled');
            const now = new Date();
            
            scheduled.forEach(task => {
                const scheduledDate = new Date(task.scheduledAt);
                if (scheduledDate <= now) {
                    // Auto-execute overdue task
                    executeScheduledTask(task.id);
                }
            });
        }

        function executeScheduledTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            task.status = 'in_progress';
            delete task.scheduledAt;
            
            renderScheduledTasks();
            renderTasks();
            debouncedAutoSave(`Auto-execute scheduled task "${task.title}"`);
            showToast('success', `Scheduled task "${task.title}" is now in progress!`);
        }

        function openScheduledTaskModal() {
            if (!STATE.user) {
                showToast('error', 'Login to schedule tasks');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'scheduled-task-dialog';
            
            const now = new Date();
            const defaultDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // Tomorrow
            const dateStr = defaultDate.toISOString().slice(0, 16);
            
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ğŸ“… Schedule Task</h2>
                        <button class="modal-close" onclick="closeScheduledTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Title</label>
                            <input type="text" class="form-input" id="scheduled-title" placeholder="Task title">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Description</label>
                            <textarea class="form-input" id="scheduled-description" rows="2" placeholder="Task description"></textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Scheduled For</label>
                            <input type="datetime-local" class="form-input" id="scheduled-datetime" value="${dateStr}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Priority</label>
                            <select class="form-input" id="scheduled-priority">
                                <option value="low">Low</option>
                                <option value="medium" selected>Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeScheduledTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveScheduledTask()">Schedule Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            document.getElementById('scheduled-title').focus();
        }

        function closeScheduledTaskDialog() {
            const dialog = document.getElementById('scheduled-task-dialog');
            if (dialog) dialog.remove();
        }

        function saveScheduledTask() {
            const title = document.getElementById('scheduled-title').value.trim();
            const description = document.getElementById('scheduled-description').value.trim();
            const datetime = document.getElementById('scheduled-datetime').value;
            const priority = document.getElementById('scheduled-priority').value;
            
            if (!title) {
                showToast('error', 'Title is required');
                return;
            }
            
            if (!datetime) {
                showToast('error', 'Please select a date and time');
                return;
            }
            
            const scheduledAt = new Date(datetime).toISOString();
            
            const newTask = {
                id: 'task_' + Date.now(),
                title,
                description,
                status: 'scheduled',
                scheduledAt,
                priority,
                project: 'system',
                tags: ['scheduled'],
                subtasks: [],
                createdAt: new Date().toISOString()
            };
            
            STATE.data.tasks.push(newTask);
            closeScheduledTaskDialog();
            renderScheduledTasks();
            debouncedAutoSave(`Schedule task "${title}"`);
            showToast('success', `Task scheduled for ${new Date(scheduledAt).toLocaleString()}`);
        }

        // Check scheduled tasks every minute
        setInterval(() => {
            if (STATE.data) checkScheduledTasks();
        }, 60000);
        
        // Update scheduled task countdowns every 30 seconds
        setInterval(() => {
            if (STATE.data) renderScheduledTasks();
        }, 30000);
        
        // Update processing time displays every 30 seconds
        setInterval(() => {
            updateProcessingTimes();
        }, 30000);
        
        // Update activity logs for in_progress tasks every 15 seconds
        setInterval(() => {
            updateActivityLogs();
        }, 15000);
        
        function updateActivityLogs() {
            // Find all visible thinking panels and check for NEW comments only
            document.querySelectorAll('.thinking-panel').forEach(panel => {
                if (panel.style.display !== 'none') {
                    const taskId = panel.id.replace('thinking-panel-', '');
                    const task = STATE.data?.tasks?.find(t => t.id === taskId);
                    if (task && task.comments) {
                        // Check if there are actually new comments
                        const hasNewComments = task.comments.some(c => !seenCommentIds.has(c.id));
                        if (hasNewComments) {
                            const contentEl = document.getElementById(`thinking-content-${taskId}`);
                            if (contentEl) {
                                contentEl.innerHTML = renderActivityLog(task.comments, panel.id);
                            }
                        }
                    }
                }
            });
        }
        
        function updateProcessingTimes() {
            // Update all processing time indicators without full re-render
            document.querySelectorAll('.processing-time').forEach(el => {
                const startedAt = el.dataset.startedAt;
                if (startedAt) {
                    const start = new Date(startedAt);
                    const now = new Date();
                    const minutesElapsed = Math.floor((now - start) / 60000);
                    const isTimeout = minutesElapsed >= 30;
                    const timeText = minutesElapsed < 1 ? 'gerade gestartet' : 
                                     minutesElapsed === 1 ? '1 Min' : `${minutesElapsed} Min`;
                    el.textContent = timeText;
                    el.className = 'processing-time' + (isTimeout ? ' timeout' : '');
                }
            });
        }

        // Schedule existing task (when dragged to Scheduled column)
        function openScheduleTaskModal(task) {
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'schedule-existing-task-dialog';
            
            const now = new Date();
            const defaultDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // Tomorrow
            defaultDate.setHours(9, 0, 0, 0); // Default to 9:00 AM
            const dateStr = defaultDate.toISOString().slice(0, 16);
            
            dialog.innerHTML = `
                <div class="modal" style="max-width: 450px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ğŸ“… Schedule Task</h2>
                        <button class="modal-close" onclick="closeScheduleExistingTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Task</label>
                            <div style="padding: 0.5rem; background: var(--bg-secondary); border-radius: 4px; font-weight: 500;">
                                ${task.title}
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">When should this task be due?</label>
                            <input type="datetime-local" class="form-input" id="schedule-task-datetime" value="${dateStr}">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeScheduleExistingTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmScheduleTask('${task.id}')">ğŸ“… Schedule</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeScheduleExistingTaskDialog() {
            const dialog = document.getElementById('schedule-existing-task-dialog');
            if (dialog) dialog.remove();
        }
        
        function confirmScheduleTask(taskId) {
            const datetime = document.getElementById('schedule-task-datetime').value;
            
            if (!datetime) {
                showToast('error', 'Please select a date and time');
                return;
            }
            
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const oldStatus = task.status;
            task.status = 'scheduled';
            task.scheduledAt = new Date(datetime).toISOString();
            task.updatedAt = new Date().toISOString();
            
            closeScheduleExistingTaskDialog();
            renderTasks();
            renderScheduledTasks();
            
            debouncedAutoSave(`Schedule "${task.title}" for ${new Date(datetime).toLocaleString()}`);
            showToast('success', `ğŸ“… Scheduled for ${new Date(datetime).toLocaleString()}`);
        }

        // === TASK 1: CRON DRAG & DROP ===
        let draggedCronId = null;
        
        function handleCronDragStart(event, cronId) {
            draggedCronId = cronId;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', 'cron:' + cronId);
        }
        
        function handleCronDragEnd(event) {
            event.target.classList.remove('dragging');
            draggedCronId = null;
            document.querySelectorAll('.column-tasks').forEach(col => {
                col.classList.remove('drag-over');
            });
        }
        
        function handleCronDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        
        function handleCronDragLeave(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                event.currentTarget.classList.remove('drag-over');
            }
        }
        
        function handleCronDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            // Crons dropped back on Recurring - do nothing
        }
        
        // Extended handleDrop for Cron drops
        const originalHandleDrop = handleDrop;
        handleDrop = function(event, newStatus) {
            event.preventDefault();
            const container = event.currentTarget;
            container.classList.remove('drag-over');
            
            const data = event.dataTransfer.getData('text/plain');
            
            // Check if it's a cron being dropped
            if (data.startsWith('cron:')) {
                const cronId = data.replace('cron:', '');
                const cron = STATE.crons?.find(c => c.id === cronId);
                
                if (!cron) return;
                
                if (newStatus === 'in_progress') {
                    // Execute cron via Gateway API
                    executeCronJob(cronId);
                } else if (newStatus === 'done') {
                    // Disable the cron
                    disableCronJob(cronId);
                } else if (newStatus === 'scheduled') {
                    // Convert cron to one-shot scheduled task
                    openCronToScheduledModal(cron);
                } else {
                    showToast('info', 'Drop on "In Progress" to execute, "Scheduled" to convert, "Done" to disable');
                }
                return;
            }
            
            // Regular task drop
            document.querySelectorAll('.task-card').forEach(card => {
                card.classList.remove('make-space-above', 'make-space-below');
            });

            if (!draggedTaskId || !STATE.user) return;

            const task = STATE.data.tasks.find(t => t.id === draggedTaskId);
            if (!task) return;

            const oldStatus = task.status;
            const statusChanged = task.status !== newStatus;
            
            // Check if this is a template-created task being moved to Done
            if (newStatus === 'done' && task.createdFromTemplate) {
                showTemplateExecutionDialog(draggedTaskId);
                draggedTaskId = null;
                return;
            }
            
            // If moving to Scheduled, show date picker modal
            if (newStatus === 'scheduled' && oldStatus !== 'scheduled') {
                openScheduleTaskModal(task);
                draggedTaskId = null;
                return;
            }
            
            task.status = newStatus;

            // Set completedAt when moving to done
            if (newStatus === 'done') {
                task.completedAt = new Date().toISOString();
            } else if (oldStatus === 'done') {
                delete task.completedAt;
            }
            
            // Clear processing state when moving OUT of in_progress
            if (oldStatus === 'in_progress' && newStatus !== 'in_progress') {
                task.processingStartedAt = null;
                task.processing = null;
            }

            // Calculate new sortOrder based on drop position
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            let tasksInColumn = STATE.data.tasks
                .filter(t => t.status === newStatus && t.id !== task.id)
                .sort((a, b) => {
                    const prioA = priorityOrder[a.priority] ?? 1;
                    const prioB = priorityOrder[b.priority] ?? 1;
                    if (prioA !== prioB) return prioA - prioB;
                    return (a.sortOrder ?? 999999) - (b.sortOrder ?? 999999);
                });

            // Find insert position
            let insertIdx = tasksInColumn.length;
            if (dropTargetInfo?.insertBeforeId) {
                const targetIdx = tasksInColumn.findIndex(t => t.id === dropTargetInfo.insertBeforeId);
                if (targetIdx >= 0) insertIdx = targetIdx;
            }

            // Insert task at position
            tasksInColumn.splice(insertIdx, 0, task);

            // Recalculate sortOrder for all tasks in this column
            let currentPriority = null;
            let orderCounter = 0;
            tasksInColumn.forEach(t => {
                if (t.priority !== currentPriority) {
                    currentPriority = t.priority;
                    orderCounter = 0;
                }
                t.sortOrder = orderCounter++;
            });

            STATE.data.lastUpdated = new Date().toISOString();

            if (statusChanged) {
                STATE.data.activities = STATE.data.activities || [];
                STATE.data.activities.unshift({
                    type: 'moved',
                    actor: STATE.user?.login || 'User',
                    task: task.title,
                    from: oldStatus,
                    to: newStatus,
                    time: 'just now'
                });
                renderActivity();
            }

            renderTasksSmooth(oldStatus, newStatus, task.id);

            const action = statusChanged
                ? `Move "${task.title}" â†’ ${newStatus}`
                : `Reorder "${task.title}"`;
            debouncedAutoSave(action);

            dropTargetInfo = null;
            lastDropTargetInfo = null;
        };
        
        // Create a temporary task in "In Progress" for cron execution
        function createCronExecutionTask(cron) {
            const taskId = `cron_exec_${cron.id}_${Date.now()}`;
            const task = {
                id: taskId,
                title: `ğŸš€ ${cron.name}`,
                description: `Executing cron job...\n\nSchedule: ${cron.scheduleHuman || cron.schedule}`,
                status: 'in_progress',
                tags: ['cron-execution'],
                cronId: cron.id,
                isTemporary: true,
                createdAt: new Date().toISOString(),
                processing: true
            };
            STATE.data.tasks.push(task);
            renderTasks();
            return taskId;
        }
        
        // Remove temporary cron execution task
        function removeCronExecutionTask(cronId, moveToArchive = false) {
            const taskIndex = STATE.data.tasks.findIndex(t => t.cronId === cronId && t.isTemporary);
            if (taskIndex >= 0) {
                if (moveToArchive) {
                    const task = STATE.data.tasks[taskIndex];
                    task.status = 'done';
                    task.completedAt = new Date().toISOString();
                    task.archived = true;
                    task.archivedAt = new Date().toISOString();
                } else {
                    STATE.data.tasks.splice(taskIndex, 1);
                }
                renderTasks();
            }
        }
        
        async function executeCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const gatewayUrl = getGatewayUrl();
            
            // Create temporary task in "In Progress"
            const tempTaskId = createCronExecutionTask(cron);
            
            if (!gatewayUrl) {
                // No gateway available - mark as pending execution
                cron.pendingExecution = true;
                cron.pendingExecutionAt = new Date().toISOString();
                renderCrons();
                
                // Update task to show it's queued
                const task = STATE.data.tasks.find(t => t.id === tempTaskId);
                if (task) {
                    task.title = `â³ ${cron.name}`;
                    task.description = `Queued for execution (Gateway offline)\n\nWill run on next sync.`;
                    task.processing = false;
                    renderTasks();
                }
                
                // Save to GitHub so sync-crons.sh can pick it up
                const saved = await saveCronsToGitHub(`Queue "${cron.name}" for execution`);
                if (saved) {
                    showToast('warning', `â³ "${cron.name}" queued - will run on next sync`, 5000);
                } else {
                    showToast('error', `Gateway offline - cannot execute cron`, 5000);
                    delete cron.pendingExecution;
                    delete cron.pendingExecutionAt;
                    removeCronExecutionTask(cronId);
                }
                return;
            }
            
            showToast('info', `ğŸš€ Executing "${cron.name}"...`);
            
            try {
                // Call Gateway API to execute cron
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId + '/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    showToast('success', `âœ“ Cron "${cron.name}" started`);
                    // Start polling for status
                    pollCronStatus(cronId);
                } else {
                    showToast('error', `Failed to execute cron`);
                    removeCronExecutionTask(cronId);
                }
            } catch (e) {
                // Gateway not reachable - queue for later
                cron.pendingExecution = true;
                renderCrons();
                
                // Update task to show it's queued
                const task = STATE.data.tasks.find(t => t.id === tempTaskId);
                if (task) {
                    task.title = `â³ ${cron.name}`;
                    task.description = `Queued for execution (Gateway offline)\n\nWill run on next sync.`;
                    task.processing = false;
                    renderTasks();
                }
                
                showToast('warning', `â³ Gateway offline - "${cron.name}" queued for next sync`, 5000);
                await saveCronsToGitHub(`Queue "${cron.name}" for execution (gateway offline)`);
            }
        }
        
        let cronPollingIntervals = {};
        
        function pollCronStatus(cronId) {
            // Poll every 2 seconds
            if (cronPollingIntervals[cronId]) {
                clearInterval(cronPollingIntervals[cronId]);
            }
            
            cronPollingIntervals[cronId] = setInterval(async () => {
                try {
                    await loadCronsFromGitHub();
                    const cron = STATE.crons?.find(c => c.id === cronId);
                    
                    if (cron && cron.lastStatus === 'ok') {
                        clearInterval(cronPollingIntervals[cronId]);
                        delete cronPollingIntervals[cronId];
                        showToast('success', `âœ… Cron "${cron.name}" completed`);
                        // Remove temporary task from In Progress
                        removeCronExecutionTask(cronId);
                        renderCrons();
                    }
                } catch (e) {
                    console.log('Polling error:', e);
                }
            }, 2000);
            
            // Stop polling after 5 minutes
            setTimeout(() => {
                if (cronPollingIntervals[cronId]) {
                    clearInterval(cronPollingIntervals[cronId]);
                    delete cronPollingIntervals[cronId];
                }
            }, 5 * 60 * 1000);
        }
        
        async function disableCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const gatewayUrl = getGatewayUrl();
            if (!gatewayUrl) {
                showToast('info', `Run: clawdbot cron update ${cronId} --disabled`, 8000);
                navigator.clipboard?.writeText(`clawdbot cron update ${cronId} --disabled`);
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: false })
                });
                
                if (response.ok) {
                    cron.enabled = false;
                    renderCrons();
                    showToast('success', `Disabled cron "${cron.name}"`);
                } else {
                    showToast('error', 'Failed to disable cron');
                }
            } catch (e) {
                showToast('info', `Run: clawdbot cron update ${cronId} --disabled`, 8000);
            }
        }

        // === CRON TO SCHEDULED CONVERSION ===
        function openCronToScheduledModal(cron) {
            if (!STATE.user) {
                showToast('error', 'Login required');
                return;
            }
            
            // Calculate next run time as default
            const nextRun = cron.state?.nextRunAtMs ? new Date(cron.state.nextRunAtMs) : new Date(Date.now() + 24 * 60 * 60 * 1000);
            const dateStr = nextRun.toISOString().slice(0, 16);
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-to-scheduled-dialog';
            
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ğŸ“… Convert to Scheduled Task</h2>
                        <button class="modal-close" onclick="closeCronToScheduledDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="cron-info" style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <div style="font-weight: 600; margin-bottom: 0.5rem;">${cron.emoji || 'ğŸ”„'} ${escapeHtml(cron.name)}</div>
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">${escapeHtml(cron.humanSchedule || cron.schedule || '')}</div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Run Once At</label>
                            <input type="datetime-local" class="form-input" id="cron-scheduled-datetime" value="${dateStr}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Original Cron Job</label>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                    <input type="radio" name="cron-action" value="disable" checked>
                                    <span>Disable recurring cron</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                    <input type="radio" name="cron-action" value="keep">
                                    <span>Keep recurring cron active (create copy)</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeCronToScheduledDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="convertCronToScheduled('${cron.id}')">Convert</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeCronToScheduledDialog() {
            const dialog = document.getElementById('cron-to-scheduled-dialog');
            if (dialog) dialog.remove();
        }
        
        async function convertCronToScheduled(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const datetime = document.getElementById('cron-scheduled-datetime').value;
            if (!datetime) {
                showToast('error', 'Please select a date and time');
                return;
            }
            
            const action = document.querySelector('input[name="cron-action"]:checked')?.value || 'disable';
            const scheduledAt = new Date(datetime).toISOString();
            const gatewayUrl = getGatewayUrl();
            
            // Create one-shot cron via Gateway API
            if (gatewayUrl) {
                try {
                    // Create new one-shot cron
                    const response = await fetch(gatewayUrl + '/api/crons', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: cron.name + ' (one-time)',
                            schedule: { kind: 'at', atMs: new Date(datetime).getTime() },
                            sessionTarget: cron.sessionTarget || 'main',
                            wakeMode: cron.wakeMode || 'next-heartbeat',
                            payload: cron.payload,
                            deleteAfterRun: true,
                            enabled: true
                        })
                    });
                    
                    if (response.ok) {
                        const newCronData = await response.json();
                        
                        // Optionally disable original cron
                        if (action === 'disable') {
                            await fetch(gatewayUrl + '/api/crons/' + cronId, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ enabled: false })
                            });
                            cron.enabled = false;
                        }
                        
                        // Create task in Scheduled column for UI visibility
                        const scheduledTask = {
                            id: 'cron_scheduled_' + (newCronData.id || Date.now()),
                            title: (cron.emoji || 'ğŸ”„') + ' ' + cron.name,
                            description: `Converted from recurring cron job.\n\nOriginal schedule: ${cron.humanSchedule || cron.schedule || 'N/A'}\n\nThis will run once at the scheduled time.`,
                            status: 'scheduled',
                            scheduledAt: scheduledAt,
                            priority: 'medium',
                            project: 'crons',
                            tags: ['cron-converted', 'scheduled'],
                            subtasks: [],
                            cronJobId: newCronData.id || null,  // Link to Gateway cron
                            originalCronId: cronId,             // Reference to original recurring cron
                            createdAt: new Date().toISOString()
                        };
                        STATE.data.tasks.push(scheduledTask);
                        renderScheduledTasks();
                        renderCrons();  // Update cron display (especially if disabled)
                        debouncedAutoSave(`Convert cron "${cron.name}" to scheduled task`);
                        
                        closeCronToScheduledDialog();
                        showToast('success', `ğŸ“… Scheduled for ${new Date(scheduledAt).toLocaleString()}`);
                    } else {
                        showToast('error', 'Failed to create scheduled task');
                    }
                } catch (e) {
                    console.error('Convert cron error:', e);
                    showToast('error', 'Gateway connection failed');
                }
            } else {
                // Fallback: Create scheduled task locally (will sync when Gateway is available)
                const scheduledTask = {
                    id: 'cron_scheduled_' + Date.now(),
                    title: (cron.emoji || 'ğŸ”„') + ' ' + cron.name,
                    description: `Converted from recurring cron job.\n\nOriginal schedule: ${cron.humanSchedule || cron.schedule || 'N/A'}\n\nâš ï¸ Gateway offline - will be synced when available.`,
                    status: 'scheduled',
                    scheduledAt: scheduledAt,
                    priority: 'medium',
                    project: 'crons',
                    tags: ['cron-converted', 'scheduled', 'pending-sync'],
                    subtasks: [],
                    originalCronId: cronId,
                    pendingGatewaySync: true,  // Flag for sync when Gateway comes online
                    createdAt: new Date().toISOString()
                };
                
                STATE.data.tasks.push(scheduledTask);
                
                // Mark original cron for disable if requested
                if (action === 'disable') {
                    cron.pendingDisable = true;
                }
                
                renderScheduledTasks();
                renderCrons();
                debouncedAutoSave(`Convert cron "${cron.name}" to scheduled task (offline)`);
                
                closeCronToScheduledDialog();
                showToast('warning', `ğŸ“… Scheduled locally - Gateway offline, will sync when available`, 5000);
            }
        }

        // === TASK 2: CRON EDITOR ===
        function openCronDetail(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) {
                showToast('error', 'Cron not found');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-editor-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 550px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ğŸ”„ Edit Cron Job</h2>
                        <button class="modal-close" onclick="closeCronEditor()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">Name</label>
                            <input type="text" class="form-input" id="cron-name" value="${escapeHtml(cron.name)}">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Prompt / Command</label>
                            <textarea class="form-input" id="cron-prompt" rows="4" placeholder="What should this cron do?">${escapeHtml(cron.prompt || '')}</textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Schedule</label>
                            <div id="cron-schedule-picker" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 0.75rem;">
                                <button type="button" class="btn btn-secondary cron-type-btn" data-type="daily" onclick="setCronScheduleType('daily')">ğŸ“… Daily</button>
                                <button type="button" class="btn btn-secondary cron-type-btn" data-type="weekly" onclick="setCronScheduleType('weekly')">ğŸ“† Weekly</button>
                                <button type="button" class="btn btn-secondary cron-type-btn" data-type="monthly" onclick="setCronScheduleType('monthly')">ğŸ—“ï¸ Monthly</button>
                                <button type="button" class="btn btn-secondary cron-type-btn" data-type="custom" onclick="setCronScheduleType('custom')">âš™ï¸ Custom</button>
                            </div>
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: center;">
                                <div id="cron-time-group" style="display: flex; align-items: center; gap: 0.5rem;">
                                    <label style="font-size: 0.85rem; color: var(--text-secondary);">Time:</label>
                                    <input type="time" class="form-input" id="cron-time" style="width: auto;" value="${extractTimeFromCron(cron.schedule)}">
                                </div>
                                <div id="cron-weekday-group" style="display: none; align-items: center; gap: 0.5rem;">
                                    <label style="font-size: 0.85rem; color: var(--text-secondary);">Day:</label>
                                    <select class="form-input" id="cron-weekday" style="width: auto;">
                                        <option value="1">Monday</option>
                                        <option value="2">Tuesday</option>
                                        <option value="3">Wednesday</option>
                                        <option value="4">Thursday</option>
                                        <option value="5">Friday</option>
                                        <option value="6">Saturday</option>
                                        <option value="0">Sunday</option>
                                    </select>
                                </div>
                                <div id="cron-monthday-group" style="display: none; align-items: center; gap: 0.5rem;">
                                    <label style="font-size: 0.85rem; color: var(--text-secondary);">Day of Month:</label>
                                    <input type="number" class="form-input" id="cron-monthday" style="width: 80px;" min="1" max="31" value="1">
                                </div>
                            </div>
                            <div id="cron-custom-group" style="display: none; margin-top: 0.5rem;">
                                <input type="text" class="form-input" id="cron-schedule" value="${cron.schedule}" placeholder="0 8 * * *">
                            </div>
                            <div class="form-hint" id="cron-schedule-hint" style="margin-top: 0.5rem;">
                                <strong id="cron-schedule-preview">${cron.scheduleHuman || cronToHuman(cron.schedule)}</strong>
                            </div>
                            <div id="cron-validation-error" style="color: var(--accent-red); font-size: 0.8rem; margin-top: 0.25rem; display: none;"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Timezone</label>
                            <select class="form-input" id="cron-timezone">
                                <option value="Europe/Berlin" ${cron.timezone === 'Europe/Berlin' ? 'selected' : ''}>Europe/Berlin</option>
                                <option value="UTC" ${cron.timezone === 'UTC' ? 'selected' : ''}>UTC</option>
                                <option value="America/New_York" ${cron.timezone === 'America/New_York' ? 'selected' : ''}>America/New_York</option>
                                <option value="America/Los_Angeles" ${cron.timezone === 'America/Los_Angeles' ? 'selected' : ''}>America/Los_Angeles</option>
                                <option value="Asia/Tokyo" ${cron.timezone === 'Asia/Tokyo' ? 'selected' : ''}>Asia/Tokyo</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Project</label>
                            <select class="form-input" id="cron-project">
                                <option value="">â€” No Project â€”</option>
                                ${(STATE.data?.projects || []).map(p => 
                                    `<option value="${p.id}" ${cron.project === p.id ? 'selected' : ''}>${p.icon || ''} ${p.name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Tags</label>
                            <div id="cron-tags-chips" class="tags-chips-container" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;"></div>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" class="form-input" id="new-cron-tag-input" placeholder="Add tag..." style="flex: 1;" onkeydown="if(event.key==='Enter'){event.preventDefault();addCronTag();}">
                                <button class="btn btn-secondary btn-small" onclick="addCronTag()">+ Add</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="checkbox" id="cron-enabled" ${cron.enabled ? 'checked' : ''}>
                                <span>Enabled</span>
                            </label>
                        </div>
                        <div class="form-group" style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                            <label class="form-label" style="margin-bottom: 0.5rem;">ğŸ“… Next Run</label>
                            <div id="cron-next-runs" style="font-size: 0.85rem; color: var(--text-secondary);">
                                ${generateNextRuns(cron.schedule, cron.timezone)}
                            </div>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-secondary btn-small" onclick="toggleCronHistory('${cronId}')" style="width: 100%;">
                                ğŸ“‹ Run History
                            </button>
                            <div id="cron-history" style="display: none; margin-top: 0.75rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px; max-height: 300px; overflow-y: auto;">
                                <div id="cron-history-content" style="font-size: 0.85rem;">Loading...</div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" style="margin-right: auto;" onclick="convertCronToTask('${cronId}')">ğŸ“‹ As Task</button>
                        <button class="btn btn-secondary btn-small" onclick="duplicateCronJob('${cronId}')" title="Duplicate this cron job">ğŸ“„ Duplicate</button>
                        <button class="btn btn-danger btn-small" onclick="deleteCronJob('${cronId}')" title="Delete this cron job">ğŸ—‘ï¸ Delete</button>
                        <button class="btn btn-secondary" onclick="closeCronEditor()">Cancel</button>
                        <button class="btn btn-primary" onclick="saveCronChanges('${cronId}')">Save Changes</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // Initialize schedule picker based on current cron
            initCronSchedulePicker(cron.schedule);
            
            // Initialize tags
            currentCronTags = [...(cron.tags || [])];
            renderCronTagChips();
            
            // Add event listeners for schedule changes
            document.getElementById('cron-time')?.addEventListener('change', updateCronFromPicker);
            document.getElementById('cron-weekday')?.addEventListener('change', updateCronFromPicker);
            document.getElementById('cron-monthday')?.addEventListener('change', updateCronFromPicker);
            document.getElementById('cron-schedule')?.addEventListener('input', function() {
                validateCronSchedule(this.value);
            });
        }
        
        function extractTimeFromCron(schedule) {
            const parts = schedule.trim().split(/\s+/);
            if (parts.length >= 2) {
                const minute = parts[0].padStart(2, '0');
                const hour = parts[1].padStart(2, '0');
                if (!isNaN(parseInt(minute)) && !isNaN(parseInt(hour))) {
                    return `${hour}:${minute}`;
                }
            }
            return '08:00';
        }
        
        function detectCronType(schedule) {
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) return 'custom';
            const [minute, hour, day, month, weekday] = parts;
            
            if (day === '*' && month === '*' && weekday === '*') return 'daily';
            if (day === '*' && month === '*' && weekday !== '*') return 'weekly';
            if (day !== '*' && month === '*' && weekday === '*') return 'monthly';
            return 'custom';
        }
        
        function initCronSchedulePicker(schedule) {
            const type = detectCronType(schedule);
            const parts = schedule.trim().split(/\s+/);
            
            // Highlight the active type button
            document.querySelectorAll('.cron-type-btn').forEach(btn => {
                btn.classList.toggle('btn-primary', btn.dataset.type === type);
                btn.classList.toggle('btn-secondary', btn.dataset.type !== type);
            });
            
            // Show/hide relevant fields
            document.getElementById('cron-time-group').style.display = type !== 'custom' ? 'flex' : 'none';
            document.getElementById('cron-weekday-group').style.display = type === 'weekly' ? 'flex' : 'none';
            document.getElementById('cron-monthday-group').style.display = type === 'monthly' ? 'flex' : 'none';
            document.getElementById('cron-custom-group').style.display = type === 'custom' ? 'block' : 'none';
            
            // Set values from current schedule
            if (type === 'weekly' && parts.length === 5) {
                document.getElementById('cron-weekday').value = parts[4];
            }
            if (type === 'monthly' && parts.length === 5) {
                document.getElementById('cron-monthday').value = parts[2];
            }
            
            window.cronEditorType = type;
        }
        
        function setCronScheduleType(type) {
            window.cronEditorType = type;
            
            // Update button states
            document.querySelectorAll('.cron-type-btn').forEach(btn => {
                btn.classList.toggle('btn-primary', btn.dataset.type === type);
                btn.classList.toggle('btn-secondary', btn.dataset.type !== type);
            });
            
            // Show/hide fields
            document.getElementById('cron-time-group').style.display = type !== 'custom' ? 'flex' : 'none';
            document.getElementById('cron-weekday-group').style.display = type === 'weekly' ? 'flex' : 'none';
            document.getElementById('cron-monthday-group').style.display = type === 'monthly' ? 'flex' : 'none';
            document.getElementById('cron-custom-group').style.display = type === 'custom' ? 'block' : 'none';
            
            updateCronFromPicker();
        }
        
        function updateCronFromPicker() {
            const type = window.cronEditorType || 'daily';
            const time = document.getElementById('cron-time')?.value || '08:00';
            const [hour, minute] = time.split(':').map(s => parseInt(s, 10));
            
            let schedule;
            let scheduleDesc;
            
            if (type === 'daily') {
                schedule = `${minute} ${hour} * * *`;
                scheduleDesc = `Daily at ${time}`;
            } else if (type === 'weekly') {
                const weekday = document.getElementById('cron-weekday')?.value || '1';
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                schedule = `${minute} ${hour} * * ${weekday}`;
                scheduleDesc = `Every ${dayNames[parseInt(weekday)]} at ${time}`;
            } else if (type === 'monthly') {
                const monthday = document.getElementById('cron-monthday')?.value || '1';
                schedule = `${minute} ${hour} ${monthday} * *`;
                scheduleDesc = `Monthly on day ${monthday} at ${time}`;
            } else {
                schedule = document.getElementById('cron-schedule')?.value || '0 8 * * *';
                scheduleDesc = cronToHuman(schedule);
            }
            
            // Update hidden cron-schedule field if not in custom mode
            if (type !== 'custom') {
                const scheduleInput = document.getElementById('cron-schedule');
                if (scheduleInput) scheduleInput.value = schedule;
            }
            
            // Update preview
            const preview = document.getElementById('cron-schedule-preview');
            if (preview) preview.textContent = scheduleDesc;
            
            // Update next runs
            const nextRunsEl = document.getElementById('cron-next-runs');
            const timezone = document.getElementById('cron-timezone')?.value || 'Europe/Berlin';
            if (nextRunsEl) nextRunsEl.innerHTML = generateNextRuns(schedule, timezone);
        }
        
        async function deleteCronJob(cronId) {
            if (!confirm('Are you sure you want to delete this cron job? This action cannot be undone.')) {
                return;
            }
            
            const gatewayUrl = getGatewayUrl();
            
            if (gatewayUrl) {
                try {
                    const token = localStorage.getItem(`gateway_token_${btoa(gatewayUrl)}`);
                    const response = await fetch(`${gatewayUrl}/api/cron/${cronId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        showToast('success', 'Cron job deleted');
                        // Remove from local state
                        STATE.crons = STATE.crons.filter(c => c.id !== cronId);
                        closeCronEditor();
                        renderCrons();
                    } else {
                        const error = await response.json().catch(() => ({}));
                        showToast('error', error.error || 'Failed to delete cron job');
                    }
                } catch (err) {
                    showToast('error', 'Failed to delete: ' + err.message);
                }
            } else {
                // Local only - remove from STATE
                STATE.crons = STATE.crons.filter(c => c.id !== cronId);
                showToast('success', 'Cron job deleted locally');
                closeCronEditor();
                renderCrons();
            }
        }
        
        async function toggleCronHistory(cronId) {
            const historyDiv = document.getElementById('cron-history');
            const contentDiv = document.getElementById('cron-history-content');
            
            if (historyDiv.style.display === 'none') {
                historyDiv.style.display = 'block';
                contentDiv.innerHTML = '<span style="color: var(--text-secondary);">Loading...</span>';
                
                let runs = [];
                
                // First try: Load from synced cron-runs.json (GitHub)
                if (STATE.cronRuns && STATE.cronRuns[cronId]) {
                    runs = STATE.cronRuns[cronId];
                } else {
                    // Try loading from GitHub
                    try {
                        const runsData = await loadCronRunsFromGitHub();
                        if (runsData && runsData[cronId]) {
                            runs = runsData[cronId];
                        }
                    } catch (e) {
                        console.log('Could not load runs from GitHub:', e);
                    }
                }
                
                // Second try: Gateway API (if configured)
                const gatewayUrl = getGatewayUrl();
                if (gatewayUrl && runs.length === 0) {
                    try {
                        const token = localStorage.getItem(`gateway_token_${btoa(gatewayUrl)}`);
                        const response = await fetch(`${gatewayUrl}/api/cron/${cronId}/runs`, {
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        if (response.ok) {
                            const data = await response.json();
                            runs = data.entries || [];
                        }
                    } catch (e) {
                        console.log('Gateway not available:', e);
                    }
                }
                
                // Render runs
                if (runs.length === 0) {
                    contentDiv.innerHTML = '<span style="color: var(--text-secondary);">No runs yet</span>';
                } else {
                    contentDiv.innerHTML = runs.slice(0, 10).map(run => {
                        const date = new Date(run.ts || run.runAtMs);
                        const statusIcon = run.status === 'ok' ? 'âœ…' : 'âŒ';
                        const duration = run.durationMs ? `${(run.durationMs / 1000).toFixed(1)}s` : '-';
                        const dateStr = date.toLocaleString('de-DE', { 
                            day: '2-digit', month: '2-digit', year: '2-digit',
                            hour: '2-digit', minute: '2-digit'
                        });
                        const summary = run.summary ? run.summary.substring(0, 100) + (run.summary.length > 100 ? '...' : '') : '';
                        
                        return `
                            <div style="padding: 0.5rem 0; border-bottom: 1px solid var(--border); ${runs.indexOf(run) === runs.length - 1 ? 'border-bottom: none;' : ''}">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span>${statusIcon} ${dateStr}</span>
                                    <span style="color: var(--text-secondary);">${duration}</span>
                                </div>
                                ${summary ? `<div style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(summary.replace(/\n/g, ' '))}</div>` : ''}
                            </div>
                        `;
                    }).join('');
                }
            } else {
                historyDiv.style.display = 'none';
            }
        }
        
        async function loadCronRunsFromGitHub() {
            if (!STATE.githubToken || !STATE.repoOwner || !STATE.repoName) {
                return null;
            }
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${STATE.repoOwner}/${STATE.repoName}/contents/data/cron-runs.json`,
                    {
                        headers: {
                            'Authorization': `Bearer ${STATE.githubToken}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const content = JSON.parse(atob(data.content));
                    STATE.cronRuns = content.runs || {};
                    return STATE.cronRuns;
                }
            } catch (e) {
                console.log('Failed to load cron runs from GitHub:', e);
            }
            return null;
        }
        
        async function duplicateCronJob(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) {
                showToast('error', 'Cron not found');
                return;
            }
            
            const newCron = {
                ...cron,
                id: crypto.randomUUID ? crypto.randomUUID() : 'cron_' + Date.now(),
                name: cron.name + ' (Copy)',
                enabled: false, // Start disabled to avoid immediate execution
                createdAt: new Date().toISOString()
            };
            
            const gatewayUrl = getGatewayUrl();
            
            if (gatewayUrl) {
                try {
                    const token = localStorage.getItem(`gateway_token_${btoa(gatewayUrl)}`);
                    const response = await fetch(`${gatewayUrl}/api/crons`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: newCron.name,
                            prompt: newCron.prompt,
                            schedule: newCron.schedule,
                            timezone: newCron.timezone,
                            enabled: newCron.enabled
                        })
                    });
                    
                    if (response.ok) {
                        const created = await response.json();
                        STATE.crons.push(created.job || created);
                        showToast('success', `Duplicated as "${newCron.name}"`);
                        closeCronEditor();
                        renderCrons();
                        // Open the new cron for editing
                        setTimeout(() => openCronEditor(created.job?.id || created.id), 300);
                    } else {
                        const error = await response.json().catch(() => ({}));
                        showToast('error', error.error || 'Failed to duplicate cron job');
                    }
                } catch (err) {
                    showToast('error', 'Failed to duplicate: ' + err.message);
                }
            } else {
                // Local only
                STATE.crons = STATE.crons || [];
                STATE.crons.push(newCron);
                showToast('success', `Duplicated as "${newCron.name}" (local only)`);
                closeCronEditor();
                renderCrons();
                setTimeout(() => openCronEditor(newCron.id), 300);
            }
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            return text.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;');
        }
        
        function validateCronSchedule(schedule) {
            const errorEl = document.getElementById('cron-validation-error');
            const hintEl = document.getElementById('cron-schedule-hint');
            const nextRunsEl = document.getElementById('cron-next-runs');
            
            // Simple cron validation (5 fields)
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) {
                errorEl.textContent = 'Cron expression must have 5 fields (minute hour day month weekday)';
                errorEl.style.display = 'block';
                return false;
            }
            
            // Validate each field
            const ranges = [
                { min: 0, max: 59, name: 'minute' },
                { min: 0, max: 23, name: 'hour' },
                { min: 1, max: 31, name: 'day' },
                { min: 1, max: 12, name: 'month' },
                { min: 0, max: 7, name: 'weekday' }
            ];
            
            for (let i = 0; i < 5; i++) {
                if (!isValidCronField(parts[i], ranges[i])) {
                    errorEl.textContent = `Invalid ${ranges[i].name} field: ${parts[i]}`;
                    errorEl.style.display = 'block';
                    return false;
                }
            }
            
            errorEl.style.display = 'none';
            const humanReadable = cronToHuman(schedule);
            hintEl.innerHTML = `Human readable: <strong>${humanReadable}</strong>`;
            nextRunsEl.innerHTML = generateNextRuns(schedule, document.getElementById('cron-timezone')?.value || 'Europe/Berlin');
            return true;
        }
        
        function isValidCronField(field, range) {
            if (field === '*') return true;
            if (field.includes('/')) {
                const [base, step] = field.split('/');
                if (base !== '*' && !isValidCronField(base, range)) return false;
                const stepNum = parseInt(step);
                return !isNaN(stepNum) && stepNum > 0;
            }
            if (field.includes('-')) {
                const [start, end] = field.split('-').map(Number);
                return !isNaN(start) && !isNaN(end) && start >= range.min && end <= range.max && start <= end;
            }
            if (field.includes(',')) {
                return field.split(',').every(f => isValidCronField(f.trim(), range));
            }
            const num = parseInt(field);
            return !isNaN(num) && num >= range.min && num <= range.max;
        }
        
        function cronToHuman(schedule) {
            const parts = schedule.trim().split(/\s+/);
            if (parts.length !== 5) return schedule;
            
            const [minute, hour, day, month, weekday] = parts;
            
            // Simple patterns
            if (minute !== '*' && hour !== '*' && day === '*' && month === '*' && weekday === '*') {
                return `Daily at ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
            }
            if (minute !== '*' && hour !== '*' && day === '*' && month === '*' && weekday !== '*') {
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayName = days[parseInt(weekday)] || weekday;
                return `${dayName} at ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
            }
            if (minute === '0' && hour === '*' && day === '*' && month === '*' && weekday === '*') {
                return 'Every hour';
            }
            if (minute.includes('/')) {
                const interval = minute.split('/')[1];
                return `Every ${interval} minutes`;
            }
            
            return schedule;
        }
        
        function generateNextRuns(schedule, timezone) {
            try {
                const runs = [];
                const now = new Date();
                
                const parts = schedule.trim().split(/\s+/);
                if (parts.length !== 5) return 'Invalid schedule';
                
                const [cronMin, cronHour, cronDay, cronMonth, cronWeekday] = parts;
                
                // Parse fixed values from cron
                const targetMin = cronMin !== '*' ? parseInt(cronMin) : null;
                const targetHour = cronHour !== '*' ? parseInt(cronHour) : null;
                const targetDay = cronDay !== '*' ? parseInt(cronDay) : null;
                const targetWeekday = cronWeekday !== '*' ? parseInt(cronWeekday) : null;
                
                // Start from now, but set to target time if fixed
                let checkDate = new Date(now);
                if (targetMin !== null) checkDate.setMinutes(targetMin, 0, 0);
                if (targetHour !== null) checkDate.setHours(targetHour);
                
                // If this time already passed today, start tomorrow
                if (checkDate <= now) {
                    checkDate.setDate(checkDate.getDate() + 1);
                }
                
                // Find next run (max 365 days search)
                for (let i = 0; i < 365 && runs.length < 1; i++) {
                    const day = checkDate.getDate();
                    const month = checkDate.getMonth() + 1;
                    const weekday = checkDate.getDay();
                    
                    const dayMatch = cronDay === '*' || parseInt(cronDay) === day;
                    const monthMatch = cronMonth === '*' || parseInt(cronMonth) === month;
                    const weekdayMatch = cronWeekday === '*' || parseInt(cronWeekday) === weekday;
                    
                    if (dayMatch && monthMatch && weekdayMatch) {
                        runs.push(checkDate.toLocaleString('de-DE', { 
                            weekday: 'short', 
                            day: '2-digit', 
                            month: '2-digit', 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }));
                    }
                    
                    // Move to next day
                    checkDate.setDate(checkDate.getDate() + 1);
                }
                
                return runs.length > 0 ? runs[0] : 'Could not calculate next run';
            } catch (e) {
                console.error('generateNextRuns error:', e);
                return 'Error calculating runs';
            }
        }
        
        function matchesCronField(field, value) {
            if (field === '*') return true;
            if (field.includes('/')) {
                const [base, step] = field.split('/');
                const stepNum = parseInt(step);
                if (base === '*') return value % stepNum === 0;
                return false; // Simplified
            }
            if (field.includes(',')) {
                return field.split(',').some(f => matchesCronField(f.trim(), value));
            }
            if (field.includes('-')) {
                const [start, end] = field.split('-').map(Number);
                return value >= start && value <= end;
            }
            return parseInt(field) === value;
        }
        
        function closeCronEditor() {
            const dialog = document.getElementById('cron-editor-dialog');
            if (dialog) dialog.remove();
        }
        
        async function saveCronChanges(cronId) {
            // Ensure schedule is updated from picker before reading
            updateCronFromPicker();
            
            const name = document.getElementById('cron-name').value.trim();
            const prompt = document.getElementById('cron-prompt').value.trim();
            const schedule = document.getElementById('cron-schedule').value.trim();
            const timezone = document.getElementById('cron-timezone').value;
            const project = document.getElementById('cron-project')?.value || '';
            const enabled = document.getElementById('cron-enabled').checked;
            const tags = [...currentCronTags];
            
            if (!name) {
                showToast('error', 'Name is required');
                return;
            }
            
            if (!validateCronSchedule(schedule)) {
                showToast('error', 'Invalid cron schedule');
                return;
            }
            
            const gatewayUrl = getGatewayUrl();
            if (!gatewayUrl) {
                // Save locally and show CLI command
                const cron = STATE.crons?.find(c => c.id === cronId);
                if (cron) {
                    cron.name = name;
                    cron.prompt = prompt;
                    cron.schedule = schedule;
                    cron.scheduleHuman = cronToHuman(schedule);
                    cron.timezone = timezone;
                    cron.project = project;
                    cron.tags = tags;
                    cron.enabled = enabled;
                }
                closeCronEditor();
                renderCrons();
                showToast('info', 'Gateway not available. Changes saved locally only.');
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons/' + cronId, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, prompt, schedule, timezone, project, tags, enabled })
                });
                
                if (response.ok) {
                    const cron = STATE.crons?.find(c => c.id === cronId);
                    if (cron) {
                        cron.name = name;
                        cron.prompt = prompt;
                        cron.schedule = schedule;
                        cron.scheduleHuman = cronToHuman(schedule);
                        cron.timezone = timezone;
                        cron.project = project;
                        cron.tags = tags;
                        cron.enabled = enabled;
                    }
                    closeCronEditor();
                    renderCrons();
                    showToast('success', `Cron "${name}" updated`);
                } else {
                    showToast('error', 'Failed to save cron');
                }
            } catch (e) {
                showToast('info', 'Gateway not available. Changes saved locally only.');
                const cron = STATE.crons?.find(c => c.id === cronId);
                if (cron) {
                    cron.name = name;
                    cron.prompt = prompt;
                    cron.schedule = schedule;
                    cron.scheduleHuman = cronToHuman(schedule);
                    cron.timezone = timezone;
                    cron.tags = tags;
                    cron.enabled = enabled;
                }
                closeCronEditor();
                renderCrons();
            }
        }

        // === TASK 3: TASK â†’ CRON ===
        function openTaskToCronWizard(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'task-to-cron-wizard';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title">â° Convert to Cron</h2>
                        <button class="modal-close" onclick="closeTaskToCronWizard()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="steps" style="margin-bottom: 1rem;">
                            <div class="step">
                                <span class="step-number">1</span>
                                <div class="step-content">
                                    <div class="step-title">Choose Schedule Type</div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="wizard-step-1">
                            <div style="display: grid; gap: 0.5rem;">
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('daily')">
                                    ğŸ“… Daily
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('weekly')">
                                    ğŸ“† Weekly
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('monthly')">
                                    ğŸ—“ï¸ Monthly
                                </button>
                                <button class="btn btn-secondary" style="justify-content: flex-start;" onclick="setScheduleType('custom')">
                                    âš™ï¸ Custom Cron Expression
                                </button>
                            </div>
                        </div>
                        
                        <div id="wizard-step-2" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Time</label>
                                <input type="time" class="form-input" id="wizard-time" value="08:00">
                            </div>
                            <div class="form-group" id="wizard-weekday-group" style="display: none;">
                                <label class="form-label">Day of Week</label>
                                <select class="form-input" id="wizard-weekday">
                                    <option value="1">Monday</option>
                                    <option value="2">Tuesday</option>
                                    <option value="3">Wednesday</option>
                                    <option value="4">Thursday</option>
                                    <option value="5">Friday</option>
                                    <option value="6">Saturday</option>
                                    <option value="0">Sunday</option>
                                </select>
                            </div>
                            <div class="form-group" id="wizard-monthday-group" style="display: none;">
                                <label class="form-label">Day of Month</label>
                                <input type="number" class="form-input" id="wizard-monthday" min="1" max="31" value="1">
                            </div>
                            <div class="form-group" id="wizard-custom-group" style="display: none;">
                                <label class="form-label">Cron Expression</label>
                                <input type="text" class="form-input" id="wizard-custom-cron" placeholder="0 8 * * *">
                            </div>
                        </div>
                        
                        <div id="wizard-step-3" style="display: none;">
                            <div class="form-group">
                                <label class="form-label">Cron Name</label>
                                <input type="text" class="form-input" id="cron-wizard-title" value="${task.title}">
                            </div>
                            <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                                <strong>Summary:</strong>
                                <div id="wizard-summary" style="margin-top: 0.5rem; color: var(--text-secondary);"></div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" id="wizard-back" onclick="wizardBack()" style="display: none;">Back</button>
                        <button class="btn btn-secondary" onclick="closeTaskToCronWizard()">Cancel</button>
                        <button class="btn btn-primary" id="wizard-next" onclick="wizardNext('${taskId}')" style="display: none;">Next</button>
                        <button class="btn btn-primary" id="wizard-create" onclick="createCronFromTask('${taskId}')" style="display: none;">Create Cron</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            window.wizardState = { step: 1, type: null, taskId };
        }
        
        function setScheduleType(type) {
            window.wizardState.type = type;
            document.getElementById('wizard-step-1').style.display = 'none';
            document.getElementById('wizard-step-2').style.display = 'block';
            document.getElementById('wizard-back').style.display = 'inline-flex';
            document.getElementById('wizard-next').style.display = 'inline-flex';
            
            // Show relevant fields
            document.getElementById('wizard-weekday-group').style.display = type === 'weekly' ? 'block' : 'none';
            document.getElementById('wizard-monthday-group').style.display = type === 'monthly' ? 'block' : 'none';
            document.getElementById('wizard-custom-group').style.display = type === 'custom' ? 'block' : 'none';
            
            window.wizardState.step = 2;
        }
        
        function wizardBack() {
            if (window.wizardState.step === 2) {
                document.getElementById('wizard-step-2').style.display = 'none';
                document.getElementById('wizard-step-1').style.display = 'block';
                document.getElementById('wizard-back').style.display = 'none';
                document.getElementById('wizard-next').style.display = 'none';
                window.wizardState.step = 1;
            } else if (window.wizardState.step === 3) {
                document.getElementById('wizard-step-3').style.display = 'none';
                document.getElementById('wizard-step-2').style.display = 'block';
                document.getElementById('wizard-next').style.display = 'inline-flex';
                document.getElementById('wizard-create').style.display = 'none';
                window.wizardState.step = 2;
            }
        }
        
        function wizardNext(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            const type = window.wizardState.type;
            const time = document.getElementById('wizard-time').value;
            const [hour, minute] = time.split(':');
            
            let schedule;
            let scheduleDesc;
            
            if (type === 'daily') {
                schedule = `${minute} ${hour} * * *`;
                scheduleDesc = `Daily at ${time}`;
            } else if (type === 'weekly') {
                const weekday = document.getElementById('wizard-weekday').value;
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                schedule = `${minute} ${hour} * * ${weekday}`;
                scheduleDesc = `Every ${dayNames[parseInt(weekday)]} at ${time}`;
            } else if (type === 'monthly') {
                const monthday = document.getElementById('wizard-monthday').value;
                schedule = `${minute} ${hour} ${monthday} * *`;
                scheduleDesc = `Monthly on day ${monthday} at ${time}`;
            } else {
                schedule = document.getElementById('wizard-custom-cron').value;
                scheduleDesc = schedule;
            }
            
            window.wizardState.schedule = schedule;
            window.wizardState.scheduleDesc = scheduleDesc;
            
            // Build prompt from task
            let prompt = task.description || task.title;
            if (task.subtasks && task.subtasks.length > 0) {
                prompt += '\n\nSubtasks:\n' + task.subtasks.map(s => `- ${s.title}`).join('\n');
            }
            window.wizardState.prompt = prompt;
            
            // Show summary
            document.getElementById('wizard-step-2').style.display = 'none';
            document.getElementById('wizard-step-3').style.display = 'block';
            document.getElementById('wizard-next').style.display = 'none';
            document.getElementById('wizard-create').style.display = 'inline-flex';
            
            document.getElementById('wizard-summary').innerHTML = `
                <strong>Name:</strong> ${task.title}<br>
                <strong>Schedule:</strong> ${scheduleDesc}<br>
                <strong>Cron:</strong> <code>${schedule}</code><br>
                <strong>Original task will be archived.</strong>
            `;
            
            window.wizardState.step = 3;
        }
        
        async function createCronFromTask(taskId) {
            const task = STATE.data.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Read current values from wizard inputs (not stored state)
            const titleInput = document.getElementById('cron-wizard-title');
            const cronTitle = titleInput ? titleInput.value.trim() : task.title;
            const { schedule, scheduleDesc, prompt } = window.wizardState;
            const gatewayUrl = getGatewayUrl();
            
            // Helper to create cron locally and save to GitHub
            async function createLocalCron() {
                const newCron = {
                    id: crypto.randomUUID ? crypto.randomUUID() : 'cron_' + Date.now(),
                    name: cronTitle,
                    prompt: prompt,
                    schedule: schedule,
                    scheduleHuman: scheduleDesc,
                    timezone: 'Europe/Berlin',
                    enabled: true,
                    pending: true, // Mark as pending - needs Gateway sync
                    createdAt: new Date().toISOString()
                };
                
                STATE.crons = STATE.crons || [];
                STATE.crons.push(newCron);
                
                // Archive original task
                task.archived = true;
                task.archivedAt = new Date().toISOString();
                task.archivedReason = 'Converted to cron: ' + newCron.id;
                
                // Save crons to GitHub
                const cronsSaved = await saveCronsToGitHub(`Add cron "${cronTitle}" (pending Gateway sync)`);
                
                closeTaskToCronWizard();
                renderCrons();
                renderTasks();
                debouncedAutoSave(`Convert task "${task.title}" to cron`);
                
                if (cronsSaved) {
                    showToast('success', `âœ“ Cron "${cronTitle}" saved (will activate on next sync)`);
                } else {
                    showToast('warning', `Cron created locally but failed to save to GitHub`);
                }
                return true;
            }
            
            if (!gatewayUrl) {
                // No Gateway available - save locally to GitHub
                await createLocalCron();
                return;
            }
            
            try {
                const response = await fetch(gatewayUrl + '/api/crons', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: cronTitle,
                        prompt: prompt,
                        schedule: schedule,
                        scheduleHuman: scheduleDesc,
                        timezone: 'Europe/Berlin',
                        enabled: true
                    })
                });
                
                if (response.ok) {
                    const newCron = await response.json();
                    STATE.crons = STATE.crons || [];
                    STATE.crons.push(newCron);
                    
                    // Archive original task
                    task.archived = true;
                    task.archivedAt = new Date().toISOString();
                    task.archivedReason = 'Converted to cron: ' + newCron.id;
                    
                    closeTaskToCronWizard();
                    renderCrons();
                    renderTasks();
                    debouncedAutoSave(`Convert task "${task.title}" to cron`);
                    showToast('success', `Created cron "${cronTitle}"`);
                } else {
                    showToast('error', 'Failed to create cron via Gateway');
                }
            } catch (e) {
                // Gateway not reachable - fallback to local save
                console.log('Gateway not reachable, saving locally:', e);
                await createLocalCron();
            }
        }
        
        function closeTaskToCronWizard() {
            const dialog = document.getElementById('task-to-cron-wizard');
            if (dialog) dialog.remove();
            delete window.wizardState;
        }

        // === TASK 4: CRON â†’ TASK ===
        function convertCronToTask(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-overlay visible';
            dialog.id = 'cron-to-task-dialog';
            dialog.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">ğŸ“‹ Convert to Task</h2>
                        <button class="modal-close" onclick="closeCronToTaskDialog()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 1rem;">Create a task from cron "${cron.name}"?</p>
                        <div style="background: var(--bg-secondary); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <strong>Task will include:</strong>
                            <div style="color: var(--text-secondary); margin-top: 0.5rem;">
                                Schedule: ${cron.scheduleHuman || cron.schedule}<br>
                                ${cron.prompt ? `Prompt: ${cron.prompt.substring(0, 100)}${cron.prompt.length > 100 ? '...' : ''}` : ''}
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">What to do with the cron?</label>
                            <select class="form-input" id="cron-action-select">
                                <option value="disable">Disable cron</option>
                                <option value="delete">Delete cron</option>
                                <option value="keep">Keep cron active</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeCronToTaskDialog()">Cancel</button>
                        <button class="btn btn-primary" onclick="executeConvertCronToTask('${cronId}')">Create Task</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
        }
        
        function closeCronToTaskDialog() {
            const dialog = document.getElementById('cron-to-task-dialog');
            if (dialog) dialog.remove();
        }
        
        async function executeConvertCronToTask(cronId) {
            const cron = STATE.crons?.find(c => c.id === cronId);
            if (!cron) return;
            
            const action = document.getElementById('cron-action-select').value;
            
            // Create task
            const newTask = {
                id: 'task_' + Date.now(),
                title: cron.name,
                description: `Schedule: ${cron.scheduleHuman || cron.schedule}\n\n${cron.prompt || ''}`,
                status: 'backlog',
                project: 'system',
                tags: ['from-cron'],
                subtasks: [],
                priority: 'medium',
                createdAt: new Date().toISOString(),
                createdFromCron: cronId
            };
            
            STATE.data.tasks.push(newTask);
            
            // Handle cron action
            if (action === 'disable') {
                await disableCronJob(cronId);
            } else if (action === 'delete') {
                const gatewayUrl = getGatewayUrl();
                if (gatewayUrl) {
                    try {
                        await fetch(gatewayUrl + '/api/crons/' + cronId, { method: 'DELETE' });
                        STATE.crons = STATE.crons.filter(c => c.id !== cronId);
                    } catch (e) {
                        console.log('Could not delete cron via API');
                        showToast('info', `Run: clawdbot cron remove ${cronId}`, 8000);
                    }
                } else {
                    showToast('info', `Run: clawdbot cron remove ${cronId}`, 8000);
                    navigator.clipboard?.writeText(`clawdbot cron remove ${cronId}`);
                }
            }
            
            closeCronToTaskDialog();
            closeCronEditor();
            renderCrons();
            renderTasks();
            debouncedAutoSave(`Create task from cron "${cron.name}"`);
            showToast('success', `Created task "${cron.name}"`);
        }

        // === COLLABORATORS / PEOPLE ===
        let collaboratorsLoaded = false;

        async function loadCollaborators() {
            if (collaboratorsLoaded) return;

            const container = document.getElementById('collaborators-container');
            const statsContainer = document.getElementById('people-stats');

            // Show loading
            container.innerHTML = `
                <div class="people-loading">
                    <div class="spinner"></div>
                    <p>Loading collaborators...</p>
                </div>
            `;

            const token = STATE.token || localStorage.getItem('github_token');

            if (!token) {
                container.innerHTML = `
                    <div class="people-empty">
                        <div class="people-empty-icon">ğŸ”’</div>
                        <p>Connect to GitHub to see team members</p>
                    </div>
                `;
                return;
            }

            try {
                const response = await fetch(
                    `https://api.github.com/repos/${CONFIG.owner}/${CONFIG.repo}/collaborators`,
                    {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }

                const collaborators = await response.json();
                collaboratorsLoaded = true;

                if (collaborators.length === 0) {
                    container.innerHTML = `
                        <div class="people-empty">
                            <div class="people-empty-icon">ğŸ‘¤</div>
                            <p>No collaborators found</p>
                        </div>
                    `;
                    return;
                }

                // Count by role
                const roleCounts = { admin: 0, maintain: 0, write: 0, triage: 0, read: 0 };
                collaborators.forEach(c => {
                    const role = c.role_name?.toLowerCase() || 'read';
                    if (roleCounts[role] !== undefined) roleCounts[role]++;
                });

                // Render stats
                statsContainer.innerHTML = `
                    <div class="people-stat"><strong>${collaborators.length}</strong> members</div>
                    ${roleCounts.admin > 0 ? `<div class="people-stat"><strong>${roleCounts.admin}</strong> admins</div>` : ''}
                `;

                // Render collaborator cards
                const cardsHtml = collaborators.map(c => {
                    const role = c.role_name?.toLowerCase() || 'read';
                    const roleLabel = role.charAt(0).toUpperCase() + role.slice(1);
                    const roleIcon = {
                        admin: 'ğŸ‘‘',
                        maintain: 'ğŸ”§',
                        write: 'âœï¸',
                        triage: 'ğŸ“‹',
                        read: 'ğŸ‘ï¸'
                    }[role] || 'ğŸ‘¤';

                    return `
                        <div class="collaborator-card">
                            <img class="collaborator-avatar" src="${c.avatar_url}" alt="${c.login}" loading="lazy">
                            <div class="collaborator-info">
                                <div class="collaborator-name">${c.login}</div>
                                <div class="collaborator-username">
                                    <a href="${c.html_url}" target="_blank" rel="noopener">@${c.login}</a>
                                </div>
                                <span class="collaborator-role role-${role}">${roleIcon} ${roleLabel}</span>
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = `<div class="collaborators-grid">${cardsHtml}</div>`;

            } catch (error) {
                console.error('Failed to load collaborators:', error);
                container.innerHTML = `
                    <div class="people-empty">
                        <div class="people-empty-icon">âš ï¸</div>
                        <p>Failed to load collaborators</p>
                        <p style="font-size: 0.875rem; margin-top: 0.5rem;">${error.message}</p>
                    </div>
                `;
            }
        }

        // Extend switchView to load collaborators when People tab is selected
        const originalSwitchView = switchView;
        switchView = function(viewName) {
            originalSwitchView(viewName);
            if (viewName === 'people') {
                loadCollaborators();
            }
        };

        // === EVENT DELEGATION FOR KANBAN BOARD ===
        // This provides a centralized event handler for common actions
        // Uses data-action and data-id attributes instead of inline onclick
        document.addEventListener('click', (e) => {
            // Find closest element with data-action
            const actionElement = e.target.closest('[data-action]');
            if (!actionElement) return;

            const action = actionElement.dataset.action;
            const taskId = actionElement.dataset.taskId || actionElement.dataset.id;
            const value = actionElement.dataset.value;

            switch (action) {
                case 'open-task':
                    if (taskId) openTaskDetail(taskId);
                    break;
                case 'delete-task':
                    if (taskId) {
                        currentEditingTaskId = taskId;
                        deleteTask();
                    }
                    break;
                case 'toggle-subtask':
                    if (taskId && value) toggleSubtask(taskId, value);
                    break;
                case 'close-modal':
                    const modalId = actionElement.dataset.modalId;
                    if (modalId) closeModal(modalId);
                    break;
                // Add more actions as needed
            }
        });

        // === INIT ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Restore activity sidebar state
            if (localStorage.getItem('activity-collapsed') === 'true') {
                const sidebar = document.getElementById('activity-sidebar');
                const icon = document.getElementById('activity-toggle-icon');
                const reopen = document.getElementById('activity-reopen');
                if (sidebar) sidebar.classList.add('collapsed');
                if (icon) icon.textContent = 'â˜°';
                if (reopen) reopen.style.display = 'flex';
            }
            // Auth is now handled by checkAuth() in the login script below
        });

        // Pause polling when tab not visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && STATE.token) {
                pollForUpdates();
            }
        });

        // Auto-refresh crons data every 5 minutes for live status updates
        let cronRefreshInterval = null;
        let cronRenderInterval = null;
        
        function startCronAutoRefresh() {
            if (cronRefreshInterval) clearInterval(cronRefreshInterval);
            if (cronRenderInterval) clearInterval(cronRenderInterval);
            
            // Re-render crons every 30 seconds to update running status
            cronRenderInterval = setInterval(() => {
                if (!document.hidden && STATE.crons && STATE.crons.length > 0) {
                    renderCrons();
                }
            }, 30 * 1000); // 30 seconds
            
            // Fetch fresh data from GitHub every 5 minutes
            cronRefreshInterval = setInterval(async () => {
                if (!document.hidden && STATE.token) {
                    try {
                        await loadCronsFromGitHub();
                        renderCrons();
                        console.log('ğŸ”„ Auto-refreshed cron data from GitHub');
                    } catch (e) {
                        console.warn('Auto-refresh crons failed:', e);
                    }
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        // Start auto-refresh after page loads
        setTimeout(startCronAutoRefresh, 10000); // Start 10s after load

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (STATE.hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>

    </div><!-- End Dashboard -->

    <script>
        // === LOGIN/AUTH GATE ===
        async function checkAuth() {
            // Check both old and new token keys, migrate if needed
            let token = localStorage.getItem('gh_token');
            if (!token) {
                const oldToken = localStorage.getItem('github_token');
                if (oldToken) {
                    // Migrate old token to new key
                    localStorage.setItem('gh_token', oldToken);
                    localStorage.removeItem('github_token');
                    localStorage.removeItem('github_user'); // Clean up old user data
                    token = oldToken;
                    console.log('Migrated token from github_token to gh_token');
                }
            }

            if (!token) {
                showLoginScreen();
                return;
            }

            // Validate token
            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                });

                if (response.ok) {
                    const user = await response.json();
                    STATE.token = token;
                    STATE.user = user;
                    showDashboard();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub(); // Load data after auth
                    await loadSkillsFromGitHub(); // Load skills for skill column
                    
                    // Auto-probe Gateway if not already configured
                    if (!getGatewayUrl()) {
                        autoProbeGateway().then(url => {
                            if (url) {
                                showToast('success', `Gateway connected: ${url.split('//')[1]}`);
                            }
                        });
                    }
                } else {
                    localStorage.removeItem('gh_token');
                    showLoginScreen();
                }
            } catch (e) {
                console.error('Auth check failed:', e);
                showLoginScreen();
            }
        }

        function showLoginScreen() {
            document.getElementById('login-screen').style.display = 'flex';
            document.getElementById('dashboard').style.display = 'none';
        }

        function showDashboard() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';

            // Update UI with user info
            if (STATE.user) {
                document.getElementById('btn-connect').style.display = 'none';
                document.getElementById('user-profile').style.display = 'flex';
                document.getElementById('user-avatar').src = STATE.user.avatar_url;
                document.getElementById('user-name').textContent = STATE.user.login;
            }
        }

        async function handleLogin() {
            const tokenInput = document.getElementById('login-token-input');
            const token = tokenInput.value.trim();
            const errorDiv = document.getElementById('login-error');
            const loadingDiv = document.getElementById('login-loading');
            const btn = document.getElementById('login-btn');

            if (!token) {
                errorDiv.textContent = 'Please enter a token';
                errorDiv.style.display = 'block';
                return;
            }

            // Show loading
            errorDiv.style.display = 'none';
            loadingDiv.style.display = 'flex';
            btn.disabled = true;

            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                });

                if (response.ok) {
                    const user = await response.json();
                    localStorage.setItem('gh_token', token);
                    STATE.token = token;
                    STATE.user = user;
                    showDashboard();
                    await loadTasksFromGitHub();
                    await loadCronsFromGitHub();
                } else {
                    errorDiv.textContent = 'Invalid token. Please check and try again.';
                    errorDiv.style.display = 'block';
                }
            } catch (e) {
                errorDiv.textContent = 'Connection error. Please try again.';
                errorDiv.style.display = 'block';
            } finally {
                loadingDiv.style.display = 'none';
                btn.disabled = false;
            }
        }

        // Handle Enter key on login input
        document.getElementById('login-token-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleLogin();
        });

        // Check auth on page load
        checkAuth();
    </script>
</body>
</html>
<!-- test Wed Jan 28 19:46:49 CET 2026 -->
<!-- webhook test 19:54:54 -->
<!-- test 19:55:37 -->
<!-- final test 19:56:16 -->
<!-- ctx debug 19:56:50 -->
<!-- real push test 20:18:59 -->
<!-- FINAL TEST 20:20:41 -->
